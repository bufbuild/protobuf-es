// Copyright 2021-2023 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import { describe, expect, test } from "@jest/globals";
import { UpstreamProtobuf } from "upstream-protobuf";
import { CodeGeneratorRequest } from "@bufbuild/protobuf";
import type { Schema } from "@bufbuild/protoplugin/ecmascript";
import { createEcmaScriptPlugin } from "@bufbuild/protoplugin";

describe("file preamble", () => {
  test("contains plugin name and version", async () => {
    const lines = await testGenerate(
      {
        "x.proto": `syntax="proto3";`,
      },
      {
        pluginName: "pi-plugin",
        pluginVersion: "v3.14159",
      },
    );
    expect(lines).toContain("// @generated by pi-plugin v3.14159");
  });

  test("contains plugin options", async () => {
    const lines = await testGenerate(
      {
        "x.proto": `syntax="proto3";`,
      },
      {
        parameter: "foo=bar,baz",
      },
    );
    expect(lines).toContain(
      `// @generated by test v1 with parameter "foo=bar,baz"`,
    );
  });

  test("elides rewrite_imports plugin option", async () => {
    const lines = await testGenerate(
      {
        "x.proto": `syntax="proto3";`,
      },
      {
        parameter:
          "foo,rewrite_imports=./test/*_pb.js:@buf/test,rewrite_imports=./test/*_web.js:@buf/web,bar",
      },
    );
    expect(lines).toContain(
      `// @generated by test v1 with parameter "foo,bar"`,
    );
  });

  test("contains source file info for proto3", async () => {
    const lines = await testGenerate({
      "x.proto": `syntax="proto3";`,
    });
    expect(lines).toContain("// @generated from file x.proto (syntax proto3)");
  });

  test("contains eslint-disable annotation", async () => {
    const lines = await testGenerate({
      "x.proto": `syntax="proto3";`,
    });
    expect(lines).toContain("/* eslint-disable */");
  });

  test("contains ts-nocheck annotation by default", async () => {
    const lines = await testGenerate({
      "x.proto": `syntax="proto3";`,
    });
    expect(lines).toContain("// @ts-nocheck");
  });

  test("does not contain ts-nocheck annotation when turned off", async () => {
    const lines = await testGenerate(
      {
        "x.proto": `syntax="proto3";`,
      },
      {
        parameter: "ts_nocheck=false",
      },
    );
    expect(lines).not.toContain("// @ts-nocheck");
  });

  test("contains source file info for proto2", async () => {
    const lines = await testGenerate({
      "x.proto": `syntax="proto2";`,
    });
    expect(lines).toContain("// @generated from file x.proto (syntax proto2)");
  });

  test("contains source file info for edition 2023", async () => {
    const lines = await testGenerate({
      "x.proto": `edition="2023";`,
    });
    expect(lines).toContain("// @generated from file x.proto (edition 2023)");
  });

  test("contains syntax comments", async () => {
    const lines = await testGenerate({
      "x.proto": `
                // comment above...
                // ... the syntax declaration
                syntax="proto3";
                `,
    });
    const firstLines = lines.slice(
      0,
      lines.indexOf("// @generated by test v1"),
    );
    expect(firstLines).toStrictEqual([
      "// comment above...",
      "// ... the syntax declaration",
      "",
    ]);
  });

  test("contains syntax comments with edition 2023", async () => {
    const lines = await testGenerate({
      "x.proto": `
                // comment above...
                // ... the syntax declaration
                edition="2023";
                `,
    });
    const firstLines = lines.slice(
      0,
      lines.indexOf("// @generated by test v1"),
    );
    expect(firstLines).toStrictEqual([
      "// comment above...",
      "// ... the syntax declaration",
      "",
    ]);
  });

  test("contains package comments", async () => {
    const lines = await testGenerate({
      "x.proto": `
                syntax="proto3";
                
                // comment above...
                // ... the package declaration
                package foo;
                `,
    });
    const lastLines = lines.slice(lines.indexOf("// @ts-nocheck"));
    expect(lastLines).toStrictEqual([
      "// @ts-nocheck",
      "",
      "// comment above...",
      "// ... the package declaration",
      "",
      "const placeholder = 1; // ensure file is not considered empty",
    ]);
  });

  // test helper to generate just a file with a preamble for each input proto file
  async function testGenerate(
    protoFiles: Record<string, string>,
    opt?: { parameter?: string; pluginName?: string; pluginVersion?: string },
  ) {
    const plugin = createEcmaScriptPlugin({
      name: opt?.pluginName ?? "test",
      version: opt?.pluginVersion ?? "v1",
      generateTs: generateFileWithPreamble,
      generateJs: generateFileWithPreamble,
      generateDts: generateFileWithPreamble,
      parseOption: () => {
        // accept all options
      },
    });

    function generateFileWithPreamble(
      schema: Schema,
      target: "js" | "ts" | "dts",
    ) {
      for (const file of schema.files) {
        const f = schema.generateFile(`${file.name}.${target}`);
        f.preamble(file);
        f.print(
          "const placeholder = 1; // ensure file is not considered empty",
        );
      }
    }

    const upstream = new UpstreamProtobuf();
    const req = CodeGeneratorRequest.fromBinary(
      await upstream.createCodeGeneratorRequest(protoFiles, {
        parameter: opt?.parameter,
      }),
    );
    expect(req.protoFile.length).toBe(1);
    const res = plugin.run(req);
    expect(res.file.length).toBeGreaterThanOrEqual(1);
    let content = res.file[0]?.content ?? "";
    if (content.endsWith("\n")) {
      content = content.slice(0, -1); // trim final newline so we don't return an extra line
    }
    return content.split("\n");
  }
});
