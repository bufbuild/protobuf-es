// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Author: benjy@google.com (Benjy Weinberger)
//  Based on original Protocol Buffers design by
//  Sanjay Ghemawat, Jeff Dean, and others.
//
// A proto file used to test the "custom options" feature of google.protobuf.

// @generated by protoc-gen-es v0.2.1 with parameter "ts_nocheck=false,target=ts"
// @generated from file google/protobuf/unittest_custom_options.proto (package protobuf_unittest, syntax proto2)
/* eslint-disable */

// We don't put this in a package within proto2 because we need to make sure
// that the generated code doesn't depend on being in the proto2 namespace.

import type {BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage} from "@bufbuild/protobuf";
import {Any, FileOptions, Message, proto2} from "@bufbuild/protobuf";

/**
 * @generated from enum protobuf_unittest.MethodOpt1
 */
export enum MethodOpt1 {
  /**
   * @generated from enum value: METHODOPT1_VAL1 = 1;
   */
  METHODOPT1_VAL1 = 1,

  /**
   * @generated from enum value: METHODOPT1_VAL2 = 2;
   */
  METHODOPT1_VAL2 = 2,
}
// Retrieve enum metadata with: proto2.getEnumType(MethodOpt1)
proto2.util.setEnumType(MethodOpt1, "protobuf_unittest.MethodOpt1", [
  { no: 1, name: "METHODOPT1_VAL1" },
  { no: 2, name: "METHODOPT1_VAL2" },
]);

/**
 * @generated from enum protobuf_unittest.AggregateEnum
 */
export enum AggregateEnum {
  /**
   * @generated from enum value: VALUE = 1;
   */
  VALUE = 1,
}
// Retrieve enum metadata with: proto2.getEnumType(AggregateEnum)
proto2.util.setEnumType(AggregateEnum, "protobuf_unittest.AggregateEnum", [
  { no: 1, name: "VALUE" },
]);

/**
 * A test message with custom options at all possible locations (and also some
 * regular options, to make sure they interact nicely).
 *
 * @generated from message protobuf_unittest.TestMessageWithCustomOptions
 */
export class TestMessageWithCustomOptions extends Message<TestMessageWithCustomOptions> {
  /**
   * @generated from field: optional string field1 = 1;
   */
  field1?: string;

  /**
   * @generated from oneof protobuf_unittest.TestMessageWithCustomOptions.AnOneof
   */
  AnOneof: {
    /**
     * @generated from field: int32 oneof_field = 2;
     */
    value: number;
    case: "oneofField";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * @generated from field: map<string, string> map_field = 3;
   */
  mapField: { [key: string]: string } = {};

  constructor(data?: PartialMessage<TestMessageWithCustomOptions>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime = proto2;
  static readonly typeName = "protobuf_unittest.TestMessageWithCustomOptions";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "field1", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "oneof_field", kind: "scalar", T: 5 /* ScalarType.INT32 */, oneof: "AnOneof" },
    { no: 3, name: "map_field", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestMessageWithCustomOptions {
    return new TestMessageWithCustomOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestMessageWithCustomOptions {
    return new TestMessageWithCustomOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestMessageWithCustomOptions {
    return new TestMessageWithCustomOptions().fromJsonString(jsonString, options);
  }

  static equals(a: TestMessageWithCustomOptions | PlainMessage<TestMessageWithCustomOptions> | undefined, b: TestMessageWithCustomOptions | PlainMessage<TestMessageWithCustomOptions> | undefined): boolean {
    return proto2.util.equals(TestMessageWithCustomOptions, a, b);
  }
}

/**
 * @generated from enum protobuf_unittest.TestMessageWithCustomOptions.AnEnum
 */
export enum TestMessageWithCustomOptions_AnEnum {
  /**
   * @generated from enum value: ANENUM_VAL1 = 1;
   */
  ANENUM_VAL1 = 1,

  /**
   * @generated from enum value: ANENUM_VAL2 = 2;
   */
  ANENUM_VAL2 = 2,
}
// Retrieve enum metadata with: proto2.getEnumType(TestMessageWithCustomOptions_AnEnum)
proto2.util.setEnumType(TestMessageWithCustomOptions_AnEnum, "protobuf_unittest.TestMessageWithCustomOptions.AnEnum", [
  { no: 1, name: "ANENUM_VAL1" },
  { no: 2, name: "ANENUM_VAL2" },
]);

/**
 * A test RPC service with custom options at all possible locations (and also
 * some regular options, to make sure they interact nicely).
 *
 * @generated from message protobuf_unittest.CustomOptionFooRequest
 */
export class CustomOptionFooRequest extends Message<CustomOptionFooRequest> {
  constructor(data?: PartialMessage<CustomOptionFooRequest>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime = proto2;
  static readonly typeName = "protobuf_unittest.CustomOptionFooRequest";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CustomOptionFooRequest {
    return new CustomOptionFooRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CustomOptionFooRequest {
    return new CustomOptionFooRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CustomOptionFooRequest {
    return new CustomOptionFooRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CustomOptionFooRequest | PlainMessage<CustomOptionFooRequest> | undefined, b: CustomOptionFooRequest | PlainMessage<CustomOptionFooRequest> | undefined): boolean {
    return proto2.util.equals(CustomOptionFooRequest, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.CustomOptionFooResponse
 */
export class CustomOptionFooResponse extends Message<CustomOptionFooResponse> {
  constructor(data?: PartialMessage<CustomOptionFooResponse>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime = proto2;
  static readonly typeName = "protobuf_unittest.CustomOptionFooResponse";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CustomOptionFooResponse {
    return new CustomOptionFooResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CustomOptionFooResponse {
    return new CustomOptionFooResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CustomOptionFooResponse {
    return new CustomOptionFooResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CustomOptionFooResponse | PlainMessage<CustomOptionFooResponse> | undefined, b: CustomOptionFooResponse | PlainMessage<CustomOptionFooResponse> | undefined): boolean {
    return proto2.util.equals(CustomOptionFooResponse, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.CustomOptionFooClientMessage
 */
export class CustomOptionFooClientMessage extends Message<CustomOptionFooClientMessage> {
  constructor(data?: PartialMessage<CustomOptionFooClientMessage>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime = proto2;
  static readonly typeName = "protobuf_unittest.CustomOptionFooClientMessage";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CustomOptionFooClientMessage {
    return new CustomOptionFooClientMessage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CustomOptionFooClientMessage {
    return new CustomOptionFooClientMessage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CustomOptionFooClientMessage {
    return new CustomOptionFooClientMessage().fromJsonString(jsonString, options);
  }

  static equals(a: CustomOptionFooClientMessage | PlainMessage<CustomOptionFooClientMessage> | undefined, b: CustomOptionFooClientMessage | PlainMessage<CustomOptionFooClientMessage> | undefined): boolean {
    return proto2.util.equals(CustomOptionFooClientMessage, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.CustomOptionFooServerMessage
 */
export class CustomOptionFooServerMessage extends Message<CustomOptionFooServerMessage> {
  constructor(data?: PartialMessage<CustomOptionFooServerMessage>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime = proto2;
  static readonly typeName = "protobuf_unittest.CustomOptionFooServerMessage";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CustomOptionFooServerMessage {
    return new CustomOptionFooServerMessage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CustomOptionFooServerMessage {
    return new CustomOptionFooServerMessage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CustomOptionFooServerMessage {
    return new CustomOptionFooServerMessage().fromJsonString(jsonString, options);
  }

  static equals(a: CustomOptionFooServerMessage | PlainMessage<CustomOptionFooServerMessage> | undefined, b: CustomOptionFooServerMessage | PlainMessage<CustomOptionFooServerMessage> | undefined): boolean {
    return proto2.util.equals(CustomOptionFooServerMessage, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.DummyMessageContainingEnum
 */
export class DummyMessageContainingEnum extends Message<DummyMessageContainingEnum> {
  constructor(data?: PartialMessage<DummyMessageContainingEnum>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime = proto2;
  static readonly typeName = "protobuf_unittest.DummyMessageContainingEnum";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DummyMessageContainingEnum {
    return new DummyMessageContainingEnum().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DummyMessageContainingEnum {
    return new DummyMessageContainingEnum().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DummyMessageContainingEnum {
    return new DummyMessageContainingEnum().fromJsonString(jsonString, options);
  }

  static equals(a: DummyMessageContainingEnum | PlainMessage<DummyMessageContainingEnum> | undefined, b: DummyMessageContainingEnum | PlainMessage<DummyMessageContainingEnum> | undefined): boolean {
    return proto2.util.equals(DummyMessageContainingEnum, a, b);
  }
}

/**
 * @generated from enum protobuf_unittest.DummyMessageContainingEnum.TestEnumType
 */
export enum DummyMessageContainingEnum_TestEnumType {
  /**
   * @generated from enum value: TEST_OPTION_ENUM_TYPE1 = 22;
   */
  TEST_OPTION_ENUM_TYPE1 = 22,

  /**
   * @generated from enum value: TEST_OPTION_ENUM_TYPE2 = -23;
   */
  TEST_OPTION_ENUM_TYPE2 = -23,
}
// Retrieve enum metadata with: proto2.getEnumType(DummyMessageContainingEnum_TestEnumType)
proto2.util.setEnumType(DummyMessageContainingEnum_TestEnumType, "protobuf_unittest.DummyMessageContainingEnum.TestEnumType", [
  { no: 22, name: "TEST_OPTION_ENUM_TYPE1" },
  { no: -23, name: "TEST_OPTION_ENUM_TYPE2" },
]);

/**
 * @generated from message protobuf_unittest.DummyMessageInvalidAsOptionType
 */
export class DummyMessageInvalidAsOptionType extends Message<DummyMessageInvalidAsOptionType> {
  constructor(data?: PartialMessage<DummyMessageInvalidAsOptionType>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime = proto2;
  static readonly typeName = "protobuf_unittest.DummyMessageInvalidAsOptionType";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DummyMessageInvalidAsOptionType {
    return new DummyMessageInvalidAsOptionType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DummyMessageInvalidAsOptionType {
    return new DummyMessageInvalidAsOptionType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DummyMessageInvalidAsOptionType {
    return new DummyMessageInvalidAsOptionType().fromJsonString(jsonString, options);
  }

  static equals(a: DummyMessageInvalidAsOptionType | PlainMessage<DummyMessageInvalidAsOptionType> | undefined, b: DummyMessageInvalidAsOptionType | PlainMessage<DummyMessageInvalidAsOptionType> | undefined): boolean {
    return proto2.util.equals(DummyMessageInvalidAsOptionType, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.CustomOptionMinIntegerValues
 */
export class CustomOptionMinIntegerValues extends Message<CustomOptionMinIntegerValues> {
  constructor(data?: PartialMessage<CustomOptionMinIntegerValues>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime = proto2;
  static readonly typeName = "protobuf_unittest.CustomOptionMinIntegerValues";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CustomOptionMinIntegerValues {
    return new CustomOptionMinIntegerValues().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CustomOptionMinIntegerValues {
    return new CustomOptionMinIntegerValues().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CustomOptionMinIntegerValues {
    return new CustomOptionMinIntegerValues().fromJsonString(jsonString, options);
  }

  static equals(a: CustomOptionMinIntegerValues | PlainMessage<CustomOptionMinIntegerValues> | undefined, b: CustomOptionMinIntegerValues | PlainMessage<CustomOptionMinIntegerValues> | undefined): boolean {
    return proto2.util.equals(CustomOptionMinIntegerValues, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.CustomOptionMaxIntegerValues
 */
export class CustomOptionMaxIntegerValues extends Message<CustomOptionMaxIntegerValues> {
  constructor(data?: PartialMessage<CustomOptionMaxIntegerValues>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime = proto2;
  static readonly typeName = "protobuf_unittest.CustomOptionMaxIntegerValues";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CustomOptionMaxIntegerValues {
    return new CustomOptionMaxIntegerValues().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CustomOptionMaxIntegerValues {
    return new CustomOptionMaxIntegerValues().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CustomOptionMaxIntegerValues {
    return new CustomOptionMaxIntegerValues().fromJsonString(jsonString, options);
  }

  static equals(a: CustomOptionMaxIntegerValues | PlainMessage<CustomOptionMaxIntegerValues> | undefined, b: CustomOptionMaxIntegerValues | PlainMessage<CustomOptionMaxIntegerValues> | undefined): boolean {
    return proto2.util.equals(CustomOptionMaxIntegerValues, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.CustomOptionOtherValues
 */
export class CustomOptionOtherValues extends Message<CustomOptionOtherValues> {
  constructor(data?: PartialMessage<CustomOptionOtherValues>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime = proto2;
  static readonly typeName = "protobuf_unittest.CustomOptionOtherValues";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CustomOptionOtherValues {
    return new CustomOptionOtherValues().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CustomOptionOtherValues {
    return new CustomOptionOtherValues().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CustomOptionOtherValues {
    return new CustomOptionOtherValues().fromJsonString(jsonString, options);
  }

  static equals(a: CustomOptionOtherValues | PlainMessage<CustomOptionOtherValues> | undefined, b: CustomOptionOtherValues | PlainMessage<CustomOptionOtherValues> | undefined): boolean {
    return proto2.util.equals(CustomOptionOtherValues, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.SettingRealsFromPositiveInts
 */
export class SettingRealsFromPositiveInts extends Message<SettingRealsFromPositiveInts> {
  constructor(data?: PartialMessage<SettingRealsFromPositiveInts>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime = proto2;
  static readonly typeName = "protobuf_unittest.SettingRealsFromPositiveInts";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SettingRealsFromPositiveInts {
    return new SettingRealsFromPositiveInts().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SettingRealsFromPositiveInts {
    return new SettingRealsFromPositiveInts().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SettingRealsFromPositiveInts {
    return new SettingRealsFromPositiveInts().fromJsonString(jsonString, options);
  }

  static equals(a: SettingRealsFromPositiveInts | PlainMessage<SettingRealsFromPositiveInts> | undefined, b: SettingRealsFromPositiveInts | PlainMessage<SettingRealsFromPositiveInts> | undefined): boolean {
    return proto2.util.equals(SettingRealsFromPositiveInts, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.SettingRealsFromNegativeInts
 */
export class SettingRealsFromNegativeInts extends Message<SettingRealsFromNegativeInts> {
  constructor(data?: PartialMessage<SettingRealsFromNegativeInts>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime = proto2;
  static readonly typeName = "protobuf_unittest.SettingRealsFromNegativeInts";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SettingRealsFromNegativeInts {
    return new SettingRealsFromNegativeInts().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SettingRealsFromNegativeInts {
    return new SettingRealsFromNegativeInts().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SettingRealsFromNegativeInts {
    return new SettingRealsFromNegativeInts().fromJsonString(jsonString, options);
  }

  static equals(a: SettingRealsFromNegativeInts | PlainMessage<SettingRealsFromNegativeInts> | undefined, b: SettingRealsFromNegativeInts | PlainMessage<SettingRealsFromNegativeInts> | undefined): boolean {
    return proto2.util.equals(SettingRealsFromNegativeInts, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.ComplexOptionType1
 */
export class ComplexOptionType1 extends Message<ComplexOptionType1> {
  /**
   * @generated from field: optional int32 foo = 1;
   */
  foo?: number;

  /**
   * @generated from field: optional int32 foo2 = 2;
   */
  foo2?: number;

  /**
   * @generated from field: optional int32 foo3 = 3;
   */
  foo3?: number;

  /**
   * @generated from field: repeated int32 foo4 = 4;
   */
  foo4: number[] = [];

  constructor(data?: PartialMessage<ComplexOptionType1>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime = proto2;
  static readonly typeName = "protobuf_unittest.ComplexOptionType1";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "foo", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 2, name: "foo2", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 3, name: "foo3", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 4, name: "foo4", kind: "scalar", T: 5 /* ScalarType.INT32 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ComplexOptionType1 {
    return new ComplexOptionType1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ComplexOptionType1 {
    return new ComplexOptionType1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ComplexOptionType1 {
    return new ComplexOptionType1().fromJsonString(jsonString, options);
  }

  static equals(a: ComplexOptionType1 | PlainMessage<ComplexOptionType1> | undefined, b: ComplexOptionType1 | PlainMessage<ComplexOptionType1> | undefined): boolean {
    return proto2.util.equals(ComplexOptionType1, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.ComplexOptionType2
 */
export class ComplexOptionType2 extends Message<ComplexOptionType2> {
  /**
   * @generated from field: optional protobuf_unittest.ComplexOptionType1 bar = 1;
   */
  bar?: ComplexOptionType1;

  /**
   * @generated from field: optional int32 baz = 2;
   */
  baz?: number;

  /**
   * @generated from field: optional protobuf_unittest.ComplexOptionType2.ComplexOptionType4 fred = 3;
   */
  fred?: ComplexOptionType2_ComplexOptionType4;

  /**
   * @generated from field: repeated protobuf_unittest.ComplexOptionType2.ComplexOptionType4 barney = 4;
   */
  barney: ComplexOptionType2_ComplexOptionType4[] = [];

  constructor(data?: PartialMessage<ComplexOptionType2>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime = proto2;
  static readonly typeName = "protobuf_unittest.ComplexOptionType2";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "bar", kind: "message", T: ComplexOptionType1, opt: true },
    { no: 2, name: "baz", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 3, name: "fred", kind: "message", T: ComplexOptionType2_ComplexOptionType4, opt: true },
    { no: 4, name: "barney", kind: "message", T: ComplexOptionType2_ComplexOptionType4, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ComplexOptionType2 {
    return new ComplexOptionType2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ComplexOptionType2 {
    return new ComplexOptionType2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ComplexOptionType2 {
    return new ComplexOptionType2().fromJsonString(jsonString, options);
  }

  static equals(a: ComplexOptionType2 | PlainMessage<ComplexOptionType2> | undefined, b: ComplexOptionType2 | PlainMessage<ComplexOptionType2> | undefined): boolean {
    return proto2.util.equals(ComplexOptionType2, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.ComplexOptionType2.ComplexOptionType4
 */
export class ComplexOptionType2_ComplexOptionType4 extends Message<ComplexOptionType2_ComplexOptionType4> {
  /**
   * @generated from field: optional int32 waldo = 1;
   */
  waldo?: number;

  constructor(data?: PartialMessage<ComplexOptionType2_ComplexOptionType4>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime = proto2;
  static readonly typeName = "protobuf_unittest.ComplexOptionType2.ComplexOptionType4";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "waldo", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ComplexOptionType2_ComplexOptionType4 {
    return new ComplexOptionType2_ComplexOptionType4().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ComplexOptionType2_ComplexOptionType4 {
    return new ComplexOptionType2_ComplexOptionType4().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ComplexOptionType2_ComplexOptionType4 {
    return new ComplexOptionType2_ComplexOptionType4().fromJsonString(jsonString, options);
  }

  static equals(a: ComplexOptionType2_ComplexOptionType4 | PlainMessage<ComplexOptionType2_ComplexOptionType4> | undefined, b: ComplexOptionType2_ComplexOptionType4 | PlainMessage<ComplexOptionType2_ComplexOptionType4> | undefined): boolean {
    return proto2.util.equals(ComplexOptionType2_ComplexOptionType4, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.ComplexOptionType3
 */
export class ComplexOptionType3 extends Message<ComplexOptionType3> {
  /**
   * @generated from field: optional int32 moo = 1;
   */
  moo?: number;

  /**
   * @generated from field: optional protobuf_unittest.ComplexOptionType3.ComplexOptionType5 complexoptiontype5 = 2;
   */
  complexoptiontype5?: ComplexOptionType3_ComplexOptionType5;

  constructor(data?: PartialMessage<ComplexOptionType3>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime = proto2;
  static readonly typeName = "protobuf_unittest.ComplexOptionType3";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "moo", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 2, name: "complexoptiontype5", kind: "message", T: ComplexOptionType3_ComplexOptionType5, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ComplexOptionType3 {
    return new ComplexOptionType3().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ComplexOptionType3 {
    return new ComplexOptionType3().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ComplexOptionType3 {
    return new ComplexOptionType3().fromJsonString(jsonString, options);
  }

  static equals(a: ComplexOptionType3 | PlainMessage<ComplexOptionType3> | undefined, b: ComplexOptionType3 | PlainMessage<ComplexOptionType3> | undefined): boolean {
    return proto2.util.equals(ComplexOptionType3, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.ComplexOptionType3.ComplexOptionType5
 */
export class ComplexOptionType3_ComplexOptionType5 extends Message<ComplexOptionType3_ComplexOptionType5> {
  /**
   * @generated from field: optional int32 plugh = 3;
   */
  plugh?: number;

  constructor(data?: PartialMessage<ComplexOptionType3_ComplexOptionType5>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime = proto2;
  static readonly typeName = "protobuf_unittest.ComplexOptionType3.ComplexOptionType5";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 3, name: "plugh", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ComplexOptionType3_ComplexOptionType5 {
    return new ComplexOptionType3_ComplexOptionType5().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ComplexOptionType3_ComplexOptionType5 {
    return new ComplexOptionType3_ComplexOptionType5().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ComplexOptionType3_ComplexOptionType5 {
    return new ComplexOptionType3_ComplexOptionType5().fromJsonString(jsonString, options);
  }

  static equals(a: ComplexOptionType3_ComplexOptionType5 | PlainMessage<ComplexOptionType3_ComplexOptionType5> | undefined, b: ComplexOptionType3_ComplexOptionType5 | PlainMessage<ComplexOptionType3_ComplexOptionType5> | undefined): boolean {
    return proto2.util.equals(ComplexOptionType3_ComplexOptionType5, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.ComplexOpt6
 */
export class ComplexOpt6 extends Message<ComplexOpt6> {
  /**
   * @generated from field: optional int32 xyzzy = 7593951;
   */
  xyzzy?: number;

  constructor(data?: PartialMessage<ComplexOpt6>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime = proto2;
  static readonly typeName = "protobuf_unittest.ComplexOpt6";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 7593951, name: "xyzzy", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ComplexOpt6 {
    return new ComplexOpt6().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ComplexOpt6 {
    return new ComplexOpt6().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ComplexOpt6 {
    return new ComplexOpt6().fromJsonString(jsonString, options);
  }

  static equals(a: ComplexOpt6 | PlainMessage<ComplexOpt6> | undefined, b: ComplexOpt6 | PlainMessage<ComplexOpt6> | undefined): boolean {
    return proto2.util.equals(ComplexOpt6, a, b);
  }
}

/**
 * Note that we try various different ways of naming the same extension.
 *
 * @generated from message protobuf_unittest.VariousComplexOptions
 */
export class VariousComplexOptions extends Message<VariousComplexOptions> {
  constructor(data?: PartialMessage<VariousComplexOptions>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime = proto2;
  static readonly typeName = "protobuf_unittest.VariousComplexOptions";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VariousComplexOptions {
    return new VariousComplexOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VariousComplexOptions {
    return new VariousComplexOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VariousComplexOptions {
    return new VariousComplexOptions().fromJsonString(jsonString, options);
  }

  static equals(a: VariousComplexOptions | PlainMessage<VariousComplexOptions> | undefined, b: VariousComplexOptions | PlainMessage<VariousComplexOptions> | undefined): boolean {
    return proto2.util.equals(VariousComplexOptions, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.AggregateMessageSet
 */
export class AggregateMessageSet extends Message<AggregateMessageSet> {
  constructor(data?: PartialMessage<AggregateMessageSet>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime = proto2;
  static readonly typeName = "protobuf_unittest.AggregateMessageSet";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AggregateMessageSet {
    return new AggregateMessageSet().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AggregateMessageSet {
    return new AggregateMessageSet().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AggregateMessageSet {
    return new AggregateMessageSet().fromJsonString(jsonString, options);
  }

  static equals(a: AggregateMessageSet | PlainMessage<AggregateMessageSet> | undefined, b: AggregateMessageSet | PlainMessage<AggregateMessageSet> | undefined): boolean {
    return proto2.util.equals(AggregateMessageSet, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.AggregateMessageSetElement
 */
export class AggregateMessageSetElement extends Message<AggregateMessageSetElement> {
  /**
   * @generated from field: optional string s = 1;
   */
  s?: string;

  constructor(data?: PartialMessage<AggregateMessageSetElement>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime = proto2;
  static readonly typeName = "protobuf_unittest.AggregateMessageSetElement";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "s", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AggregateMessageSetElement {
    return new AggregateMessageSetElement().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AggregateMessageSetElement {
    return new AggregateMessageSetElement().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AggregateMessageSetElement {
    return new AggregateMessageSetElement().fromJsonString(jsonString, options);
  }

  static equals(a: AggregateMessageSetElement | PlainMessage<AggregateMessageSetElement> | undefined, b: AggregateMessageSetElement | PlainMessage<AggregateMessageSetElement> | undefined): boolean {
    return proto2.util.equals(AggregateMessageSetElement, a, b);
  }
}

/**
 * A helper type used to test aggregate option parsing
 *
 * @generated from message protobuf_unittest.Aggregate
 */
export class Aggregate extends Message<Aggregate> {
  /**
   * @generated from field: optional int32 i = 1;
   */
  i?: number;

  /**
   * @generated from field: optional string s = 2;
   */
  s?: string;

  /**
   * A nested object
   *
   * @generated from field: optional protobuf_unittest.Aggregate sub = 3;
   */
  sub?: Aggregate;

  /**
   * To test the parsing of extensions inside aggregate values
   *
   * @generated from field: optional google.protobuf.FileOptions file = 4;
   */
  file?: FileOptions;

  /**
   * An embedded message set
   *
   * @generated from field: optional protobuf_unittest.AggregateMessageSet mset = 5;
   */
  mset?: AggregateMessageSet;

  /**
   * An any
   *
   * @generated from field: optional google.protobuf.Any any = 6;
   */
  any?: Any;

  constructor(data?: PartialMessage<Aggregate>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime = proto2;
  static readonly typeName = "protobuf_unittest.Aggregate";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "i", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 2, name: "s", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "sub", kind: "message", T: Aggregate, opt: true },
    { no: 4, name: "file", kind: "message", T: FileOptions, opt: true },
    { no: 5, name: "mset", kind: "message", T: AggregateMessageSet, opt: true },
    { no: 6, name: "any", kind: "message", T: Any, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Aggregate {
    return new Aggregate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Aggregate {
    return new Aggregate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Aggregate {
    return new Aggregate().fromJsonString(jsonString, options);
  }

  static equals(a: Aggregate | PlainMessage<Aggregate> | undefined, b: Aggregate | PlainMessage<Aggregate> | undefined): boolean {
    return proto2.util.equals(Aggregate, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.AggregateMessage
 */
export class AggregateMessage extends Message<AggregateMessage> {
  /**
   * @generated from field: optional int32 fieldname = 1;
   */
  fieldname?: number;

  constructor(data?: PartialMessage<AggregateMessage>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime = proto2;
  static readonly typeName = "protobuf_unittest.AggregateMessage";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "fieldname", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AggregateMessage {
    return new AggregateMessage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AggregateMessage {
    return new AggregateMessage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AggregateMessage {
    return new AggregateMessage().fromJsonString(jsonString, options);
  }

  static equals(a: AggregateMessage | PlainMessage<AggregateMessage> | undefined, b: AggregateMessage | PlainMessage<AggregateMessage> | undefined): boolean {
    return proto2.util.equals(AggregateMessage, a, b);
  }
}

/**
 * Test custom options for nested type.
 *
 * @generated from message protobuf_unittest.NestedOptionType
 */
export class NestedOptionType extends Message<NestedOptionType> {
  constructor(data?: PartialMessage<NestedOptionType>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime = proto2;
  static readonly typeName = "protobuf_unittest.NestedOptionType";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NestedOptionType {
    return new NestedOptionType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NestedOptionType {
    return new NestedOptionType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NestedOptionType {
    return new NestedOptionType().fromJsonString(jsonString, options);
  }

  static equals(a: NestedOptionType | PlainMessage<NestedOptionType> | undefined, b: NestedOptionType | PlainMessage<NestedOptionType> | undefined): boolean {
    return proto2.util.equals(NestedOptionType, a, b);
  }
}

/**
 * @generated from enum protobuf_unittest.NestedOptionType.NestedEnum
 */
export enum NestedOptionType_NestedEnum {
  /**
   * @generated from enum value: NESTED_ENUM_VALUE = 1;
   */
  VALUE = 1,
}
// Retrieve enum metadata with: proto2.getEnumType(NestedOptionType_NestedEnum)
proto2.util.setEnumType(NestedOptionType_NestedEnum, "protobuf_unittest.NestedOptionType.NestedEnum", [
  { no: 1, name: "NESTED_ENUM_VALUE" },
]);

/**
 * @generated from message protobuf_unittest.NestedOptionType.NestedMessage
 */
export class NestedOptionType_NestedMessage extends Message<NestedOptionType_NestedMessage> {
  /**
   * @generated from field: optional int32 nested_field = 1;
   */
  nestedField?: number;

  constructor(data?: PartialMessage<NestedOptionType_NestedMessage>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime = proto2;
  static readonly typeName = "protobuf_unittest.NestedOptionType.NestedMessage";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "nested_field", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NestedOptionType_NestedMessage {
    return new NestedOptionType_NestedMessage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NestedOptionType_NestedMessage {
    return new NestedOptionType_NestedMessage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NestedOptionType_NestedMessage {
    return new NestedOptionType_NestedMessage().fromJsonString(jsonString, options);
  }

  static equals(a: NestedOptionType_NestedMessage | PlainMessage<NestedOptionType_NestedMessage> | undefined, b: NestedOptionType_NestedMessage | PlainMessage<NestedOptionType_NestedMessage> | undefined): boolean {
    return proto2.util.equals(NestedOptionType_NestedMessage, a, b);
  }
}

/**
 * Custom message option that has a required enum field.
 * WARNING: this is strongly discouraged!
 *
 * @generated from message protobuf_unittest.OldOptionType
 */
export class OldOptionType extends Message<OldOptionType> {
  /**
   * @generated from field: required protobuf_unittest.OldOptionType.TestEnum value = 1;
   */
  value?: OldOptionType_TestEnum;

  constructor(data?: PartialMessage<OldOptionType>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime = proto2;
  static readonly typeName = "protobuf_unittest.OldOptionType";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "value", kind: "enum", T: proto2.getEnumType(OldOptionType_TestEnum) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OldOptionType {
    return new OldOptionType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OldOptionType {
    return new OldOptionType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OldOptionType {
    return new OldOptionType().fromJsonString(jsonString, options);
  }

  static equals(a: OldOptionType | PlainMessage<OldOptionType> | undefined, b: OldOptionType | PlainMessage<OldOptionType> | undefined): boolean {
    return proto2.util.equals(OldOptionType, a, b);
  }
}

/**
 * @generated from enum protobuf_unittest.OldOptionType.TestEnum
 */
export enum OldOptionType_TestEnum {
  /**
   * @generated from enum value: OLD_VALUE = 0;
   */
  OLD_VALUE = 0,
}
// Retrieve enum metadata with: proto2.getEnumType(OldOptionType_TestEnum)
proto2.util.setEnumType(OldOptionType_TestEnum, "protobuf_unittest.OldOptionType.TestEnum", [
  { no: 0, name: "OLD_VALUE" },
]);

/**
 * Updated version of the custom option above.
 *
 * @generated from message protobuf_unittest.NewOptionType
 */
export class NewOptionType extends Message<NewOptionType> {
  /**
   * @generated from field: required protobuf_unittest.NewOptionType.TestEnum value = 1;
   */
  value?: NewOptionType_TestEnum;

  constructor(data?: PartialMessage<NewOptionType>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime = proto2;
  static readonly typeName = "protobuf_unittest.NewOptionType";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "value", kind: "enum", T: proto2.getEnumType(NewOptionType_TestEnum) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NewOptionType {
    return new NewOptionType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NewOptionType {
    return new NewOptionType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NewOptionType {
    return new NewOptionType().fromJsonString(jsonString, options);
  }

  static equals(a: NewOptionType | PlainMessage<NewOptionType> | undefined, b: NewOptionType | PlainMessage<NewOptionType> | undefined): boolean {
    return proto2.util.equals(NewOptionType, a, b);
  }
}

/**
 * @generated from enum protobuf_unittest.NewOptionType.TestEnum
 */
export enum NewOptionType_TestEnum {
  /**
   * @generated from enum value: OLD_VALUE = 0;
   */
  OLD_VALUE = 0,

  /**
   * @generated from enum value: NEW_VALUE = 1;
   */
  NEW_VALUE = 1,
}
// Retrieve enum metadata with: proto2.getEnumType(NewOptionType_TestEnum)
proto2.util.setEnumType(NewOptionType_TestEnum, "protobuf_unittest.NewOptionType.TestEnum", [
  { no: 0, name: "OLD_VALUE" },
  { no: 1, name: "NEW_VALUE" },
]);

/**
 * Test message using the "required_enum_opt" option defined above.
 *
 * @generated from message protobuf_unittest.TestMessageWithRequiredEnumOption
 */
export class TestMessageWithRequiredEnumOption extends Message<TestMessageWithRequiredEnumOption> {
  constructor(data?: PartialMessage<TestMessageWithRequiredEnumOption>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime = proto2;
  static readonly typeName = "protobuf_unittest.TestMessageWithRequiredEnumOption";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestMessageWithRequiredEnumOption {
    return new TestMessageWithRequiredEnumOption().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestMessageWithRequiredEnumOption {
    return new TestMessageWithRequiredEnumOption().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestMessageWithRequiredEnumOption {
    return new TestMessageWithRequiredEnumOption().fromJsonString(jsonString, options);
  }

  static equals(a: TestMessageWithRequiredEnumOption | PlainMessage<TestMessageWithRequiredEnumOption> | undefined, b: TestMessageWithRequiredEnumOption | PlainMessage<TestMessageWithRequiredEnumOption> | undefined): boolean {
    return proto2.util.equals(TestMessageWithRequiredEnumOption, a, b);
  }
}

