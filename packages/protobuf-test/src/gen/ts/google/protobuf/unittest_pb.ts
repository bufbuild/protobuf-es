// Copyright 2021-2024 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Author: kenton@google.com (Kenton Varda)
//  Based on original Protocol Buffers design by
//  Sanjay Ghemawat, Jeff Dean, and others.
//
// A proto file we will use for unit testing.
//
// LINT: ALLOW_GROUPS, LEGACY_NAMES

// @generated by protoc-gen-es v1.7.2 with parameter "ts_nocheck=false,target=ts"
// @generated from file google/protobuf/unittest.proto (package protobuf_unittest, syntax proto2)
/* eslint-disable */

// We don't put this in a package within proto2 because we need to make sure
// that the generated code doesn't depend on being in the proto2 namespace.
// In test_util.h we do "using namespace unittest = protobuf_unittest".

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto2, protoDouble, protoInt64 } from "@bufbuild/protobuf";
import { ImportEnum, ImportMessage } from "./unittest_import_pb.js";
import { PublicImportMessage } from "./unittest_import_public_pb.js";

/**
 * @generated from enum protobuf_unittest.ForeignEnum
 */
export enum ForeignEnum {
  /**
   * @generated from enum value: FOREIGN_FOO = 4;
   */
  FOREIGN_FOO = 4,

  /**
   * @generated from enum value: FOREIGN_BAR = 5;
   */
  FOREIGN_BAR = 5,

  /**
   * @generated from enum value: FOREIGN_BAZ = 6;
   */
  FOREIGN_BAZ = 6,

  /**
   * (1 << 32) to generate a 64b bitmask would be incorrect.
   *
   * @generated from enum value: FOREIGN_BAX = 32;
   */
  FOREIGN_BAX = 32,
}
// Retrieve enum metadata with: proto2.getEnumType(ForeignEnum)
proto2.util.setEnumType(ForeignEnum, "protobuf_unittest.ForeignEnum", [
  { no: 4, name: "FOREIGN_FOO" },
  { no: 5, name: "FOREIGN_BAR" },
  { no: 6, name: "FOREIGN_BAZ" },
  { no: 32, name: "FOREIGN_BAX" },
]);

/**
 * @generated from enum protobuf_unittest.TestReservedEnumFields
 */
export enum TestReservedEnumFields {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,
}
// Retrieve enum metadata with: proto2.getEnumType(TestReservedEnumFields)
proto2.util.setEnumType(TestReservedEnumFields, "protobuf_unittest.TestReservedEnumFields", [
  { no: 0, name: "UNKNOWN" },
]);

/**
 * Test an enum that has multiple values with the same number.
 *
 * @generated from enum protobuf_unittest.TestEnumWithDupValue
 */
export enum TestEnumWithDupValue {
  /**
   * @generated from enum value: FOO1 = 1;
   */
  FOO1 = 1,

  /**
   * @generated from enum value: BAR1 = 2;
   */
  BAR1 = 2,

  /**
   * @generated from enum value: BAZ = 3;
   */
  BAZ = 3,

  /**
   * @generated from enum value: FOO2 = 1;
   */
  FOO2 = 1,

  /**
   * @generated from enum value: BAR2 = 2;
   */
  BAR2 = 2,
}
// Retrieve enum metadata with: proto2.getEnumType(TestEnumWithDupValue)
proto2.util.setEnumType(TestEnumWithDupValue, "protobuf_unittest.TestEnumWithDupValue", [
  { no: 1, name: "FOO1" },
  { no: 2, name: "BAR1" },
  { no: 3, name: "BAZ" },
  { no: 1, name: "FOO2" },
  { no: 2, name: "BAR2" },
]);

/**
 * Test an enum with large, unordered values.
 *
 * @generated from enum protobuf_unittest.TestSparseEnum
 */
export enum TestSparseEnum {
  /**
   * @generated from enum value: SPARSE_A = 123;
   */
  SPARSE_A = 123,

  /**
   * @generated from enum value: SPARSE_B = 62374;
   */
  SPARSE_B = 62374,

  /**
   * @generated from enum value: SPARSE_C = 12589234;
   */
  SPARSE_C = 12589234,

  /**
   * @generated from enum value: SPARSE_D = -15;
   */
  SPARSE_D = -15,

  /**
   * @generated from enum value: SPARSE_E = -53452;
   */
  SPARSE_E = -53452,

  /**
   * @generated from enum value: SPARSE_F = 0;
   */
  SPARSE_F = 0,

  /**
   * @generated from enum value: SPARSE_G = 2;
   */
  SPARSE_G = 2,
}
// Retrieve enum metadata with: proto2.getEnumType(TestSparseEnum)
proto2.util.setEnumType(TestSparseEnum, "protobuf_unittest.TestSparseEnum", [
  { no: 123, name: "SPARSE_A" },
  { no: 62374, name: "SPARSE_B" },
  { no: 12589234, name: "SPARSE_C" },
  { no: -15, name: "SPARSE_D" },
  { no: -53452, name: "SPARSE_E" },
  { no: 0, name: "SPARSE_F" },
  { no: 2, name: "SPARSE_G" },
]);

/**
 * @generated from enum protobuf_unittest.VeryLargeEnum
 */
export enum VeryLargeEnum {
  /**
   * @generated from enum value: ENUM_LABEL_DEFAULT = 0;
   */
  ENUM_LABEL_DEFAULT = 0,

  /**
   * @generated from enum value: ENUM_LABEL_1 = 1;
   */
  ENUM_LABEL_1 = 1,

  /**
   * @generated from enum value: ENUM_LABEL_2 = 2;
   */
  ENUM_LABEL_2 = 2,

  /**
   * @generated from enum value: ENUM_LABEL_3 = 3;
   */
  ENUM_LABEL_3 = 3,

  /**
   * @generated from enum value: ENUM_LABEL_4 = 4;
   */
  ENUM_LABEL_4 = 4,

  /**
   * @generated from enum value: ENUM_LABEL_5 = 5;
   */
  ENUM_LABEL_5 = 5,

  /**
   * @generated from enum value: ENUM_LABEL_6 = 6;
   */
  ENUM_LABEL_6 = 6,

  /**
   * @generated from enum value: ENUM_LABEL_7 = 7;
   */
  ENUM_LABEL_7 = 7,

  /**
   * @generated from enum value: ENUM_LABEL_8 = 8;
   */
  ENUM_LABEL_8 = 8,

  /**
   * @generated from enum value: ENUM_LABEL_9 = 9;
   */
  ENUM_LABEL_9 = 9,

  /**
   * @generated from enum value: ENUM_LABEL_10 = 10;
   */
  ENUM_LABEL_10 = 10,

  /**
   * @generated from enum value: ENUM_LABEL_11 = 11;
   */
  ENUM_LABEL_11 = 11,

  /**
   * @generated from enum value: ENUM_LABEL_12 = 12;
   */
  ENUM_LABEL_12 = 12,

  /**
   * @generated from enum value: ENUM_LABEL_13 = 13;
   */
  ENUM_LABEL_13 = 13,

  /**
   * @generated from enum value: ENUM_LABEL_14 = 14;
   */
  ENUM_LABEL_14 = 14,

  /**
   * @generated from enum value: ENUM_LABEL_15 = 15;
   */
  ENUM_LABEL_15 = 15,

  /**
   * @generated from enum value: ENUM_LABEL_16 = 16;
   */
  ENUM_LABEL_16 = 16,

  /**
   * @generated from enum value: ENUM_LABEL_17 = 17;
   */
  ENUM_LABEL_17 = 17,

  /**
   * @generated from enum value: ENUM_LABEL_18 = 18;
   */
  ENUM_LABEL_18 = 18,

  /**
   * @generated from enum value: ENUM_LABEL_19 = 19;
   */
  ENUM_LABEL_19 = 19,

  /**
   * @generated from enum value: ENUM_LABEL_20 = 20;
   */
  ENUM_LABEL_20 = 20,

  /**
   * @generated from enum value: ENUM_LABEL_21 = 21;
   */
  ENUM_LABEL_21 = 21,

  /**
   * @generated from enum value: ENUM_LABEL_22 = 22;
   */
  ENUM_LABEL_22 = 22,

  /**
   * @generated from enum value: ENUM_LABEL_23 = 23;
   */
  ENUM_LABEL_23 = 23,

  /**
   * @generated from enum value: ENUM_LABEL_24 = 24;
   */
  ENUM_LABEL_24 = 24,

  /**
   * @generated from enum value: ENUM_LABEL_25 = 25;
   */
  ENUM_LABEL_25 = 25,

  /**
   * @generated from enum value: ENUM_LABEL_26 = 26;
   */
  ENUM_LABEL_26 = 26,

  /**
   * @generated from enum value: ENUM_LABEL_27 = 27;
   */
  ENUM_LABEL_27 = 27,

  /**
   * @generated from enum value: ENUM_LABEL_28 = 28;
   */
  ENUM_LABEL_28 = 28,

  /**
   * @generated from enum value: ENUM_LABEL_29 = 29;
   */
  ENUM_LABEL_29 = 29,

  /**
   * @generated from enum value: ENUM_LABEL_30 = 30;
   */
  ENUM_LABEL_30 = 30,

  /**
   * @generated from enum value: ENUM_LABEL_31 = 31;
   */
  ENUM_LABEL_31 = 31,

  /**
   * @generated from enum value: ENUM_LABEL_32 = 32;
   */
  ENUM_LABEL_32 = 32,

  /**
   * @generated from enum value: ENUM_LABEL_33 = 33;
   */
  ENUM_LABEL_33 = 33,

  /**
   * @generated from enum value: ENUM_LABEL_34 = 34;
   */
  ENUM_LABEL_34 = 34,

  /**
   * @generated from enum value: ENUM_LABEL_35 = 35;
   */
  ENUM_LABEL_35 = 35,

  /**
   * @generated from enum value: ENUM_LABEL_36 = 36;
   */
  ENUM_LABEL_36 = 36,

  /**
   * @generated from enum value: ENUM_LABEL_37 = 37;
   */
  ENUM_LABEL_37 = 37,

  /**
   * @generated from enum value: ENUM_LABEL_38 = 38;
   */
  ENUM_LABEL_38 = 38,

  /**
   * @generated from enum value: ENUM_LABEL_39 = 39;
   */
  ENUM_LABEL_39 = 39,

  /**
   * @generated from enum value: ENUM_LABEL_40 = 40;
   */
  ENUM_LABEL_40 = 40,

  /**
   * @generated from enum value: ENUM_LABEL_41 = 41;
   */
  ENUM_LABEL_41 = 41,

  /**
   * @generated from enum value: ENUM_LABEL_42 = 42;
   */
  ENUM_LABEL_42 = 42,

  /**
   * @generated from enum value: ENUM_LABEL_43 = 43;
   */
  ENUM_LABEL_43 = 43,

  /**
   * @generated from enum value: ENUM_LABEL_44 = 44;
   */
  ENUM_LABEL_44 = 44,

  /**
   * @generated from enum value: ENUM_LABEL_45 = 45;
   */
  ENUM_LABEL_45 = 45,

  /**
   * @generated from enum value: ENUM_LABEL_46 = 46;
   */
  ENUM_LABEL_46 = 46,

  /**
   * @generated from enum value: ENUM_LABEL_47 = 47;
   */
  ENUM_LABEL_47 = 47,

  /**
   * @generated from enum value: ENUM_LABEL_48 = 48;
   */
  ENUM_LABEL_48 = 48,

  /**
   * @generated from enum value: ENUM_LABEL_49 = 49;
   */
  ENUM_LABEL_49 = 49,

  /**
   * @generated from enum value: ENUM_LABEL_50 = 50;
   */
  ENUM_LABEL_50 = 50,

  /**
   * @generated from enum value: ENUM_LABEL_51 = 51;
   */
  ENUM_LABEL_51 = 51,

  /**
   * @generated from enum value: ENUM_LABEL_52 = 52;
   */
  ENUM_LABEL_52 = 52,

  /**
   * @generated from enum value: ENUM_LABEL_53 = 53;
   */
  ENUM_LABEL_53 = 53,

  /**
   * @generated from enum value: ENUM_LABEL_54 = 54;
   */
  ENUM_LABEL_54 = 54,

  /**
   * @generated from enum value: ENUM_LABEL_55 = 55;
   */
  ENUM_LABEL_55 = 55,

  /**
   * @generated from enum value: ENUM_LABEL_56 = 56;
   */
  ENUM_LABEL_56 = 56,

  /**
   * @generated from enum value: ENUM_LABEL_57 = 57;
   */
  ENUM_LABEL_57 = 57,

  /**
   * @generated from enum value: ENUM_LABEL_58 = 58;
   */
  ENUM_LABEL_58 = 58,

  /**
   * @generated from enum value: ENUM_LABEL_59 = 59;
   */
  ENUM_LABEL_59 = 59,

  /**
   * @generated from enum value: ENUM_LABEL_60 = 60;
   */
  ENUM_LABEL_60 = 60,

  /**
   * @generated from enum value: ENUM_LABEL_61 = 61;
   */
  ENUM_LABEL_61 = 61,

  /**
   * @generated from enum value: ENUM_LABEL_62 = 62;
   */
  ENUM_LABEL_62 = 62,

  /**
   * @generated from enum value: ENUM_LABEL_63 = 63;
   */
  ENUM_LABEL_63 = 63,

  /**
   * @generated from enum value: ENUM_LABEL_64 = 64;
   */
  ENUM_LABEL_64 = 64,

  /**
   * @generated from enum value: ENUM_LABEL_65 = 65;
   */
  ENUM_LABEL_65 = 65,

  /**
   * @generated from enum value: ENUM_LABEL_66 = 66;
   */
  ENUM_LABEL_66 = 66,

  /**
   * @generated from enum value: ENUM_LABEL_67 = 67;
   */
  ENUM_LABEL_67 = 67,

  /**
   * @generated from enum value: ENUM_LABEL_68 = 68;
   */
  ENUM_LABEL_68 = 68,

  /**
   * @generated from enum value: ENUM_LABEL_69 = 69;
   */
  ENUM_LABEL_69 = 69,

  /**
   * @generated from enum value: ENUM_LABEL_70 = 70;
   */
  ENUM_LABEL_70 = 70,

  /**
   * @generated from enum value: ENUM_LABEL_71 = 71;
   */
  ENUM_LABEL_71 = 71,

  /**
   * @generated from enum value: ENUM_LABEL_72 = 72;
   */
  ENUM_LABEL_72 = 72,

  /**
   * @generated from enum value: ENUM_LABEL_73 = 73;
   */
  ENUM_LABEL_73 = 73,

  /**
   * @generated from enum value: ENUM_LABEL_74 = 74;
   */
  ENUM_LABEL_74 = 74,

  /**
   * @generated from enum value: ENUM_LABEL_75 = 75;
   */
  ENUM_LABEL_75 = 75,

  /**
   * @generated from enum value: ENUM_LABEL_76 = 76;
   */
  ENUM_LABEL_76 = 76,

  /**
   * @generated from enum value: ENUM_LABEL_77 = 77;
   */
  ENUM_LABEL_77 = 77,

  /**
   * @generated from enum value: ENUM_LABEL_78 = 78;
   */
  ENUM_LABEL_78 = 78,

  /**
   * @generated from enum value: ENUM_LABEL_79 = 79;
   */
  ENUM_LABEL_79 = 79,

  /**
   * @generated from enum value: ENUM_LABEL_80 = 80;
   */
  ENUM_LABEL_80 = 80,

  /**
   * @generated from enum value: ENUM_LABEL_81 = 81;
   */
  ENUM_LABEL_81 = 81,

  /**
   * @generated from enum value: ENUM_LABEL_82 = 82;
   */
  ENUM_LABEL_82 = 82,

  /**
   * @generated from enum value: ENUM_LABEL_83 = 83;
   */
  ENUM_LABEL_83 = 83,

  /**
   * @generated from enum value: ENUM_LABEL_84 = 84;
   */
  ENUM_LABEL_84 = 84,

  /**
   * @generated from enum value: ENUM_LABEL_85 = 85;
   */
  ENUM_LABEL_85 = 85,

  /**
   * @generated from enum value: ENUM_LABEL_86 = 86;
   */
  ENUM_LABEL_86 = 86,

  /**
   * @generated from enum value: ENUM_LABEL_87 = 87;
   */
  ENUM_LABEL_87 = 87,

  /**
   * @generated from enum value: ENUM_LABEL_88 = 88;
   */
  ENUM_LABEL_88 = 88,

  /**
   * @generated from enum value: ENUM_LABEL_89 = 89;
   */
  ENUM_LABEL_89 = 89,

  /**
   * @generated from enum value: ENUM_LABEL_90 = 90;
   */
  ENUM_LABEL_90 = 90,

  /**
   * @generated from enum value: ENUM_LABEL_91 = 91;
   */
  ENUM_LABEL_91 = 91,

  /**
   * @generated from enum value: ENUM_LABEL_92 = 92;
   */
  ENUM_LABEL_92 = 92,

  /**
   * @generated from enum value: ENUM_LABEL_93 = 93;
   */
  ENUM_LABEL_93 = 93,

  /**
   * @generated from enum value: ENUM_LABEL_94 = 94;
   */
  ENUM_LABEL_94 = 94,

  /**
   * @generated from enum value: ENUM_LABEL_95 = 95;
   */
  ENUM_LABEL_95 = 95,

  /**
   * @generated from enum value: ENUM_LABEL_96 = 96;
   */
  ENUM_LABEL_96 = 96,

  /**
   * @generated from enum value: ENUM_LABEL_97 = 97;
   */
  ENUM_LABEL_97 = 97,

  /**
   * @generated from enum value: ENUM_LABEL_98 = 98;
   */
  ENUM_LABEL_98 = 98,

  /**
   * @generated from enum value: ENUM_LABEL_99 = 99;
   */
  ENUM_LABEL_99 = 99,

  /**
   * @generated from enum value: ENUM_LABEL_100 = 100;
   */
  ENUM_LABEL_100 = 100,
}
// Retrieve enum metadata with: proto2.getEnumType(VeryLargeEnum)
proto2.util.setEnumType(VeryLargeEnum, "protobuf_unittest.VeryLargeEnum", [
  { no: 0, name: "ENUM_LABEL_DEFAULT" },
  { no: 1, name: "ENUM_LABEL_1" },
  { no: 2, name: "ENUM_LABEL_2" },
  { no: 3, name: "ENUM_LABEL_3" },
  { no: 4, name: "ENUM_LABEL_4" },
  { no: 5, name: "ENUM_LABEL_5" },
  { no: 6, name: "ENUM_LABEL_6" },
  { no: 7, name: "ENUM_LABEL_7" },
  { no: 8, name: "ENUM_LABEL_8" },
  { no: 9, name: "ENUM_LABEL_9" },
  { no: 10, name: "ENUM_LABEL_10" },
  { no: 11, name: "ENUM_LABEL_11" },
  { no: 12, name: "ENUM_LABEL_12" },
  { no: 13, name: "ENUM_LABEL_13" },
  { no: 14, name: "ENUM_LABEL_14" },
  { no: 15, name: "ENUM_LABEL_15" },
  { no: 16, name: "ENUM_LABEL_16" },
  { no: 17, name: "ENUM_LABEL_17" },
  { no: 18, name: "ENUM_LABEL_18" },
  { no: 19, name: "ENUM_LABEL_19" },
  { no: 20, name: "ENUM_LABEL_20" },
  { no: 21, name: "ENUM_LABEL_21" },
  { no: 22, name: "ENUM_LABEL_22" },
  { no: 23, name: "ENUM_LABEL_23" },
  { no: 24, name: "ENUM_LABEL_24" },
  { no: 25, name: "ENUM_LABEL_25" },
  { no: 26, name: "ENUM_LABEL_26" },
  { no: 27, name: "ENUM_LABEL_27" },
  { no: 28, name: "ENUM_LABEL_28" },
  { no: 29, name: "ENUM_LABEL_29" },
  { no: 30, name: "ENUM_LABEL_30" },
  { no: 31, name: "ENUM_LABEL_31" },
  { no: 32, name: "ENUM_LABEL_32" },
  { no: 33, name: "ENUM_LABEL_33" },
  { no: 34, name: "ENUM_LABEL_34" },
  { no: 35, name: "ENUM_LABEL_35" },
  { no: 36, name: "ENUM_LABEL_36" },
  { no: 37, name: "ENUM_LABEL_37" },
  { no: 38, name: "ENUM_LABEL_38" },
  { no: 39, name: "ENUM_LABEL_39" },
  { no: 40, name: "ENUM_LABEL_40" },
  { no: 41, name: "ENUM_LABEL_41" },
  { no: 42, name: "ENUM_LABEL_42" },
  { no: 43, name: "ENUM_LABEL_43" },
  { no: 44, name: "ENUM_LABEL_44" },
  { no: 45, name: "ENUM_LABEL_45" },
  { no: 46, name: "ENUM_LABEL_46" },
  { no: 47, name: "ENUM_LABEL_47" },
  { no: 48, name: "ENUM_LABEL_48" },
  { no: 49, name: "ENUM_LABEL_49" },
  { no: 50, name: "ENUM_LABEL_50" },
  { no: 51, name: "ENUM_LABEL_51" },
  { no: 52, name: "ENUM_LABEL_52" },
  { no: 53, name: "ENUM_LABEL_53" },
  { no: 54, name: "ENUM_LABEL_54" },
  { no: 55, name: "ENUM_LABEL_55" },
  { no: 56, name: "ENUM_LABEL_56" },
  { no: 57, name: "ENUM_LABEL_57" },
  { no: 58, name: "ENUM_LABEL_58" },
  { no: 59, name: "ENUM_LABEL_59" },
  { no: 60, name: "ENUM_LABEL_60" },
  { no: 61, name: "ENUM_LABEL_61" },
  { no: 62, name: "ENUM_LABEL_62" },
  { no: 63, name: "ENUM_LABEL_63" },
  { no: 64, name: "ENUM_LABEL_64" },
  { no: 65, name: "ENUM_LABEL_65" },
  { no: 66, name: "ENUM_LABEL_66" },
  { no: 67, name: "ENUM_LABEL_67" },
  { no: 68, name: "ENUM_LABEL_68" },
  { no: 69, name: "ENUM_LABEL_69" },
  { no: 70, name: "ENUM_LABEL_70" },
  { no: 71, name: "ENUM_LABEL_71" },
  { no: 72, name: "ENUM_LABEL_72" },
  { no: 73, name: "ENUM_LABEL_73" },
  { no: 74, name: "ENUM_LABEL_74" },
  { no: 75, name: "ENUM_LABEL_75" },
  { no: 76, name: "ENUM_LABEL_76" },
  { no: 77, name: "ENUM_LABEL_77" },
  { no: 78, name: "ENUM_LABEL_78" },
  { no: 79, name: "ENUM_LABEL_79" },
  { no: 80, name: "ENUM_LABEL_80" },
  { no: 81, name: "ENUM_LABEL_81" },
  { no: 82, name: "ENUM_LABEL_82" },
  { no: 83, name: "ENUM_LABEL_83" },
  { no: 84, name: "ENUM_LABEL_84" },
  { no: 85, name: "ENUM_LABEL_85" },
  { no: 86, name: "ENUM_LABEL_86" },
  { no: 87, name: "ENUM_LABEL_87" },
  { no: 88, name: "ENUM_LABEL_88" },
  { no: 89, name: "ENUM_LABEL_89" },
  { no: 90, name: "ENUM_LABEL_90" },
  { no: 91, name: "ENUM_LABEL_91" },
  { no: 92, name: "ENUM_LABEL_92" },
  { no: 93, name: "ENUM_LABEL_93" },
  { no: 94, name: "ENUM_LABEL_94" },
  { no: 95, name: "ENUM_LABEL_95" },
  { no: 96, name: "ENUM_LABEL_96" },
  { no: 97, name: "ENUM_LABEL_97" },
  { no: 98, name: "ENUM_LABEL_98" },
  { no: 99, name: "ENUM_LABEL_99" },
  { no: 100, name: "ENUM_LABEL_100" },
]);

/**
 * This proto includes every type of field in both singular and repeated
 * forms.
 *
 * @generated from message protobuf_unittest.TestAllTypes
 */
export class TestAllTypes extends Message<TestAllTypes> {
  /**
   * Singular
   *
   * @generated from field: optional int32 optional_int32 = 1;
   */
  declare optionalInt32: number;

  /**
   * @generated from field: optional int64 optional_int64 = 2;
   */
  declare optionalInt64: bigint;

  /**
   * @generated from field: optional uint32 optional_uint32 = 3;
   */
  declare optionalUint32: number;

  /**
   * @generated from field: optional uint64 optional_uint64 = 4;
   */
  declare optionalUint64: bigint;

  /**
   * @generated from field: optional sint32 optional_sint32 = 5;
   */
  declare optionalSint32: number;

  /**
   * @generated from field: optional sint64 optional_sint64 = 6;
   */
  declare optionalSint64: bigint;

  /**
   * @generated from field: optional fixed32 optional_fixed32 = 7;
   */
  declare optionalFixed32: number;

  /**
   * @generated from field: optional fixed64 optional_fixed64 = 8;
   */
  declare optionalFixed64: bigint;

  /**
   * @generated from field: optional sfixed32 optional_sfixed32 = 9;
   */
  declare optionalSfixed32: number;

  /**
   * @generated from field: optional sfixed64 optional_sfixed64 = 10;
   */
  declare optionalSfixed64: bigint;

  /**
   * @generated from field: optional float optional_float = 11;
   */
  declare optionalFloat: number;

  /**
   * @generated from field: optional double optional_double = 12;
   */
  declare optionalDouble: number;

  /**
   * @generated from field: optional bool optional_bool = 13;
   */
  declare optionalBool: boolean;

  /**
   * @generated from field: optional string optional_string = 14;
   */
  declare optionalString: string;

  /**
   * @generated from field: optional bytes optional_bytes = 15;
   */
  declare optionalBytes: Uint8Array;

  /**
   * @generated from field: optional protobuf_unittest.TestAllTypes.OptionalGroup optionalgroup = 16;
   */
  optionalgroup?: TestAllTypes_OptionalGroup;

  /**
   * @generated from field: optional protobuf_unittest.TestAllTypes.NestedMessage optional_nested_message = 18;
   */
  optionalNestedMessage?: TestAllTypes_NestedMessage;

  /**
   * @generated from field: optional protobuf_unittest.ForeignMessage optional_foreign_message = 19;
   */
  optionalForeignMessage?: ForeignMessage;

  /**
   * @generated from field: optional protobuf_unittest_import.ImportMessage optional_import_message = 20;
   */
  optionalImportMessage?: ImportMessage;

  /**
   * @generated from field: optional protobuf_unittest.TestAllTypes.NestedEnum optional_nested_enum = 21;
   */
  declare optionalNestedEnum: TestAllTypes_NestedEnum;

  /**
   * @generated from field: optional protobuf_unittest.ForeignEnum optional_foreign_enum = 22;
   */
  declare optionalForeignEnum: ForeignEnum;

  /**
   * @generated from field: optional protobuf_unittest_import.ImportEnum optional_import_enum = 23;
   */
  declare optionalImportEnum: ImportEnum;

  /**
   * @generated from field: optional string optional_string_piece = 24;
   */
  declare optionalStringPiece: string;

  /**
   * @generated from field: optional string optional_cord = 25;
   */
  declare optionalCord: string;

  /**
   * Defined in unittest_import_public.proto
   *
   * @generated from field: optional protobuf_unittest_import.PublicImportMessage optional_public_import_message = 26;
   */
  optionalPublicImportMessage?: PublicImportMessage;

  /**
   * @generated from field: optional protobuf_unittest.TestAllTypes.NestedMessage optional_lazy_message = 27;
   */
  optionalLazyMessage?: TestAllTypes_NestedMessage;

  /**
   * @generated from field: optional protobuf_unittest.TestAllTypes.NestedMessage optional_unverified_lazy_message = 28;
   */
  optionalUnverifiedLazyMessage?: TestAllTypes_NestedMessage;

  /**
   * Repeated
   *
   * @generated from field: repeated int32 repeated_int32 = 31;
   */
  repeatedInt32: number[] = [];

  /**
   * @generated from field: repeated int64 repeated_int64 = 32;
   */
  repeatedInt64: bigint[] = [];

  /**
   * @generated from field: repeated uint32 repeated_uint32 = 33;
   */
  repeatedUint32: number[] = [];

  /**
   * @generated from field: repeated uint64 repeated_uint64 = 34;
   */
  repeatedUint64: bigint[] = [];

  /**
   * @generated from field: repeated sint32 repeated_sint32 = 35;
   */
  repeatedSint32: number[] = [];

  /**
   * @generated from field: repeated sint64 repeated_sint64 = 36;
   */
  repeatedSint64: bigint[] = [];

  /**
   * @generated from field: repeated fixed32 repeated_fixed32 = 37;
   */
  repeatedFixed32: number[] = [];

  /**
   * @generated from field: repeated fixed64 repeated_fixed64 = 38;
   */
  repeatedFixed64: bigint[] = [];

  /**
   * @generated from field: repeated sfixed32 repeated_sfixed32 = 39;
   */
  repeatedSfixed32: number[] = [];

  /**
   * @generated from field: repeated sfixed64 repeated_sfixed64 = 40;
   */
  repeatedSfixed64: bigint[] = [];

  /**
   * @generated from field: repeated float repeated_float = 41;
   */
  repeatedFloat: number[] = [];

  /**
   * @generated from field: repeated double repeated_double = 42;
   */
  repeatedDouble: number[] = [];

  /**
   * @generated from field: repeated bool repeated_bool = 43;
   */
  repeatedBool: boolean[] = [];

  /**
   * @generated from field: repeated string repeated_string = 44;
   */
  repeatedString: string[] = [];

  /**
   * @generated from field: repeated bytes repeated_bytes = 45;
   */
  repeatedBytes: Uint8Array[] = [];

  /**
   * @generated from field: repeated protobuf_unittest.TestAllTypes.RepeatedGroup repeatedgroup = 46;
   */
  repeatedgroup: TestAllTypes_RepeatedGroup[] = [];

  /**
   * @generated from field: repeated protobuf_unittest.TestAllTypes.NestedMessage repeated_nested_message = 48;
   */
  repeatedNestedMessage: TestAllTypes_NestedMessage[] = [];

  /**
   * @generated from field: repeated protobuf_unittest.ForeignMessage repeated_foreign_message = 49;
   */
  repeatedForeignMessage: ForeignMessage[] = [];

  /**
   * @generated from field: repeated protobuf_unittest_import.ImportMessage repeated_import_message = 50;
   */
  repeatedImportMessage: ImportMessage[] = [];

  /**
   * @generated from field: repeated protobuf_unittest.TestAllTypes.NestedEnum repeated_nested_enum = 51;
   */
  repeatedNestedEnum: TestAllTypes_NestedEnum[] = [];

  /**
   * @generated from field: repeated protobuf_unittest.ForeignEnum repeated_foreign_enum = 52;
   */
  repeatedForeignEnum: ForeignEnum[] = [];

  /**
   * @generated from field: repeated protobuf_unittest_import.ImportEnum repeated_import_enum = 53;
   */
  repeatedImportEnum: ImportEnum[] = [];

  /**
   * @generated from field: repeated string repeated_string_piece = 54;
   */
  repeatedStringPiece: string[] = [];

  /**
   * @generated from field: repeated string repeated_cord = 55;
   */
  repeatedCord: string[] = [];

  /**
   * @generated from field: repeated protobuf_unittest.TestAllTypes.NestedMessage repeated_lazy_message = 57;
   */
  repeatedLazyMessage: TestAllTypes_NestedMessage[] = [];

  /**
   * Singular with defaults
   *
   * @generated from field: optional int32 default_int32 = 61 [default = 41];
   */
  declare defaultInt32: number;

  /**
   * @generated from field: optional int64 default_int64 = 62 [default = 42];
   */
  declare defaultInt64: bigint;

  /**
   * @generated from field: optional uint32 default_uint32 = 63 [default = 43];
   */
  declare defaultUint32: number;

  /**
   * @generated from field: optional uint64 default_uint64 = 64 [default = 44];
   */
  declare defaultUint64: bigint;

  /**
   * @generated from field: optional sint32 default_sint32 = 65 [default = -45];
   */
  declare defaultSint32: number;

  /**
   * @generated from field: optional sint64 default_sint64 = 66 [default = 46];
   */
  declare defaultSint64: bigint;

  /**
   * @generated from field: optional fixed32 default_fixed32 = 67 [default = 47];
   */
  declare defaultFixed32: number;

  /**
   * @generated from field: optional fixed64 default_fixed64 = 68 [default = 48];
   */
  declare defaultFixed64: bigint;

  /**
   * @generated from field: optional sfixed32 default_sfixed32 = 69 [default = 49];
   */
  declare defaultSfixed32: number;

  /**
   * @generated from field: optional sfixed64 default_sfixed64 = 70 [default = -50];
   */
  declare defaultSfixed64: bigint;

  /**
   * @generated from field: optional float default_float = 71 [default = 51.5];
   */
  declare defaultFloat: number;

  /**
   * @generated from field: optional double default_double = 72 [default = 52000];
   */
  declare defaultDouble: number;

  /**
   * @generated from field: optional bool default_bool = 73 [default = true];
   */
  declare defaultBool: boolean;

  /**
   * @generated from field: optional string default_string = 74 [default = "hello"];
   */
  declare defaultString: string;

  /**
   * @generated from field: optional bytes default_bytes = 75 [default = "world"];
   */
  declare defaultBytes: Uint8Array;

  /**
   * @generated from field: optional protobuf_unittest.TestAllTypes.NestedEnum default_nested_enum = 81 [default = BAR];
   */
  declare defaultNestedEnum: TestAllTypes_NestedEnum;

  /**
   * @generated from field: optional protobuf_unittest.ForeignEnum default_foreign_enum = 82 [default = FOREIGN_BAR];
   */
  declare defaultForeignEnum: ForeignEnum;

  /**
   * @generated from field: optional protobuf_unittest_import.ImportEnum default_import_enum = 83 [default = IMPORT_BAR];
   */
  declare defaultImportEnum: ImportEnum;

  /**
   * @generated from field: optional string default_string_piece = 84 [default = "abc"];
   */
  declare defaultStringPiece: string;

  /**
   * @generated from field: optional string default_cord = 85 [default = "123"];
   */
  declare defaultCord: string;

  /**
   * For oneof test
   *
   * @generated from oneof protobuf_unittest.TestAllTypes.oneof_field
   */
  oneofField: {
    /**
     * @generated from field: uint32 oneof_uint32 = 111;
     */
    value: number;
    case: "oneofUint32";
  } | {
    /**
     * @generated from field: protobuf_unittest.TestAllTypes.NestedMessage oneof_nested_message = 112;
     */
    value: TestAllTypes_NestedMessage;
    case: "oneofNestedMessage";
  } | {
    /**
     * @generated from field: string oneof_string = 113;
     */
    value: string;
    case: "oneofString";
  } | {
    /**
     * @generated from field: bytes oneof_bytes = 114;
     */
    value: Uint8Array;
    case: "oneofBytes";
  } | {
    /**
     * @generated from field: string oneof_cord = 115;
     */
    value: string;
    case: "oneofCord";
  } | {
    /**
     * @generated from field: string oneof_string_piece = 116;
     */
    value: string;
    case: "oneofStringPiece";
  } | {
    /**
     * @generated from field: protobuf_unittest.TestAllTypes.NestedMessage oneof_lazy_nested_message = 117;
     */
    value: TestAllTypes_NestedMessage;
    case: "oneofLazyNestedMessage";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<TestAllTypes>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestAllTypes";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "optional_int32", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 2, name: "optional_int64", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 3, name: "optional_uint32", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 4, name: "optional_uint64", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
    { no: 5, name: "optional_sint32", kind: "scalar", T: 17 /* ScalarType.SINT32 */, opt: true },
    { no: 6, name: "optional_sint64", kind: "scalar", T: 18 /* ScalarType.SINT64 */, opt: true },
    { no: 7, name: "optional_fixed32", kind: "scalar", T: 7 /* ScalarType.FIXED32 */, opt: true },
    { no: 8, name: "optional_fixed64", kind: "scalar", T: 6 /* ScalarType.FIXED64 */, opt: true },
    { no: 9, name: "optional_sfixed32", kind: "scalar", T: 15 /* ScalarType.SFIXED32 */, opt: true },
    { no: 10, name: "optional_sfixed64", kind: "scalar", T: 16 /* ScalarType.SFIXED64 */, opt: true },
    { no: 11, name: "optional_float", kind: "scalar", T: 2 /* ScalarType.FLOAT */, opt: true },
    { no: 12, name: "optional_double", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 13, name: "optional_bool", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 14, name: "optional_string", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 15, name: "optional_bytes", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 16, name: "optionalgroup", kind: "message", T: TestAllTypes_OptionalGroup, delimited: true, opt: true },
    { no: 18, name: "optional_nested_message", kind: "message", T: TestAllTypes_NestedMessage, opt: true },
    { no: 19, name: "optional_foreign_message", kind: "message", T: ForeignMessage, opt: true },
    { no: 20, name: "optional_import_message", kind: "message", T: ImportMessage, opt: true },
    { no: 21, name: "optional_nested_enum", kind: "enum", T: proto2.getEnumType(TestAllTypes_NestedEnum), opt: true },
    { no: 22, name: "optional_foreign_enum", kind: "enum", T: proto2.getEnumType(ForeignEnum), opt: true },
    { no: 23, name: "optional_import_enum", kind: "enum", T: proto2.getEnumType(ImportEnum), opt: true },
    { no: 24, name: "optional_string_piece", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 25, name: "optional_cord", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 26, name: "optional_public_import_message", kind: "message", T: PublicImportMessage, opt: true },
    { no: 27, name: "optional_lazy_message", kind: "message", T: TestAllTypes_NestedMessage, opt: true },
    { no: 28, name: "optional_unverified_lazy_message", kind: "message", T: TestAllTypes_NestedMessage, opt: true },
    { no: 31, name: "repeated_int32", kind: "scalar", T: 5 /* ScalarType.INT32 */, repeated: true },
    { no: 32, name: "repeated_int64", kind: "scalar", T: 3 /* ScalarType.INT64 */, repeated: true },
    { no: 33, name: "repeated_uint32", kind: "scalar", T: 13 /* ScalarType.UINT32 */, repeated: true },
    { no: 34, name: "repeated_uint64", kind: "scalar", T: 4 /* ScalarType.UINT64 */, repeated: true },
    { no: 35, name: "repeated_sint32", kind: "scalar", T: 17 /* ScalarType.SINT32 */, repeated: true },
    { no: 36, name: "repeated_sint64", kind: "scalar", T: 18 /* ScalarType.SINT64 */, repeated: true },
    { no: 37, name: "repeated_fixed32", kind: "scalar", T: 7 /* ScalarType.FIXED32 */, repeated: true },
    { no: 38, name: "repeated_fixed64", kind: "scalar", T: 6 /* ScalarType.FIXED64 */, repeated: true },
    { no: 39, name: "repeated_sfixed32", kind: "scalar", T: 15 /* ScalarType.SFIXED32 */, repeated: true },
    { no: 40, name: "repeated_sfixed64", kind: "scalar", T: 16 /* ScalarType.SFIXED64 */, repeated: true },
    { no: 41, name: "repeated_float", kind: "scalar", T: 2 /* ScalarType.FLOAT */, repeated: true },
    { no: 42, name: "repeated_double", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, repeated: true },
    { no: 43, name: "repeated_bool", kind: "scalar", T: 8 /* ScalarType.BOOL */, repeated: true },
    { no: 44, name: "repeated_string", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 45, name: "repeated_bytes", kind: "scalar", T: 12 /* ScalarType.BYTES */, repeated: true },
    { no: 46, name: "repeatedgroup", kind: "message", T: TestAllTypes_RepeatedGroup, delimited: true, repeated: true },
    { no: 48, name: "repeated_nested_message", kind: "message", T: TestAllTypes_NestedMessage, repeated: true },
    { no: 49, name: "repeated_foreign_message", kind: "message", T: ForeignMessage, repeated: true },
    { no: 50, name: "repeated_import_message", kind: "message", T: ImportMessage, repeated: true },
    { no: 51, name: "repeated_nested_enum", kind: "enum", T: proto2.getEnumType(TestAllTypes_NestedEnum), repeated: true },
    { no: 52, name: "repeated_foreign_enum", kind: "enum", T: proto2.getEnumType(ForeignEnum), repeated: true },
    { no: 53, name: "repeated_import_enum", kind: "enum", T: proto2.getEnumType(ImportEnum), repeated: true },
    { no: 54, name: "repeated_string_piece", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 55, name: "repeated_cord", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 57, name: "repeated_lazy_message", kind: "message", T: TestAllTypes_NestedMessage, repeated: true },
    { no: 61, name: "default_int32", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true, default: 41 },
    { no: 62, name: "default_int64", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true, default: protoInt64.parse("42") },
    { no: 63, name: "default_uint32", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true, default: 43 },
    { no: 64, name: "default_uint64", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true, default: protoInt64.uParse("44") },
    { no: 65, name: "default_sint32", kind: "scalar", T: 17 /* ScalarType.SINT32 */, opt: true, default: -45 },
    { no: 66, name: "default_sint64", kind: "scalar", T: 18 /* ScalarType.SINT64 */, opt: true, default: protoInt64.parse("46") },
    { no: 67, name: "default_fixed32", kind: "scalar", T: 7 /* ScalarType.FIXED32 */, opt: true, default: 47 },
    { no: 68, name: "default_fixed64", kind: "scalar", T: 6 /* ScalarType.FIXED64 */, opt: true, default: protoInt64.uParse("48") },
    { no: 69, name: "default_sfixed32", kind: "scalar", T: 15 /* ScalarType.SFIXED32 */, opt: true, default: 49 },
    { no: 70, name: "default_sfixed64", kind: "scalar", T: 16 /* ScalarType.SFIXED64 */, opt: true, default: protoInt64.parse("-50") },
    { no: 71, name: "default_float", kind: "scalar", T: 2 /* ScalarType.FLOAT */, opt: true, default: 51.5 },
    { no: 72, name: "default_double", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true, default: 52000 },
    { no: 73, name: "default_bool", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true, default: true },
    { no: 74, name: "default_string", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true, default: "hello" },
    { no: 75, name: "default_bytes", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true, default: new Uint8Array([0x77, 0x6F, 0x72, 0x6C, 0x64]) },
    { no: 81, name: "default_nested_enum", kind: "enum", T: proto2.getEnumType(TestAllTypes_NestedEnum), opt: true, default: TestAllTypes_NestedEnum.BAR },
    { no: 82, name: "default_foreign_enum", kind: "enum", T: proto2.getEnumType(ForeignEnum), opt: true, default: ForeignEnum.FOREIGN_BAR },
    { no: 83, name: "default_import_enum", kind: "enum", T: proto2.getEnumType(ImportEnum), opt: true, default: ImportEnum.IMPORT_BAR },
    { no: 84, name: "default_string_piece", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true, default: "abc" },
    { no: 85, name: "default_cord", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true, default: "123" },
    { no: 111, name: "oneof_uint32", kind: "scalar", T: 13 /* ScalarType.UINT32 */, oneof: "oneof_field" },
    { no: 112, name: "oneof_nested_message", kind: "message", T: TestAllTypes_NestedMessage, oneof: "oneof_field" },
    { no: 113, name: "oneof_string", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "oneof_field" },
    { no: 114, name: "oneof_bytes", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "oneof_field" },
    { no: 115, name: "oneof_cord", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "oneof_field" },
    { no: 116, name: "oneof_string_piece", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "oneof_field" },
    { no: 117, name: "oneof_lazy_nested_message", kind: "message", T: TestAllTypes_NestedMessage, oneof: "oneof_field" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestAllTypes {
    return new TestAllTypes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestAllTypes {
    return new TestAllTypes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestAllTypes {
    return new TestAllTypes().fromJsonString(jsonString, options);
  }

  static equals(a: TestAllTypes | PlainMessage<TestAllTypes> | undefined, b: TestAllTypes | PlainMessage<TestAllTypes> | undefined): boolean {
    return proto2.util.equals(TestAllTypes, a, b);
  }
}

TestAllTypes.prototype.optionalInt32 = 0;
TestAllTypes.prototype.optionalInt64 = protoInt64.zero;
TestAllTypes.prototype.optionalUint32 = 0;
TestAllTypes.prototype.optionalUint64 = protoInt64.zero;
TestAllTypes.prototype.optionalSint32 = 0;
TestAllTypes.prototype.optionalSint64 = protoInt64.zero;
TestAllTypes.prototype.optionalFixed32 = 0;
TestAllTypes.prototype.optionalFixed64 = protoInt64.zero;
TestAllTypes.prototype.optionalSfixed32 = 0;
TestAllTypes.prototype.optionalSfixed64 = protoInt64.zero;
TestAllTypes.prototype.optionalFloat = 0;
TestAllTypes.prototype.optionalDouble = 0;
TestAllTypes.prototype.optionalBool = false;
TestAllTypes.prototype.optionalString = "";
TestAllTypes.prototype.optionalBytes = new Uint8Array(0);
TestAllTypes.prototype.optionalNestedEnum = 1 as TestAllTypes_NestedEnum.FOO;
TestAllTypes.prototype.optionalForeignEnum = 4 as ForeignEnum.FOREIGN_FOO;
TestAllTypes.prototype.optionalImportEnum = 7 as ImportEnum.IMPORT_FOO;
TestAllTypes.prototype.optionalStringPiece = "";
TestAllTypes.prototype.optionalCord = "";
TestAllTypes.prototype.defaultInt32 = 41;
TestAllTypes.prototype.defaultInt64 = protoInt64.parse("42");
TestAllTypes.prototype.defaultUint32 = 43;
TestAllTypes.prototype.defaultUint64 = protoInt64.uParse("44");
TestAllTypes.prototype.defaultSint32 = -45;
TestAllTypes.prototype.defaultSint64 = protoInt64.parse("46");
TestAllTypes.prototype.defaultFixed32 = 47;
TestAllTypes.prototype.defaultFixed64 = protoInt64.uParse("48");
TestAllTypes.prototype.defaultSfixed32 = 49;
TestAllTypes.prototype.defaultSfixed64 = protoInt64.parse("-50");
TestAllTypes.prototype.defaultFloat = 51.5;
TestAllTypes.prototype.defaultDouble = 52000;
TestAllTypes.prototype.defaultBool = true;
TestAllTypes.prototype.defaultString = "hello";
TestAllTypes.prototype.defaultBytes = new Uint8Array([0x77, 0x6F, 0x72, 0x6C, 0x64]);
TestAllTypes.prototype.defaultNestedEnum = 2 as TestAllTypes_NestedEnum.BAR;
TestAllTypes.prototype.defaultForeignEnum = 5 as ForeignEnum.FOREIGN_BAR;
TestAllTypes.prototype.defaultImportEnum = 8 as ImportEnum.IMPORT_BAR;
TestAllTypes.prototype.defaultStringPiece = "abc";
TestAllTypes.prototype.defaultCord = "123";

/**
 * @generated from enum protobuf_unittest.TestAllTypes.NestedEnum
 */
export enum TestAllTypes_NestedEnum {
  /**
   * @generated from enum value: FOO = 1;
   */
  FOO = 1,

  /**
   * @generated from enum value: BAR = 2;
   */
  BAR = 2,

  /**
   * @generated from enum value: BAZ = 3;
   */
  BAZ = 3,

  /**
   * Intentionally negative.
   *
   * @generated from enum value: NEG = -1;
   */
  NEG = -1,
}
// Retrieve enum metadata with: proto2.getEnumType(TestAllTypes_NestedEnum)
proto2.util.setEnumType(TestAllTypes_NestedEnum, "protobuf_unittest.TestAllTypes.NestedEnum", [
  { no: 1, name: "FOO" },
  { no: 2, name: "BAR" },
  { no: 3, name: "BAZ" },
  { no: -1, name: "NEG" },
]);

/**
 * @generated from message protobuf_unittest.TestAllTypes.NestedMessage
 */
export class TestAllTypes_NestedMessage extends Message<TestAllTypes_NestedMessage> {
  /**
   * The field name "b" fails to compile in proto1 because it conflicts with
   * a local variable named "b" in one of the generated methods.  Doh.
   * This file needs to compile in proto1 to test backwards-compatibility.
   *
   * @generated from field: optional int32 bb = 1;
   */
  declare bb: number;

  constructor(data?: PartialMessage<TestAllTypes_NestedMessage>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestAllTypes.NestedMessage";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "bb", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestAllTypes_NestedMessage {
    return new TestAllTypes_NestedMessage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestAllTypes_NestedMessage {
    return new TestAllTypes_NestedMessage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestAllTypes_NestedMessage {
    return new TestAllTypes_NestedMessage().fromJsonString(jsonString, options);
  }

  static equals(a: TestAllTypes_NestedMessage | PlainMessage<TestAllTypes_NestedMessage> | undefined, b: TestAllTypes_NestedMessage | PlainMessage<TestAllTypes_NestedMessage> | undefined): boolean {
    return proto2.util.equals(TestAllTypes_NestedMessage, a, b);
  }
}

TestAllTypes_NestedMessage.prototype.bb = 0;

/**
 * @generated from message protobuf_unittest.TestAllTypes.OptionalGroup
 */
export class TestAllTypes_OptionalGroup extends Message<TestAllTypes_OptionalGroup> {
  /**
   * @generated from field: optional int32 a = 17;
   */
  declare a: number;

  constructor(data?: PartialMessage<TestAllTypes_OptionalGroup>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestAllTypes.OptionalGroup";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 17, name: "a", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestAllTypes_OptionalGroup {
    return new TestAllTypes_OptionalGroup().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestAllTypes_OptionalGroup {
    return new TestAllTypes_OptionalGroup().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestAllTypes_OptionalGroup {
    return new TestAllTypes_OptionalGroup().fromJsonString(jsonString, options);
  }

  static equals(a: TestAllTypes_OptionalGroup | PlainMessage<TestAllTypes_OptionalGroup> | undefined, b: TestAllTypes_OptionalGroup | PlainMessage<TestAllTypes_OptionalGroup> | undefined): boolean {
    return proto2.util.equals(TestAllTypes_OptionalGroup, a, b);
  }
}

TestAllTypes_OptionalGroup.prototype.a = 0;

/**
 * @generated from message protobuf_unittest.TestAllTypes.RepeatedGroup
 */
export class TestAllTypes_RepeatedGroup extends Message<TestAllTypes_RepeatedGroup> {
  /**
   * @generated from field: optional int32 a = 47;
   */
  declare a: number;

  constructor(data?: PartialMessage<TestAllTypes_RepeatedGroup>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestAllTypes.RepeatedGroup";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 47, name: "a", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestAllTypes_RepeatedGroup {
    return new TestAllTypes_RepeatedGroup().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestAllTypes_RepeatedGroup {
    return new TestAllTypes_RepeatedGroup().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestAllTypes_RepeatedGroup {
    return new TestAllTypes_RepeatedGroup().fromJsonString(jsonString, options);
  }

  static equals(a: TestAllTypes_RepeatedGroup | PlainMessage<TestAllTypes_RepeatedGroup> | undefined, b: TestAllTypes_RepeatedGroup | PlainMessage<TestAllTypes_RepeatedGroup> | undefined): boolean {
    return proto2.util.equals(TestAllTypes_RepeatedGroup, a, b);
  }
}

TestAllTypes_RepeatedGroup.prototype.a = 0;

/**
 * This proto includes a recursively nested message.
 *
 * @generated from message protobuf_unittest.NestedTestAllTypes
 */
export class NestedTestAllTypes extends Message<NestedTestAllTypes> {
  /**
   * @generated from field: optional protobuf_unittest.NestedTestAllTypes child = 1;
   */
  child?: NestedTestAllTypes;

  /**
   * @generated from field: optional protobuf_unittest.TestAllTypes payload = 2;
   */
  payload?: TestAllTypes;

  /**
   * @generated from field: repeated protobuf_unittest.NestedTestAllTypes repeated_child = 3;
   */
  repeatedChild: NestedTestAllTypes[] = [];

  /**
   * @generated from field: optional protobuf_unittest.NestedTestAllTypes lazy_child = 4;
   */
  lazyChild?: NestedTestAllTypes;

  /**
   * @generated from field: optional protobuf_unittest.TestAllTypes eager_child = 5;
   */
  eagerChild?: TestAllTypes;

  constructor(data?: PartialMessage<NestedTestAllTypes>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.NestedTestAllTypes";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "child", kind: "message", T: NestedTestAllTypes, opt: true },
    { no: 2, name: "payload", kind: "message", T: TestAllTypes, opt: true },
    { no: 3, name: "repeated_child", kind: "message", T: NestedTestAllTypes, repeated: true },
    { no: 4, name: "lazy_child", kind: "message", T: NestedTestAllTypes, opt: true },
    { no: 5, name: "eager_child", kind: "message", T: TestAllTypes, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NestedTestAllTypes {
    return new NestedTestAllTypes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NestedTestAllTypes {
    return new NestedTestAllTypes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NestedTestAllTypes {
    return new NestedTestAllTypes().fromJsonString(jsonString, options);
  }

  static equals(a: NestedTestAllTypes | PlainMessage<NestedTestAllTypes> | undefined, b: NestedTestAllTypes | PlainMessage<NestedTestAllTypes> | undefined): boolean {
    return proto2.util.equals(NestedTestAllTypes, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.TestDeprecatedFields
 */
export class TestDeprecatedFields extends Message<TestDeprecatedFields> {
  /**
   * @generated from field: optional int32 deprecated_int32 = 1 [deprecated = true];
   * @deprecated
   */
  declare deprecatedInt32: number;

  /**
   * @generated from field: repeated string deprecated_repeated_string = 4 [deprecated = true];
   * @deprecated
   */
  deprecatedRepeatedString: string[] = [];

  /**
   * @generated from field: optional protobuf_unittest.TestAllTypes.NestedMessage deprecated_message = 3 [deprecated = true];
   * @deprecated
   */
  deprecatedMessage?: TestAllTypes_NestedMessage;

  /**
   * @generated from oneof protobuf_unittest.TestDeprecatedFields.oneof_fields
   */
  oneofFields: {
    /**
     * @generated from field: int32 deprecated_int32_in_oneof = 2 [deprecated = true];
     * @deprecated
     */
    value: number;
    case: "deprecatedInt32InOneof";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * @generated from field: optional protobuf_unittest.TestDeprecatedFields nested = 5;
   */
  nested?: TestDeprecatedFields;

  constructor(data?: PartialMessage<TestDeprecatedFields>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestDeprecatedFields";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "deprecated_int32", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 4, name: "deprecated_repeated_string", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "deprecated_message", kind: "message", T: TestAllTypes_NestedMessage, opt: true },
    { no: 2, name: "deprecated_int32_in_oneof", kind: "scalar", T: 5 /* ScalarType.INT32 */, oneof: "oneof_fields" },
    { no: 5, name: "nested", kind: "message", T: TestDeprecatedFields, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestDeprecatedFields {
    return new TestDeprecatedFields().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestDeprecatedFields {
    return new TestDeprecatedFields().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestDeprecatedFields {
    return new TestDeprecatedFields().fromJsonString(jsonString, options);
  }

  static equals(a: TestDeprecatedFields | PlainMessage<TestDeprecatedFields> | undefined, b: TestDeprecatedFields | PlainMessage<TestDeprecatedFields> | undefined): boolean {
    return proto2.util.equals(TestDeprecatedFields, a, b);
  }
}

TestDeprecatedFields.prototype.deprecatedInt32 = 0;

/**
 * @generated from message protobuf_unittest.TestDeprecatedMessage
 * @deprecated
 */
export class TestDeprecatedMessage extends Message<TestDeprecatedMessage> {
  constructor(data?: PartialMessage<TestDeprecatedMessage>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestDeprecatedMessage";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestDeprecatedMessage {
    return new TestDeprecatedMessage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestDeprecatedMessage {
    return new TestDeprecatedMessage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestDeprecatedMessage {
    return new TestDeprecatedMessage().fromJsonString(jsonString, options);
  }

  static equals(a: TestDeprecatedMessage | PlainMessage<TestDeprecatedMessage> | undefined, b: TestDeprecatedMessage | PlainMessage<TestDeprecatedMessage> | undefined): boolean {
    return proto2.util.equals(TestDeprecatedMessage, a, b);
  }
}

/**
 * Define these after TestAllTypes to make sure the compiler can handle
 * that.
 *
 * @generated from message protobuf_unittest.ForeignMessage
 */
export class ForeignMessage extends Message<ForeignMessage> {
  /**
   * @generated from field: optional int32 c = 1;
   */
  declare c: number;

  /**
   * @generated from field: optional int32 d = 2;
   */
  declare d: number;

  constructor(data?: PartialMessage<ForeignMessage>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.ForeignMessage";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "c", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 2, name: "d", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ForeignMessage {
    return new ForeignMessage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ForeignMessage {
    return new ForeignMessage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ForeignMessage {
    return new ForeignMessage().fromJsonString(jsonString, options);
  }

  static equals(a: ForeignMessage | PlainMessage<ForeignMessage> | undefined, b: ForeignMessage | PlainMessage<ForeignMessage> | undefined): boolean {
    return proto2.util.equals(ForeignMessage, a, b);
  }
}

ForeignMessage.prototype.c = 0;
ForeignMessage.prototype.d = 0;

/**
 * @generated from message protobuf_unittest.TestReservedFields
 */
export class TestReservedFields extends Message<TestReservedFields> {
  constructor(data?: PartialMessage<TestReservedFields>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestReservedFields";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestReservedFields {
    return new TestReservedFields().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestReservedFields {
    return new TestReservedFields().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestReservedFields {
    return new TestReservedFields().fromJsonString(jsonString, options);
  }

  static equals(a: TestReservedFields | PlainMessage<TestReservedFields> | undefined, b: TestReservedFields | PlainMessage<TestReservedFields> | undefined): boolean {
    return proto2.util.equals(TestReservedFields, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.TestAllExtensions
 */
export class TestAllExtensions extends Message<TestAllExtensions> {
  constructor(data?: PartialMessage<TestAllExtensions>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestAllExtensions";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestAllExtensions {
    return new TestAllExtensions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestAllExtensions {
    return new TestAllExtensions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestAllExtensions {
    return new TestAllExtensions().fromJsonString(jsonString, options);
  }

  static equals(a: TestAllExtensions | PlainMessage<TestAllExtensions> | undefined, b: TestAllExtensions | PlainMessage<TestAllExtensions> | undefined): boolean {
    return proto2.util.equals(TestAllExtensions, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.OptionalGroup_extension
 */
export class OptionalGroup_extension extends Message<OptionalGroup_extension> {
  /**
   * @generated from field: optional int32 a = 17;
   */
  declare a: number;

  constructor(data?: PartialMessage<OptionalGroup_extension>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.OptionalGroup_extension";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 17, name: "a", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OptionalGroup_extension {
    return new OptionalGroup_extension().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OptionalGroup_extension {
    return new OptionalGroup_extension().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OptionalGroup_extension {
    return new OptionalGroup_extension().fromJsonString(jsonString, options);
  }

  static equals(a: OptionalGroup_extension | PlainMessage<OptionalGroup_extension> | undefined, b: OptionalGroup_extension | PlainMessage<OptionalGroup_extension> | undefined): boolean {
    return proto2.util.equals(OptionalGroup_extension, a, b);
  }
}

OptionalGroup_extension.prototype.a = 0;

/**
 * @generated from message protobuf_unittest.RepeatedGroup_extension
 */
export class RepeatedGroup_extension extends Message<RepeatedGroup_extension> {
  /**
   * @generated from field: optional int32 a = 47;
   */
  declare a: number;

  constructor(data?: PartialMessage<RepeatedGroup_extension>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.RepeatedGroup_extension";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 47, name: "a", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepeatedGroup_extension {
    return new RepeatedGroup_extension().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepeatedGroup_extension {
    return new RepeatedGroup_extension().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepeatedGroup_extension {
    return new RepeatedGroup_extension().fromJsonString(jsonString, options);
  }

  static equals(a: RepeatedGroup_extension | PlainMessage<RepeatedGroup_extension> | undefined, b: RepeatedGroup_extension | PlainMessage<RepeatedGroup_extension> | undefined): boolean {
    return proto2.util.equals(RepeatedGroup_extension, a, b);
  }
}

RepeatedGroup_extension.prototype.a = 0;

/**
 * @generated from message protobuf_unittest.TestMixedFieldsAndExtensions
 */
export class TestMixedFieldsAndExtensions extends Message<TestMixedFieldsAndExtensions> {
  /**
   * @generated from field: optional int32 a = 1;
   */
  declare a: number;

  /**
   * @generated from field: repeated fixed32 b = 3;
   */
  b: number[] = [];

  constructor(data?: PartialMessage<TestMixedFieldsAndExtensions>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestMixedFieldsAndExtensions";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "a", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 3, name: "b", kind: "scalar", T: 7 /* ScalarType.FIXED32 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestMixedFieldsAndExtensions {
    return new TestMixedFieldsAndExtensions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestMixedFieldsAndExtensions {
    return new TestMixedFieldsAndExtensions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestMixedFieldsAndExtensions {
    return new TestMixedFieldsAndExtensions().fromJsonString(jsonString, options);
  }

  static equals(a: TestMixedFieldsAndExtensions | PlainMessage<TestMixedFieldsAndExtensions> | undefined, b: TestMixedFieldsAndExtensions | PlainMessage<TestMixedFieldsAndExtensions> | undefined): boolean {
    return proto2.util.equals(TestMixedFieldsAndExtensions, a, b);
  }
}

TestMixedFieldsAndExtensions.prototype.a = 0;

/**
 * @generated from extension: optional int32 c = 2;
 */
export const TestMixedFieldsAndExtensions_c = proto2.makeExtension<TestMixedFieldsAndExtensions, number>(
  "protobuf_unittest.TestMixedFieldsAndExtensions.c", 
  TestMixedFieldsAndExtensions, 
  { no: 2, kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
);

/**
 * @generated from extension: repeated fixed32 d = 4;
 */
export const TestMixedFieldsAndExtensions_d = proto2.makeExtension<TestMixedFieldsAndExtensions, number[]>(
  "protobuf_unittest.TestMixedFieldsAndExtensions.d", 
  TestMixedFieldsAndExtensions, 
  { no: 4, kind: "scalar", T: 7 /* ScalarType.FIXED32 */, repeated: true },
);

/**
 * @generated from message protobuf_unittest.TestGroup
 */
export class TestGroup extends Message<TestGroup> {
  /**
   * @generated from field: optional protobuf_unittest.TestGroup.OptionalGroup optionalgroup = 16;
   */
  optionalgroup?: TestGroup_OptionalGroup;

  /**
   * @generated from field: optional protobuf_unittest.ForeignEnum optional_foreign_enum = 22;
   */
  declare optionalForeignEnum: ForeignEnum;

  constructor(data?: PartialMessage<TestGroup>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestGroup";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 16, name: "optionalgroup", kind: "message", T: TestGroup_OptionalGroup, delimited: true, opt: true },
    { no: 22, name: "optional_foreign_enum", kind: "enum", T: proto2.getEnumType(ForeignEnum), opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestGroup {
    return new TestGroup().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestGroup {
    return new TestGroup().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestGroup {
    return new TestGroup().fromJsonString(jsonString, options);
  }

  static equals(a: TestGroup | PlainMessage<TestGroup> | undefined, b: TestGroup | PlainMessage<TestGroup> | undefined): boolean {
    return proto2.util.equals(TestGroup, a, b);
  }
}

TestGroup.prototype.optionalForeignEnum = 4 as ForeignEnum.FOREIGN_FOO;

/**
 * @generated from message protobuf_unittest.TestGroup.OptionalGroup
 */
export class TestGroup_OptionalGroup extends Message<TestGroup_OptionalGroup> {
  /**
   * @generated from field: optional int32 a = 17;
   */
  declare a: number;

  /**
   * fast table size must be at least 16, for this
   *
   * @generated from field: optional int32 zz = 89;
   */
  declare zz: number;

  constructor(data?: PartialMessage<TestGroup_OptionalGroup>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestGroup.OptionalGroup";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 17, name: "a", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 89, name: "zz", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestGroup_OptionalGroup {
    return new TestGroup_OptionalGroup().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestGroup_OptionalGroup {
    return new TestGroup_OptionalGroup().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestGroup_OptionalGroup {
    return new TestGroup_OptionalGroup().fromJsonString(jsonString, options);
  }

  static equals(a: TestGroup_OptionalGroup | PlainMessage<TestGroup_OptionalGroup> | undefined, b: TestGroup_OptionalGroup | PlainMessage<TestGroup_OptionalGroup> | undefined): boolean {
    return proto2.util.equals(TestGroup_OptionalGroup, a, b);
  }
}

TestGroup_OptionalGroup.prototype.a = 0;
TestGroup_OptionalGroup.prototype.zz = 0;

/**
 * @generated from message protobuf_unittest.TestGroupExtension
 */
export class TestGroupExtension extends Message<TestGroupExtension> {
  constructor(data?: PartialMessage<TestGroupExtension>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestGroupExtension";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestGroupExtension {
    return new TestGroupExtension().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestGroupExtension {
    return new TestGroupExtension().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestGroupExtension {
    return new TestGroupExtension().fromJsonString(jsonString, options);
  }

  static equals(a: TestGroupExtension | PlainMessage<TestGroupExtension> | undefined, b: TestGroupExtension | PlainMessage<TestGroupExtension> | undefined): boolean {
    return proto2.util.equals(TestGroupExtension, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.TestNestedExtension
 */
export class TestNestedExtension extends Message<TestNestedExtension> {
  constructor(data?: PartialMessage<TestNestedExtension>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestNestedExtension";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestNestedExtension {
    return new TestNestedExtension().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestNestedExtension {
    return new TestNestedExtension().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestNestedExtension {
    return new TestNestedExtension().fromJsonString(jsonString, options);
  }

  static equals(a: TestNestedExtension | PlainMessage<TestNestedExtension> | undefined, b: TestNestedExtension | PlainMessage<TestNestedExtension> | undefined): boolean {
    return proto2.util.equals(TestNestedExtension, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.TestNestedExtension.OptionalGroup_extension
 */
export class TestNestedExtension_OptionalGroup_extension extends Message<TestNestedExtension_OptionalGroup_extension> {
  /**
   * @generated from field: optional int32 a = 17;
   */
  declare a: number;

  constructor(data?: PartialMessage<TestNestedExtension_OptionalGroup_extension>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestNestedExtension.OptionalGroup_extension";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 17, name: "a", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestNestedExtension_OptionalGroup_extension {
    return new TestNestedExtension_OptionalGroup_extension().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestNestedExtension_OptionalGroup_extension {
    return new TestNestedExtension_OptionalGroup_extension().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestNestedExtension_OptionalGroup_extension {
    return new TestNestedExtension_OptionalGroup_extension().fromJsonString(jsonString, options);
  }

  static equals(a: TestNestedExtension_OptionalGroup_extension | PlainMessage<TestNestedExtension_OptionalGroup_extension> | undefined, b: TestNestedExtension_OptionalGroup_extension | PlainMessage<TestNestedExtension_OptionalGroup_extension> | undefined): boolean {
    return proto2.util.equals(TestNestedExtension_OptionalGroup_extension, a, b);
  }
}

TestNestedExtension_OptionalGroup_extension.prototype.a = 0;

/**
 * Check for bug where string extensions declared in tested scope did not
 * compile.
 *
 * @generated from extension: optional string test = 1002 [default = "test"];
 */
export const TestNestedExtension_test = proto2.makeExtension<TestAllExtensions, string>(
  "protobuf_unittest.TestNestedExtension.test", 
  TestAllExtensions, 
  { no: 1002, kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true, default: "test" },
);

/**
 * Used to test if generated extension name is correct when there are
 * underscores.
 *
 * @generated from extension: optional string nested_string_extension = 1003;
 */
export const TestNestedExtension_nested_string_extension = proto2.makeExtension<TestAllExtensions, string>(
  "protobuf_unittest.TestNestedExtension.nested_string_extension", 
  TestAllExtensions, 
  { no: 1003, kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
);

/**
 * @generated from extension: optional protobuf_unittest.TestNestedExtension.OptionalGroup_extension optionalgroup_extension = 16;
 */
export const TestNestedExtension_optionalgroup_extension = proto2.makeExtension<TestGroupExtension, TestNestedExtension_OptionalGroup_extension>(
  "protobuf_unittest.TestNestedExtension.optionalgroup_extension", 
  TestGroupExtension, 
  () => ({ no: 16, kind: "message", T: TestNestedExtension_OptionalGroup_extension, delimited: true, opt: true }),
);

/**
 * @generated from extension: optional protobuf_unittest.ForeignEnum optional_foreign_enum_extension = 22;
 */
export const TestNestedExtension_optional_foreign_enum_extension = proto2.makeExtension<TestGroupExtension, ForeignEnum>(
  "protobuf_unittest.TestNestedExtension.optional_foreign_enum_extension", 
  TestGroupExtension, 
  () => ({ no: 22, kind: "enum", T: proto2.getEnumType(ForeignEnum), opt: true }),
);

/**
 * @generated from message protobuf_unittest.TestChildExtension
 */
export class TestChildExtension extends Message<TestChildExtension> {
  /**
   * @generated from field: optional string a = 1;
   */
  declare a: string;

  /**
   * @generated from field: optional string b = 2;
   */
  declare b: string;

  /**
   * @generated from field: optional protobuf_unittest.TestAllExtensions optional_extension = 3;
   */
  optionalExtension?: TestAllExtensions;

  constructor(data?: PartialMessage<TestChildExtension>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestChildExtension";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "a", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "b", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "optional_extension", kind: "message", T: TestAllExtensions, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestChildExtension {
    return new TestChildExtension().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestChildExtension {
    return new TestChildExtension().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestChildExtension {
    return new TestChildExtension().fromJsonString(jsonString, options);
  }

  static equals(a: TestChildExtension | PlainMessage<TestChildExtension> | undefined, b: TestChildExtension | PlainMessage<TestChildExtension> | undefined): boolean {
    return proto2.util.equals(TestChildExtension, a, b);
  }
}

TestChildExtension.prototype.a = "";
TestChildExtension.prototype.b = "";

/**
 * Emulates wireformat data of TestChildExtension with dynamic extension
 * (DynamicExtension).
 *
 * @generated from message protobuf_unittest.TestChildExtensionData
 */
export class TestChildExtensionData extends Message<TestChildExtensionData> {
  /**
   * @generated from field: optional string a = 1;
   */
  declare a: string;

  /**
   * @generated from field: optional string b = 2;
   */
  declare b: string;

  /**
   * @generated from field: optional protobuf_unittest.TestChildExtensionData.NestedTestAllExtensionsData optional_extension = 3;
   */
  optionalExtension?: TestChildExtensionData_NestedTestAllExtensionsData;

  constructor(data?: PartialMessage<TestChildExtensionData>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestChildExtensionData";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "a", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "b", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "optional_extension", kind: "message", T: TestChildExtensionData_NestedTestAllExtensionsData, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestChildExtensionData {
    return new TestChildExtensionData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestChildExtensionData {
    return new TestChildExtensionData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestChildExtensionData {
    return new TestChildExtensionData().fromJsonString(jsonString, options);
  }

  static equals(a: TestChildExtensionData | PlainMessage<TestChildExtensionData> | undefined, b: TestChildExtensionData | PlainMessage<TestChildExtensionData> | undefined): boolean {
    return proto2.util.equals(TestChildExtensionData, a, b);
  }
}

TestChildExtensionData.prototype.a = "";
TestChildExtensionData.prototype.b = "";

/**
 * @generated from message protobuf_unittest.TestChildExtensionData.NestedTestAllExtensionsData
 */
export class TestChildExtensionData_NestedTestAllExtensionsData extends Message<TestChildExtensionData_NestedTestAllExtensionsData> {
  /**
   * @generated from field: optional protobuf_unittest.TestChildExtensionData.NestedTestAllExtensionsData.NestedDynamicExtensions dynamic = 409707008;
   */
  dynamic?: TestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensions;

  constructor(data?: PartialMessage<TestChildExtensionData_NestedTestAllExtensionsData>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestChildExtensionData.NestedTestAllExtensionsData";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 409707008, name: "dynamic", kind: "message", T: TestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensions, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestChildExtensionData_NestedTestAllExtensionsData {
    return new TestChildExtensionData_NestedTestAllExtensionsData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestChildExtensionData_NestedTestAllExtensionsData {
    return new TestChildExtensionData_NestedTestAllExtensionsData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestChildExtensionData_NestedTestAllExtensionsData {
    return new TestChildExtensionData_NestedTestAllExtensionsData().fromJsonString(jsonString, options);
  }

  static equals(a: TestChildExtensionData_NestedTestAllExtensionsData | PlainMessage<TestChildExtensionData_NestedTestAllExtensionsData> | undefined, b: TestChildExtensionData_NestedTestAllExtensionsData | PlainMessage<TestChildExtensionData_NestedTestAllExtensionsData> | undefined): boolean {
    return proto2.util.equals(TestChildExtensionData_NestedTestAllExtensionsData, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.TestChildExtensionData.NestedTestAllExtensionsData.NestedDynamicExtensions
 */
export class TestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensions extends Message<TestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensions> {
  /**
   * @generated from field: optional int32 a = 1;
   */
  declare a: number;

  /**
   * @generated from field: optional int32 b = 2;
   */
  declare b: number;

  constructor(data?: PartialMessage<TestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensions>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestChildExtensionData.NestedTestAllExtensionsData.NestedDynamicExtensions";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "a", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 2, name: "b", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensions {
    return new TestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensions {
    return new TestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensions {
    return new TestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensions().fromJsonString(jsonString, options);
  }

  static equals(a: TestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensions | PlainMessage<TestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensions> | undefined, b: TestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensions | PlainMessage<TestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensions> | undefined): boolean {
    return proto2.util.equals(TestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensions, a, b);
  }
}

TestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensions.prototype.a = 0;
TestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensions.prototype.b = 0;

/**
 * @generated from message protobuf_unittest.TestNestedChildExtension
 */
export class TestNestedChildExtension extends Message<TestNestedChildExtension> {
  /**
   * @generated from field: optional int32 a = 1;
   */
  declare a: number;

  /**
   * @generated from field: optional protobuf_unittest.TestChildExtension child = 2;
   */
  child?: TestChildExtension;

  constructor(data?: PartialMessage<TestNestedChildExtension>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestNestedChildExtension";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "a", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 2, name: "child", kind: "message", T: TestChildExtension, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestNestedChildExtension {
    return new TestNestedChildExtension().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestNestedChildExtension {
    return new TestNestedChildExtension().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestNestedChildExtension {
    return new TestNestedChildExtension().fromJsonString(jsonString, options);
  }

  static equals(a: TestNestedChildExtension | PlainMessage<TestNestedChildExtension> | undefined, b: TestNestedChildExtension | PlainMessage<TestNestedChildExtension> | undefined): boolean {
    return proto2.util.equals(TestNestedChildExtension, a, b);
  }
}

TestNestedChildExtension.prototype.a = 0;

/**
 * Emulates wireformat data of TestNestedChildExtension with dynamic extension
 * (DynamicExtension).
 *
 * @generated from message protobuf_unittest.TestNestedChildExtensionData
 */
export class TestNestedChildExtensionData extends Message<TestNestedChildExtensionData> {
  /**
   * @generated from field: optional int32 a = 1;
   */
  declare a: number;

  /**
   * @generated from field: optional protobuf_unittest.TestChildExtensionData child = 2;
   */
  child?: TestChildExtensionData;

  constructor(data?: PartialMessage<TestNestedChildExtensionData>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestNestedChildExtensionData";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "a", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 2, name: "child", kind: "message", T: TestChildExtensionData, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestNestedChildExtensionData {
    return new TestNestedChildExtensionData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestNestedChildExtensionData {
    return new TestNestedChildExtensionData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestNestedChildExtensionData {
    return new TestNestedChildExtensionData().fromJsonString(jsonString, options);
  }

  static equals(a: TestNestedChildExtensionData | PlainMessage<TestNestedChildExtensionData> | undefined, b: TestNestedChildExtensionData | PlainMessage<TestNestedChildExtensionData> | undefined): boolean {
    return proto2.util.equals(TestNestedChildExtensionData, a, b);
  }
}

TestNestedChildExtensionData.prototype.a = 0;

/**
 * Required and closed enum fields are considered unknown fields if the value is
 * not valid. We need to make sure it functions as expected.
 *
 * @generated from message protobuf_unittest.TestRequiredEnum
 */
export class TestRequiredEnum extends Message<TestRequiredEnum> {
  /**
   * @generated from field: required protobuf_unittest.ForeignEnum required_enum = 1;
   */
  declare requiredEnum: ForeignEnum;

  /**
   * A dummy optional field.
   *
   * @generated from field: optional int32 a = 2;
   */
  declare a: number;

  constructor(data?: PartialMessage<TestRequiredEnum>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestRequiredEnum";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "required_enum", kind: "enum", T: proto2.getEnumType(ForeignEnum), req: true },
    { no: 2, name: "a", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestRequiredEnum {
    return new TestRequiredEnum().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestRequiredEnum {
    return new TestRequiredEnum().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestRequiredEnum {
    return new TestRequiredEnum().fromJsonString(jsonString, options);
  }

  static equals(a: TestRequiredEnum | PlainMessage<TestRequiredEnum> | undefined, b: TestRequiredEnum | PlainMessage<TestRequiredEnum> | undefined): boolean {
    return proto2.util.equals(TestRequiredEnum, a, b);
  }
}

TestRequiredEnum.prototype.requiredEnum = 4 as ForeignEnum.FOREIGN_FOO;
TestRequiredEnum.prototype.a = 0;

/**
 * TestRequiredEnum + using enum values that won't fit to 64 bitmask.
 *
 * @generated from message protobuf_unittest.TestRequiredEnumNoMask
 */
export class TestRequiredEnumNoMask extends Message<TestRequiredEnumNoMask> {
  /**
   * @generated from field: required protobuf_unittest.TestRequiredEnumNoMask.NestedEnum required_enum = 1;
   */
  declare requiredEnum: TestRequiredEnumNoMask_NestedEnum;

  /**
   * A dummy optional field.
   *
   * @generated from field: optional int32 a = 2;
   */
  declare a: number;

  constructor(data?: PartialMessage<TestRequiredEnumNoMask>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestRequiredEnumNoMask";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "required_enum", kind: "enum", T: proto2.getEnumType(TestRequiredEnumNoMask_NestedEnum), req: true },
    { no: 2, name: "a", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestRequiredEnumNoMask {
    return new TestRequiredEnumNoMask().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestRequiredEnumNoMask {
    return new TestRequiredEnumNoMask().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestRequiredEnumNoMask {
    return new TestRequiredEnumNoMask().fromJsonString(jsonString, options);
  }

  static equals(a: TestRequiredEnumNoMask | PlainMessage<TestRequiredEnumNoMask> | undefined, b: TestRequiredEnumNoMask | PlainMessage<TestRequiredEnumNoMask> | undefined): boolean {
    return proto2.util.equals(TestRequiredEnumNoMask, a, b);
  }
}

TestRequiredEnumNoMask.prototype.requiredEnum = 0 as TestRequiredEnumNoMask_NestedEnum.UNSPECIFIED;
TestRequiredEnumNoMask.prototype.a = 0;

/**
 * @generated from enum protobuf_unittest.TestRequiredEnumNoMask.NestedEnum
 */
export enum TestRequiredEnumNoMask_NestedEnum {
  /**
   * @generated from enum value: UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: FOO = 2;
   */
  FOO = 2,

  /**
   * @generated from enum value: BAR = 100;
   */
  BAR = 100,

  /**
   * Intentionally negative.
   *
   * @generated from enum value: BAZ = -1;
   */
  BAZ = -1,
}
// Retrieve enum metadata with: proto2.getEnumType(TestRequiredEnumNoMask_NestedEnum)
proto2.util.setEnumType(TestRequiredEnumNoMask_NestedEnum, "protobuf_unittest.TestRequiredEnumNoMask.NestedEnum", [
  { no: 0, name: "UNSPECIFIED" },
  { no: 2, name: "FOO" },
  { no: 100, name: "BAR" },
  { no: -1, name: "BAZ" },
]);

/**
 * @generated from message protobuf_unittest.TestRequiredEnumMulti
 */
export class TestRequiredEnumMulti extends Message<TestRequiredEnumMulti> {
  /**
   * Intentionally placed in descending field number to force sorting in closed
   * enum verification.
   *
   * @generated from field: required protobuf_unittest.TestRequiredEnumMulti.NestedEnum required_enum_4 = 4;
   */
  declare requiredEnum4: TestRequiredEnumMulti_NestedEnum;

  /**
   * @generated from field: optional int32 a_3 = 3;
   */
  declare a3: number;

  /**
   * @generated from field: required protobuf_unittest.TestRequiredEnumMulti.NestedEnum required_enum_2 = 2;
   */
  declare requiredEnum2: TestRequiredEnumMulti_NestedEnum;

  /**
   * @generated from field: required protobuf_unittest.ForeignEnum required_enum_1 = 1;
   */
  declare requiredEnum1: ForeignEnum;

  constructor(data?: PartialMessage<TestRequiredEnumMulti>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestRequiredEnumMulti";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 4, name: "required_enum_4", kind: "enum", T: proto2.getEnumType(TestRequiredEnumMulti_NestedEnum), req: true },
    { no: 3, name: "a_3", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 2, name: "required_enum_2", kind: "enum", T: proto2.getEnumType(TestRequiredEnumMulti_NestedEnum), req: true },
    { no: 1, name: "required_enum_1", kind: "enum", T: proto2.getEnumType(ForeignEnum), req: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestRequiredEnumMulti {
    return new TestRequiredEnumMulti().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestRequiredEnumMulti {
    return new TestRequiredEnumMulti().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestRequiredEnumMulti {
    return new TestRequiredEnumMulti().fromJsonString(jsonString, options);
  }

  static equals(a: TestRequiredEnumMulti | PlainMessage<TestRequiredEnumMulti> | undefined, b: TestRequiredEnumMulti | PlainMessage<TestRequiredEnumMulti> | undefined): boolean {
    return proto2.util.equals(TestRequiredEnumMulti, a, b);
  }
}

TestRequiredEnumMulti.prototype.requiredEnum4 = 0 as TestRequiredEnumMulti_NestedEnum.UNSPECIFIED;
TestRequiredEnumMulti.prototype.a3 = 0;
TestRequiredEnumMulti.prototype.requiredEnum2 = 0 as TestRequiredEnumMulti_NestedEnum.UNSPECIFIED;
TestRequiredEnumMulti.prototype.requiredEnum1 = 4 as ForeignEnum.FOREIGN_FOO;

/**
 * @generated from enum protobuf_unittest.TestRequiredEnumMulti.NestedEnum
 */
export enum TestRequiredEnumMulti_NestedEnum {
  /**
   * @generated from enum value: UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: FOO = 1;
   */
  FOO = 1,

  /**
   * @generated from enum value: BAR = 2;
   */
  BAR = 2,

  /**
   * @generated from enum value: BAZ = 100;
   */
  BAZ = 100,
}
// Retrieve enum metadata with: proto2.getEnumType(TestRequiredEnumMulti_NestedEnum)
proto2.util.setEnumType(TestRequiredEnumMulti_NestedEnum, "protobuf_unittest.TestRequiredEnumMulti.NestedEnum", [
  { no: 0, name: "UNSPECIFIED" },
  { no: 1, name: "FOO" },
  { no: 2, name: "BAR" },
  { no: 100, name: "BAZ" },
]);

/**
 * @generated from message protobuf_unittest.TestRequiredNoMaskMulti
 */
export class TestRequiredNoMaskMulti extends Message<TestRequiredNoMaskMulti> {
  /**
   * Intentionally placed in descending field number to force sorting in closed
   * enum verification. Also, using large field numbers to use tag only
   * matching for required fields.
   *
   * @generated from field: required fixed32 required_fixed32_80 = 80;
   */
  declare requiredFixed3280: number;

  /**
   * @generated from field: required fixed32 required_fixed32_70 = 70;
   */
  declare requiredFixed3270: number;

  /**
   * @generated from field: required protobuf_unittest.TestRequiredNoMaskMulti.NestedEnum required_enum_64 = 64;
   */
  declare requiredEnum64: TestRequiredNoMaskMulti_NestedEnum;

  /**
   * @generated from field: required protobuf_unittest.TestRequiredNoMaskMulti.NestedEnum required_enum_4 = 4;
   */
  declare requiredEnum4: TestRequiredNoMaskMulti_NestedEnum;

  /**
   * @generated from field: optional int32 a_3 = 3;
   */
  declare a3: number;

  /**
   * @generated from field: required protobuf_unittest.TestRequiredNoMaskMulti.NestedEnum required_enum_2 = 2;
   */
  declare requiredEnum2: TestRequiredNoMaskMulti_NestedEnum;

  /**
   * @generated from field: required protobuf_unittest.ForeignEnum required_enum_1 = 1;
   */
  declare requiredEnum1: ForeignEnum;

  constructor(data?: PartialMessage<TestRequiredNoMaskMulti>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestRequiredNoMaskMulti";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 80, name: "required_fixed32_80", kind: "scalar", T: 7 /* ScalarType.FIXED32 */, req: true },
    { no: 70, name: "required_fixed32_70", kind: "scalar", T: 7 /* ScalarType.FIXED32 */, req: true },
    { no: 64, name: "required_enum_64", kind: "enum", T: proto2.getEnumType(TestRequiredNoMaskMulti_NestedEnum), req: true },
    { no: 4, name: "required_enum_4", kind: "enum", T: proto2.getEnumType(TestRequiredNoMaskMulti_NestedEnum), req: true },
    { no: 3, name: "a_3", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 2, name: "required_enum_2", kind: "enum", T: proto2.getEnumType(TestRequiredNoMaskMulti_NestedEnum), req: true },
    { no: 1, name: "required_enum_1", kind: "enum", T: proto2.getEnumType(ForeignEnum), req: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestRequiredNoMaskMulti {
    return new TestRequiredNoMaskMulti().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestRequiredNoMaskMulti {
    return new TestRequiredNoMaskMulti().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestRequiredNoMaskMulti {
    return new TestRequiredNoMaskMulti().fromJsonString(jsonString, options);
  }

  static equals(a: TestRequiredNoMaskMulti | PlainMessage<TestRequiredNoMaskMulti> | undefined, b: TestRequiredNoMaskMulti | PlainMessage<TestRequiredNoMaskMulti> | undefined): boolean {
    return proto2.util.equals(TestRequiredNoMaskMulti, a, b);
  }
}

TestRequiredNoMaskMulti.prototype.requiredFixed3280 = 0;
TestRequiredNoMaskMulti.prototype.requiredFixed3270 = 0;
TestRequiredNoMaskMulti.prototype.requiredEnum64 = 0 as TestRequiredNoMaskMulti_NestedEnum.UNSPECIFIED;
TestRequiredNoMaskMulti.prototype.requiredEnum4 = 0 as TestRequiredNoMaskMulti_NestedEnum.UNSPECIFIED;
TestRequiredNoMaskMulti.prototype.a3 = 0;
TestRequiredNoMaskMulti.prototype.requiredEnum2 = 0 as TestRequiredNoMaskMulti_NestedEnum.UNSPECIFIED;
TestRequiredNoMaskMulti.prototype.requiredEnum1 = 4 as ForeignEnum.FOREIGN_FOO;

/**
 * @generated from enum protobuf_unittest.TestRequiredNoMaskMulti.NestedEnum
 */
export enum TestRequiredNoMaskMulti_NestedEnum {
  /**
   * @generated from enum value: UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: FOO = 1;
   */
  FOO = 1,

  /**
   * @generated from enum value: BAR = 2;
   */
  BAR = 2,

  /**
   * @generated from enum value: BAZ = 100;
   */
  BAZ = 100,
}
// Retrieve enum metadata with: proto2.getEnumType(TestRequiredNoMaskMulti_NestedEnum)
proto2.util.setEnumType(TestRequiredNoMaskMulti_NestedEnum, "protobuf_unittest.TestRequiredNoMaskMulti.NestedEnum", [
  { no: 0, name: "UNSPECIFIED" },
  { no: 1, name: "FOO" },
  { no: 2, name: "BAR" },
  { no: 100, name: "BAZ" },
]);

/**
 * We have separate messages for testing required fields because it's
 * annoying to have to fill in required fields in TestProto in order to
 * do anything with it.  Note that we don't need to test every type of
 * required filed because the code output is basically identical to
 * optional fields for all types.
 *
 * @generated from message protobuf_unittest.TestRequired
 */
export class TestRequired extends Message<TestRequired> {
  /**
   * @generated from field: required int32 a = 1;
   */
  declare a: number;

  /**
   * @generated from field: optional int32 dummy2 = 2;
   */
  declare dummy2: number;

  /**
   * @generated from field: required int32 b = 3;
   */
  declare b: number;

  /**
   * Pad the field count to 32 so that we can test that IsInitialized()
   * properly checks multiple elements of has_bits_.
   *
   * @generated from field: optional int32 dummy4 = 4;
   */
  declare dummy4: number;

  /**
   * @generated from field: optional int32 dummy5 = 5;
   */
  declare dummy5: number;

  /**
   * @generated from field: optional int32 dummy6 = 6;
   */
  declare dummy6: number;

  /**
   * @generated from field: optional int32 dummy7 = 7;
   */
  declare dummy7: number;

  /**
   * @generated from field: optional int32 dummy8 = 8;
   */
  declare dummy8: number;

  /**
   * @generated from field: optional int32 dummy9 = 9;
   */
  declare dummy9: number;

  /**
   * @generated from field: optional int32 dummy10 = 10;
   */
  declare dummy10: number;

  /**
   * @generated from field: optional int32 dummy11 = 11;
   */
  declare dummy11: number;

  /**
   * @generated from field: optional int32 dummy12 = 12;
   */
  declare dummy12: number;

  /**
   * @generated from field: optional int32 dummy13 = 13;
   */
  declare dummy13: number;

  /**
   * @generated from field: optional int32 dummy14 = 14;
   */
  declare dummy14: number;

  /**
   * @generated from field: optional int32 dummy15 = 15;
   */
  declare dummy15: number;

  /**
   * @generated from field: optional int32 dummy16 = 16;
   */
  declare dummy16: number;

  /**
   * @generated from field: optional int32 dummy17 = 17;
   */
  declare dummy17: number;

  /**
   * @generated from field: optional int32 dummy18 = 18;
   */
  declare dummy18: number;

  /**
   * @generated from field: optional int32 dummy19 = 19;
   */
  declare dummy19: number;

  /**
   * @generated from field: optional int32 dummy20 = 20;
   */
  declare dummy20: number;

  /**
   * @generated from field: optional int32 dummy21 = 21;
   */
  declare dummy21: number;

  /**
   * @generated from field: optional int32 dummy22 = 22;
   */
  declare dummy22: number;

  /**
   * @generated from field: optional int32 dummy23 = 23;
   */
  declare dummy23: number;

  /**
   * @generated from field: optional int32 dummy24 = 24;
   */
  declare dummy24: number;

  /**
   * @generated from field: optional int32 dummy25 = 25;
   */
  declare dummy25: number;

  /**
   * @generated from field: optional int32 dummy26 = 26;
   */
  declare dummy26: number;

  /**
   * @generated from field: optional int32 dummy27 = 27;
   */
  declare dummy27: number;

  /**
   * @generated from field: optional int32 dummy28 = 28;
   */
  declare dummy28: number;

  /**
   * @generated from field: optional int32 dummy29 = 29;
   */
  declare dummy29: number;

  /**
   * @generated from field: optional int32 dummy30 = 30;
   */
  declare dummy30: number;

  /**
   * @generated from field: optional int32 dummy31 = 31;
   */
  declare dummy31: number;

  /**
   * @generated from field: optional int32 dummy32 = 32;
   */
  declare dummy32: number;

  /**
   * @generated from field: required int32 c = 33;
   */
  declare c: number;

  /**
   * Add an optional child message to make this non-trivial for go/pdlazy.
   *
   * @generated from field: optional protobuf_unittest.ForeignMessage optional_foreign = 34;
   */
  optionalForeign?: ForeignMessage;

  constructor(data?: PartialMessage<TestRequired>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestRequired";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "a", kind: "scalar", T: 5 /* ScalarType.INT32 */, req: true },
    { no: 2, name: "dummy2", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 3, name: "b", kind: "scalar", T: 5 /* ScalarType.INT32 */, req: true },
    { no: 4, name: "dummy4", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 5, name: "dummy5", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 6, name: "dummy6", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 7, name: "dummy7", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 8, name: "dummy8", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 9, name: "dummy9", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 10, name: "dummy10", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 11, name: "dummy11", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 12, name: "dummy12", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 13, name: "dummy13", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 14, name: "dummy14", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 15, name: "dummy15", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 16, name: "dummy16", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 17, name: "dummy17", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 18, name: "dummy18", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 19, name: "dummy19", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 20, name: "dummy20", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 21, name: "dummy21", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 22, name: "dummy22", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 23, name: "dummy23", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 24, name: "dummy24", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 25, name: "dummy25", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 26, name: "dummy26", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 27, name: "dummy27", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 28, name: "dummy28", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 29, name: "dummy29", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 30, name: "dummy30", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 31, name: "dummy31", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 32, name: "dummy32", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 33, name: "c", kind: "scalar", T: 5 /* ScalarType.INT32 */, req: true },
    { no: 34, name: "optional_foreign", kind: "message", T: ForeignMessage, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestRequired {
    return new TestRequired().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestRequired {
    return new TestRequired().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestRequired {
    return new TestRequired().fromJsonString(jsonString, options);
  }

  static equals(a: TestRequired | PlainMessage<TestRequired> | undefined, b: TestRequired | PlainMessage<TestRequired> | undefined): boolean {
    return proto2.util.equals(TestRequired, a, b);
  }
}

TestRequired.prototype.a = 0;
TestRequired.prototype.dummy2 = 0;
TestRequired.prototype.b = 0;
TestRequired.prototype.dummy4 = 0;
TestRequired.prototype.dummy5 = 0;
TestRequired.prototype.dummy6 = 0;
TestRequired.prototype.dummy7 = 0;
TestRequired.prototype.dummy8 = 0;
TestRequired.prototype.dummy9 = 0;
TestRequired.prototype.dummy10 = 0;
TestRequired.prototype.dummy11 = 0;
TestRequired.prototype.dummy12 = 0;
TestRequired.prototype.dummy13 = 0;
TestRequired.prototype.dummy14 = 0;
TestRequired.prototype.dummy15 = 0;
TestRequired.prototype.dummy16 = 0;
TestRequired.prototype.dummy17 = 0;
TestRequired.prototype.dummy18 = 0;
TestRequired.prototype.dummy19 = 0;
TestRequired.prototype.dummy20 = 0;
TestRequired.prototype.dummy21 = 0;
TestRequired.prototype.dummy22 = 0;
TestRequired.prototype.dummy23 = 0;
TestRequired.prototype.dummy24 = 0;
TestRequired.prototype.dummy25 = 0;
TestRequired.prototype.dummy26 = 0;
TestRequired.prototype.dummy27 = 0;
TestRequired.prototype.dummy28 = 0;
TestRequired.prototype.dummy29 = 0;
TestRequired.prototype.dummy30 = 0;
TestRequired.prototype.dummy31 = 0;
TestRequired.prototype.dummy32 = 0;
TestRequired.prototype.c = 0;

/**
 * @generated from extension: optional protobuf_unittest.TestRequired single = 1000;
 */
export const TestRequired_single = proto2.makeExtension<TestAllExtensions, TestRequired>(
  "protobuf_unittest.TestRequired.single", 
  TestAllExtensions, 
  () => ({ no: 1000, kind: "message", T: TestRequired, opt: true }),
);

/**
 * @generated from extension: repeated protobuf_unittest.TestRequired multi = 1001;
 */
export const TestRequired_multi = proto2.makeExtension<TestAllExtensions, TestRequired[]>(
  "protobuf_unittest.TestRequired.multi", 
  TestAllExtensions, 
  () => ({ no: 1001, kind: "message", T: TestRequired, repeated: true }),
);

/**
 * @generated from message protobuf_unittest.TestRequiredForeign
 */
export class TestRequiredForeign extends Message<TestRequiredForeign> {
  /**
   * @generated from field: optional protobuf_unittest.TestRequired optional_message = 1;
   */
  optionalMessage?: TestRequired;

  /**
   * @generated from field: repeated protobuf_unittest.TestRequired repeated_message = 2;
   */
  repeatedMessage: TestRequired[] = [];

  /**
   * @generated from field: optional int32 dummy = 3;
   */
  declare dummy: number;

  /**
   * Missing required fields must not affect verification of child messages.
   *
   * @generated from field: optional protobuf_unittest.NestedTestAllTypes optional_lazy_message = 4;
   */
  optionalLazyMessage?: NestedTestAllTypes;

  constructor(data?: PartialMessage<TestRequiredForeign>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestRequiredForeign";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "optional_message", kind: "message", T: TestRequired, opt: true },
    { no: 2, name: "repeated_message", kind: "message", T: TestRequired, repeated: true },
    { no: 3, name: "dummy", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 4, name: "optional_lazy_message", kind: "message", T: NestedTestAllTypes, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestRequiredForeign {
    return new TestRequiredForeign().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestRequiredForeign {
    return new TestRequiredForeign().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestRequiredForeign {
    return new TestRequiredForeign().fromJsonString(jsonString, options);
  }

  static equals(a: TestRequiredForeign | PlainMessage<TestRequiredForeign> | undefined, b: TestRequiredForeign | PlainMessage<TestRequiredForeign> | undefined): boolean {
    return proto2.util.equals(TestRequiredForeign, a, b);
  }
}

TestRequiredForeign.prototype.dummy = 0;

/**
 * @generated from message protobuf_unittest.TestRequiredMessage
 */
export class TestRequiredMessage extends Message<TestRequiredMessage> {
  /**
   * @generated from field: optional protobuf_unittest.TestRequired optional_message = 1;
   */
  optionalMessage?: TestRequired;

  /**
   * @generated from field: repeated protobuf_unittest.TestRequired repeated_message = 2;
   */
  repeatedMessage: TestRequired[] = [];

  /**
   * @generated from field: required protobuf_unittest.TestRequired required_message = 3;
   */
  requiredMessage?: TestRequired;

  constructor(data?: PartialMessage<TestRequiredMessage>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestRequiredMessage";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "optional_message", kind: "message", T: TestRequired, opt: true },
    { no: 2, name: "repeated_message", kind: "message", T: TestRequired, repeated: true },
    { no: 3, name: "required_message", kind: "message", T: TestRequired, req: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestRequiredMessage {
    return new TestRequiredMessage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestRequiredMessage {
    return new TestRequiredMessage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestRequiredMessage {
    return new TestRequiredMessage().fromJsonString(jsonString, options);
  }

  static equals(a: TestRequiredMessage | PlainMessage<TestRequiredMessage> | undefined, b: TestRequiredMessage | PlainMessage<TestRequiredMessage> | undefined): boolean {
    return proto2.util.equals(TestRequiredMessage, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.TestNestedRequiredForeign
 */
export class TestNestedRequiredForeign extends Message<TestNestedRequiredForeign> {
  /**
   * @generated from field: optional protobuf_unittest.TestNestedRequiredForeign child = 1;
   */
  child?: TestNestedRequiredForeign;

  /**
   * @generated from field: optional protobuf_unittest.TestRequiredForeign payload = 2;
   */
  payload?: TestRequiredForeign;

  /**
   * @generated from field: optional int32 dummy = 3;
   */
  declare dummy: number;

  /**
   * optional message to test required closed enum.
   *
   * @generated from field: optional protobuf_unittest.TestRequiredEnum required_enum = 5;
   */
  requiredEnum?: TestRequiredEnum;

  /**
   * @generated from field: optional protobuf_unittest.TestRequiredEnumNoMask required_enum_no_mask = 6;
   */
  requiredEnumNoMask?: TestRequiredEnumNoMask;

  /**
   * @generated from field: optional protobuf_unittest.TestRequiredEnumMulti required_enum_multi = 7;
   */
  requiredEnumMulti?: TestRequiredEnumMulti;

  /**
   * @generated from field: optional protobuf_unittest.TestRequiredNoMaskMulti required_no_mask = 9;
   */
  requiredNoMask?: TestRequiredNoMaskMulti;

  constructor(data?: PartialMessage<TestNestedRequiredForeign>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestNestedRequiredForeign";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "child", kind: "message", T: TestNestedRequiredForeign, opt: true },
    { no: 2, name: "payload", kind: "message", T: TestRequiredForeign, opt: true },
    { no: 3, name: "dummy", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 5, name: "required_enum", kind: "message", T: TestRequiredEnum, opt: true },
    { no: 6, name: "required_enum_no_mask", kind: "message", T: TestRequiredEnumNoMask, opt: true },
    { no: 7, name: "required_enum_multi", kind: "message", T: TestRequiredEnumMulti, opt: true },
    { no: 9, name: "required_no_mask", kind: "message", T: TestRequiredNoMaskMulti, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestNestedRequiredForeign {
    return new TestNestedRequiredForeign().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestNestedRequiredForeign {
    return new TestNestedRequiredForeign().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestNestedRequiredForeign {
    return new TestNestedRequiredForeign().fromJsonString(jsonString, options);
  }

  static equals(a: TestNestedRequiredForeign | PlainMessage<TestNestedRequiredForeign> | undefined, b: TestNestedRequiredForeign | PlainMessage<TestNestedRequiredForeign> | undefined): boolean {
    return proto2.util.equals(TestNestedRequiredForeign, a, b);
  }
}

TestNestedRequiredForeign.prototype.dummy = 0;

/**
 * Test that we can use NestedMessage from outside TestAllTypes.
 *
 * @generated from message protobuf_unittest.TestForeignNested
 */
export class TestForeignNested extends Message<TestForeignNested> {
  /**
   * @generated from field: optional protobuf_unittest.TestAllTypes.NestedMessage foreign_nested = 1;
   */
  foreignNested?: TestAllTypes_NestedMessage;

  constructor(data?: PartialMessage<TestForeignNested>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestForeignNested";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "foreign_nested", kind: "message", T: TestAllTypes_NestedMessage, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestForeignNested {
    return new TestForeignNested().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestForeignNested {
    return new TestForeignNested().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestForeignNested {
    return new TestForeignNested().fromJsonString(jsonString, options);
  }

  static equals(a: TestForeignNested | PlainMessage<TestForeignNested> | undefined, b: TestForeignNested | PlainMessage<TestForeignNested> | undefined): boolean {
    return proto2.util.equals(TestForeignNested, a, b);
  }
}

/**
 * TestEmptyMessage is used to test unknown field support.
 *
 * @generated from message protobuf_unittest.TestEmptyMessage
 */
export class TestEmptyMessage extends Message<TestEmptyMessage> {
  constructor(data?: PartialMessage<TestEmptyMessage>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestEmptyMessage";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestEmptyMessage {
    return new TestEmptyMessage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestEmptyMessage {
    return new TestEmptyMessage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestEmptyMessage {
    return new TestEmptyMessage().fromJsonString(jsonString, options);
  }

  static equals(a: TestEmptyMessage | PlainMessage<TestEmptyMessage> | undefined, b: TestEmptyMessage | PlainMessage<TestEmptyMessage> | undefined): boolean {
    return proto2.util.equals(TestEmptyMessage, a, b);
  }
}

/**
 * Like above, but declare all field numbers as potential extensions.  No
 * actual extensions should ever be defined for this type.
 *
 * @generated from message protobuf_unittest.TestEmptyMessageWithExtensions
 */
export class TestEmptyMessageWithExtensions extends Message<TestEmptyMessageWithExtensions> {
  constructor(data?: PartialMessage<TestEmptyMessageWithExtensions>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestEmptyMessageWithExtensions";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestEmptyMessageWithExtensions {
    return new TestEmptyMessageWithExtensions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestEmptyMessageWithExtensions {
    return new TestEmptyMessageWithExtensions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestEmptyMessageWithExtensions {
    return new TestEmptyMessageWithExtensions().fromJsonString(jsonString, options);
  }

  static equals(a: TestEmptyMessageWithExtensions | PlainMessage<TestEmptyMessageWithExtensions> | undefined, b: TestEmptyMessageWithExtensions | PlainMessage<TestEmptyMessageWithExtensions> | undefined): boolean {
    return proto2.util.equals(TestEmptyMessageWithExtensions, a, b);
  }
}

/**
 * Needed for a Python test.
 *
 * @generated from message protobuf_unittest.TestPickleNestedMessage
 */
export class TestPickleNestedMessage extends Message<TestPickleNestedMessage> {
  constructor(data?: PartialMessage<TestPickleNestedMessage>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestPickleNestedMessage";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestPickleNestedMessage {
    return new TestPickleNestedMessage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestPickleNestedMessage {
    return new TestPickleNestedMessage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestPickleNestedMessage {
    return new TestPickleNestedMessage().fromJsonString(jsonString, options);
  }

  static equals(a: TestPickleNestedMessage | PlainMessage<TestPickleNestedMessage> | undefined, b: TestPickleNestedMessage | PlainMessage<TestPickleNestedMessage> | undefined): boolean {
    return proto2.util.equals(TestPickleNestedMessage, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.TestPickleNestedMessage.NestedMessage
 */
export class TestPickleNestedMessage_NestedMessage extends Message<TestPickleNestedMessage_NestedMessage> {
  /**
   * @generated from field: optional int32 bb = 1;
   */
  declare bb: number;

  constructor(data?: PartialMessage<TestPickleNestedMessage_NestedMessage>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestPickleNestedMessage.NestedMessage";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "bb", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestPickleNestedMessage_NestedMessage {
    return new TestPickleNestedMessage_NestedMessage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestPickleNestedMessage_NestedMessage {
    return new TestPickleNestedMessage_NestedMessage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestPickleNestedMessage_NestedMessage {
    return new TestPickleNestedMessage_NestedMessage().fromJsonString(jsonString, options);
  }

  static equals(a: TestPickleNestedMessage_NestedMessage | PlainMessage<TestPickleNestedMessage_NestedMessage> | undefined, b: TestPickleNestedMessage_NestedMessage | PlainMessage<TestPickleNestedMessage_NestedMessage> | undefined): boolean {
    return proto2.util.equals(TestPickleNestedMessage_NestedMessage, a, b);
  }
}

TestPickleNestedMessage_NestedMessage.prototype.bb = 0;

/**
 * @generated from message protobuf_unittest.TestPickleNestedMessage.NestedMessage.NestedNestedMessage
 */
export class TestPickleNestedMessage_NestedMessage_NestedNestedMessage extends Message<TestPickleNestedMessage_NestedMessage_NestedNestedMessage> {
  /**
   * @generated from field: optional int32 cc = 1;
   */
  declare cc: number;

  constructor(data?: PartialMessage<TestPickleNestedMessage_NestedMessage_NestedNestedMessage>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestPickleNestedMessage.NestedMessage.NestedNestedMessage";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "cc", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestPickleNestedMessage_NestedMessage_NestedNestedMessage {
    return new TestPickleNestedMessage_NestedMessage_NestedNestedMessage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestPickleNestedMessage_NestedMessage_NestedNestedMessage {
    return new TestPickleNestedMessage_NestedMessage_NestedNestedMessage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestPickleNestedMessage_NestedMessage_NestedNestedMessage {
    return new TestPickleNestedMessage_NestedMessage_NestedNestedMessage().fromJsonString(jsonString, options);
  }

  static equals(a: TestPickleNestedMessage_NestedMessage_NestedNestedMessage | PlainMessage<TestPickleNestedMessage_NestedMessage_NestedNestedMessage> | undefined, b: TestPickleNestedMessage_NestedMessage_NestedNestedMessage | PlainMessage<TestPickleNestedMessage_NestedMessage_NestedNestedMessage> | undefined): boolean {
    return proto2.util.equals(TestPickleNestedMessage_NestedMessage_NestedNestedMessage, a, b);
  }
}

TestPickleNestedMessage_NestedMessage_NestedNestedMessage.prototype.cc = 0;

/**
 * @generated from message protobuf_unittest.TestMultipleExtensionRanges
 */
export class TestMultipleExtensionRanges extends Message<TestMultipleExtensionRanges> {
  constructor(data?: PartialMessage<TestMultipleExtensionRanges>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestMultipleExtensionRanges";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestMultipleExtensionRanges {
    return new TestMultipleExtensionRanges().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestMultipleExtensionRanges {
    return new TestMultipleExtensionRanges().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestMultipleExtensionRanges {
    return new TestMultipleExtensionRanges().fromJsonString(jsonString, options);
  }

  static equals(a: TestMultipleExtensionRanges | PlainMessage<TestMultipleExtensionRanges> | undefined, b: TestMultipleExtensionRanges | PlainMessage<TestMultipleExtensionRanges> | undefined): boolean {
    return proto2.util.equals(TestMultipleExtensionRanges, a, b);
  }
}

/**
 * Test that really large tag numbers don't break anything.
 *
 * @generated from message protobuf_unittest.TestReallyLargeTagNumber
 */
export class TestReallyLargeTagNumber extends Message<TestReallyLargeTagNumber> {
  /**
   * The largest possible tag number is 2^28 - 1, since the wire format uses
   * three bits to communicate wire type.
   *
   * @generated from field: optional int32 a = 1;
   */
  declare a: number;

  /**
   * @generated from field: optional int32 bb = 268435455;
   */
  declare bb: number;

  constructor(data?: PartialMessage<TestReallyLargeTagNumber>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestReallyLargeTagNumber";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "a", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 268435455, name: "bb", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestReallyLargeTagNumber {
    return new TestReallyLargeTagNumber().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestReallyLargeTagNumber {
    return new TestReallyLargeTagNumber().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestReallyLargeTagNumber {
    return new TestReallyLargeTagNumber().fromJsonString(jsonString, options);
  }

  static equals(a: TestReallyLargeTagNumber | PlainMessage<TestReallyLargeTagNumber> | undefined, b: TestReallyLargeTagNumber | PlainMessage<TestReallyLargeTagNumber> | undefined): boolean {
    return proto2.util.equals(TestReallyLargeTagNumber, a, b);
  }
}

TestReallyLargeTagNumber.prototype.a = 0;
TestReallyLargeTagNumber.prototype.bb = 0;

/**
 * @generated from message protobuf_unittest.TestRecursiveMessage
 */
export class TestRecursiveMessage extends Message<TestRecursiveMessage> {
  /**
   * @generated from field: optional protobuf_unittest.TestRecursiveMessage a = 1;
   */
  a?: TestRecursiveMessage;

  /**
   * @generated from field: optional int32 i = 2;
   */
  declare i: number;

  constructor(data?: PartialMessage<TestRecursiveMessage>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestRecursiveMessage";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "a", kind: "message", T: TestRecursiveMessage, opt: true },
    { no: 2, name: "i", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestRecursiveMessage {
    return new TestRecursiveMessage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestRecursiveMessage {
    return new TestRecursiveMessage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestRecursiveMessage {
    return new TestRecursiveMessage().fromJsonString(jsonString, options);
  }

  static equals(a: TestRecursiveMessage | PlainMessage<TestRecursiveMessage> | undefined, b: TestRecursiveMessage | PlainMessage<TestRecursiveMessage> | undefined): boolean {
    return proto2.util.equals(TestRecursiveMessage, a, b);
  }
}

TestRecursiveMessage.prototype.i = 0;

/**
 * Test that mutual recursion works.
 *
 * @generated from message protobuf_unittest.TestMutualRecursionA
 */
export class TestMutualRecursionA extends Message<TestMutualRecursionA> {
  /**
   * @generated from field: optional protobuf_unittest.TestMutualRecursionB bb = 1;
   */
  bb?: TestMutualRecursionB;

  /**
   * @generated from field: optional protobuf_unittest.TestMutualRecursionA.SubGroup subgroup = 2;
   */
  subgroup?: TestMutualRecursionA_SubGroup;

  /**
   * @generated from field: repeated protobuf_unittest.TestMutualRecursionA.SubGroupR subgroupr = 5;
   */
  subgroupr: TestMutualRecursionA_SubGroupR[] = [];

  constructor(data?: PartialMessage<TestMutualRecursionA>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestMutualRecursionA";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "bb", kind: "message", T: TestMutualRecursionB, opt: true },
    { no: 2, name: "subgroup", kind: "message", T: TestMutualRecursionA_SubGroup, delimited: true, opt: true },
    { no: 5, name: "subgroupr", kind: "message", T: TestMutualRecursionA_SubGroupR, delimited: true, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestMutualRecursionA {
    return new TestMutualRecursionA().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestMutualRecursionA {
    return new TestMutualRecursionA().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestMutualRecursionA {
    return new TestMutualRecursionA().fromJsonString(jsonString, options);
  }

  static equals(a: TestMutualRecursionA | PlainMessage<TestMutualRecursionA> | undefined, b: TestMutualRecursionA | PlainMessage<TestMutualRecursionA> | undefined): boolean {
    return proto2.util.equals(TestMutualRecursionA, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.TestMutualRecursionA.SubMessage
 */
export class TestMutualRecursionA_SubMessage extends Message<TestMutualRecursionA_SubMessage> {
  /**
   * @generated from field: optional protobuf_unittest.TestMutualRecursionB b = 1;
   */
  b?: TestMutualRecursionB;

  constructor(data?: PartialMessage<TestMutualRecursionA_SubMessage>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestMutualRecursionA.SubMessage";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "b", kind: "message", T: TestMutualRecursionB, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestMutualRecursionA_SubMessage {
    return new TestMutualRecursionA_SubMessage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestMutualRecursionA_SubMessage {
    return new TestMutualRecursionA_SubMessage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestMutualRecursionA_SubMessage {
    return new TestMutualRecursionA_SubMessage().fromJsonString(jsonString, options);
  }

  static equals(a: TestMutualRecursionA_SubMessage | PlainMessage<TestMutualRecursionA_SubMessage> | undefined, b: TestMutualRecursionA_SubMessage | PlainMessage<TestMutualRecursionA_SubMessage> | undefined): boolean {
    return proto2.util.equals(TestMutualRecursionA_SubMessage, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.TestMutualRecursionA.SubGroup
 */
export class TestMutualRecursionA_SubGroup extends Message<TestMutualRecursionA_SubGroup> {
  /**
   * Needed because of bug in javatest
   *
   * @generated from field: optional protobuf_unittest.TestMutualRecursionA.SubMessage sub_message = 3;
   */
  subMessage?: TestMutualRecursionA_SubMessage;

  /**
   * @generated from field: optional protobuf_unittest.TestAllTypes not_in_this_scc = 4;
   */
  notInThisScc?: TestAllTypes;

  constructor(data?: PartialMessage<TestMutualRecursionA_SubGroup>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestMutualRecursionA.SubGroup";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 3, name: "sub_message", kind: "message", T: TestMutualRecursionA_SubMessage, opt: true },
    { no: 4, name: "not_in_this_scc", kind: "message", T: TestAllTypes, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestMutualRecursionA_SubGroup {
    return new TestMutualRecursionA_SubGroup().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestMutualRecursionA_SubGroup {
    return new TestMutualRecursionA_SubGroup().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestMutualRecursionA_SubGroup {
    return new TestMutualRecursionA_SubGroup().fromJsonString(jsonString, options);
  }

  static equals(a: TestMutualRecursionA_SubGroup | PlainMessage<TestMutualRecursionA_SubGroup> | undefined, b: TestMutualRecursionA_SubGroup | PlainMessage<TestMutualRecursionA_SubGroup> | undefined): boolean {
    return proto2.util.equals(TestMutualRecursionA_SubGroup, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.TestMutualRecursionA.SubGroupR
 */
export class TestMutualRecursionA_SubGroupR extends Message<TestMutualRecursionA_SubGroupR> {
  /**
   * @generated from field: optional protobuf_unittest.TestAllTypes payload = 6;
   */
  payload?: TestAllTypes;

  constructor(data?: PartialMessage<TestMutualRecursionA_SubGroupR>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestMutualRecursionA.SubGroupR";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 6, name: "payload", kind: "message", T: TestAllTypes, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestMutualRecursionA_SubGroupR {
    return new TestMutualRecursionA_SubGroupR().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestMutualRecursionA_SubGroupR {
    return new TestMutualRecursionA_SubGroupR().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestMutualRecursionA_SubGroupR {
    return new TestMutualRecursionA_SubGroupR().fromJsonString(jsonString, options);
  }

  static equals(a: TestMutualRecursionA_SubGroupR | PlainMessage<TestMutualRecursionA_SubGroupR> | undefined, b: TestMutualRecursionA_SubGroupR | PlainMessage<TestMutualRecursionA_SubGroupR> | undefined): boolean {
    return proto2.util.equals(TestMutualRecursionA_SubGroupR, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.TestMutualRecursionB
 */
export class TestMutualRecursionB extends Message<TestMutualRecursionB> {
  /**
   * @generated from field: optional protobuf_unittest.TestMutualRecursionA a = 1;
   */
  a?: TestMutualRecursionA;

  /**
   * @generated from field: optional int32 optional_int32 = 2;
   */
  declare optionalInt32: number;

  constructor(data?: PartialMessage<TestMutualRecursionB>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestMutualRecursionB";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "a", kind: "message", T: TestMutualRecursionA, opt: true },
    { no: 2, name: "optional_int32", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestMutualRecursionB {
    return new TestMutualRecursionB().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestMutualRecursionB {
    return new TestMutualRecursionB().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestMutualRecursionB {
    return new TestMutualRecursionB().fromJsonString(jsonString, options);
  }

  static equals(a: TestMutualRecursionB | PlainMessage<TestMutualRecursionB> | undefined, b: TestMutualRecursionB | PlainMessage<TestMutualRecursionB> | undefined): boolean {
    return proto2.util.equals(TestMutualRecursionB, a, b);
  }
}

TestMutualRecursionB.prototype.optionalInt32 = 0;

/**
 * @generated from message protobuf_unittest.TestIsInitialized
 */
export class TestIsInitialized extends Message<TestIsInitialized> {
  /**
   * @generated from field: optional protobuf_unittest.TestIsInitialized.SubMessage sub_message = 1;
   */
  subMessage?: TestIsInitialized_SubMessage;

  constructor(data?: PartialMessage<TestIsInitialized>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestIsInitialized";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "sub_message", kind: "message", T: TestIsInitialized_SubMessage, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestIsInitialized {
    return new TestIsInitialized().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestIsInitialized {
    return new TestIsInitialized().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestIsInitialized {
    return new TestIsInitialized().fromJsonString(jsonString, options);
  }

  static equals(a: TestIsInitialized | PlainMessage<TestIsInitialized> | undefined, b: TestIsInitialized | PlainMessage<TestIsInitialized> | undefined): boolean {
    return proto2.util.equals(TestIsInitialized, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.TestIsInitialized.SubMessage
 */
export class TestIsInitialized_SubMessage extends Message<TestIsInitialized_SubMessage> {
  /**
   * @generated from field: optional protobuf_unittest.TestIsInitialized.SubMessage.SubGroup subgroup = 1;
   */
  subgroup?: TestIsInitialized_SubMessage_SubGroup;

  constructor(data?: PartialMessage<TestIsInitialized_SubMessage>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestIsInitialized.SubMessage";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "subgroup", kind: "message", T: TestIsInitialized_SubMessage_SubGroup, delimited: true, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestIsInitialized_SubMessage {
    return new TestIsInitialized_SubMessage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestIsInitialized_SubMessage {
    return new TestIsInitialized_SubMessage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestIsInitialized_SubMessage {
    return new TestIsInitialized_SubMessage().fromJsonString(jsonString, options);
  }

  static equals(a: TestIsInitialized_SubMessage | PlainMessage<TestIsInitialized_SubMessage> | undefined, b: TestIsInitialized_SubMessage | PlainMessage<TestIsInitialized_SubMessage> | undefined): boolean {
    return proto2.util.equals(TestIsInitialized_SubMessage, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.TestIsInitialized.SubMessage.SubGroup
 */
export class TestIsInitialized_SubMessage_SubGroup extends Message<TestIsInitialized_SubMessage_SubGroup> {
  /**
   * @generated from field: required int32 i = 2;
   */
  declare i: number;

  constructor(data?: PartialMessage<TestIsInitialized_SubMessage_SubGroup>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestIsInitialized.SubMessage.SubGroup";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 2, name: "i", kind: "scalar", T: 5 /* ScalarType.INT32 */, req: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestIsInitialized_SubMessage_SubGroup {
    return new TestIsInitialized_SubMessage_SubGroup().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestIsInitialized_SubMessage_SubGroup {
    return new TestIsInitialized_SubMessage_SubGroup().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestIsInitialized_SubMessage_SubGroup {
    return new TestIsInitialized_SubMessage_SubGroup().fromJsonString(jsonString, options);
  }

  static equals(a: TestIsInitialized_SubMessage_SubGroup | PlainMessage<TestIsInitialized_SubMessage_SubGroup> | undefined, b: TestIsInitialized_SubMessage_SubGroup | PlainMessage<TestIsInitialized_SubMessage_SubGroup> | undefined): boolean {
    return proto2.util.equals(TestIsInitialized_SubMessage_SubGroup, a, b);
  }
}

TestIsInitialized_SubMessage_SubGroup.prototype.i = 0;

/**
 * Test that groups have disjoint field numbers from their siblings and
 * parents.  This is NOT possible in proto1; only google.protobuf.  When attempting
 * to compile with proto1, this will emit an error; so we only include it
 * in protobuf_unittest_proto.
 *
 * NO_PROTO1
 *
 * @generated from message protobuf_unittest.TestDupFieldNumber
 */
export class TestDupFieldNumber extends Message<TestDupFieldNumber> {
  /**
   * NO_PROTO1
   *
   * @generated from field: optional int32 a = 1;
   */
  declare a: number;

  /**
   * @generated from field: optional protobuf_unittest.TestDupFieldNumber.Foo foo = 2;
   */
  foo?: TestDupFieldNumber_Foo;

  /**
   * @generated from field: optional protobuf_unittest.TestDupFieldNumber.Bar bar = 3;
   */
  bar?: TestDupFieldNumber_Bar;

  constructor(data?: PartialMessage<TestDupFieldNumber>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestDupFieldNumber";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "a", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 2, name: "foo", kind: "message", T: TestDupFieldNumber_Foo, delimited: true, opt: true },
    { no: 3, name: "bar", kind: "message", T: TestDupFieldNumber_Bar, delimited: true, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestDupFieldNumber {
    return new TestDupFieldNumber().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestDupFieldNumber {
    return new TestDupFieldNumber().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestDupFieldNumber {
    return new TestDupFieldNumber().fromJsonString(jsonString, options);
  }

  static equals(a: TestDupFieldNumber | PlainMessage<TestDupFieldNumber> | undefined, b: TestDupFieldNumber | PlainMessage<TestDupFieldNumber> | undefined): boolean {
    return proto2.util.equals(TestDupFieldNumber, a, b);
  }
}

TestDupFieldNumber.prototype.a = 0;

/**
 * @generated from message protobuf_unittest.TestDupFieldNumber.Foo
 */
export class TestDupFieldNumber_Foo extends Message<TestDupFieldNumber_Foo> {
  /**
   * @generated from field: optional int32 a = 1;
   */
  declare a: number;

  constructor(data?: PartialMessage<TestDupFieldNumber_Foo>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestDupFieldNumber.Foo";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "a", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestDupFieldNumber_Foo {
    return new TestDupFieldNumber_Foo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestDupFieldNumber_Foo {
    return new TestDupFieldNumber_Foo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestDupFieldNumber_Foo {
    return new TestDupFieldNumber_Foo().fromJsonString(jsonString, options);
  }

  static equals(a: TestDupFieldNumber_Foo | PlainMessage<TestDupFieldNumber_Foo> | undefined, b: TestDupFieldNumber_Foo | PlainMessage<TestDupFieldNumber_Foo> | undefined): boolean {
    return proto2.util.equals(TestDupFieldNumber_Foo, a, b);
  }
}

TestDupFieldNumber_Foo.prototype.a = 0;

/**
 * @generated from message protobuf_unittest.TestDupFieldNumber.Bar
 */
export class TestDupFieldNumber_Bar extends Message<TestDupFieldNumber_Bar> {
  /**
   * @generated from field: optional int32 a = 1;
   */
  declare a: number;

  constructor(data?: PartialMessage<TestDupFieldNumber_Bar>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestDupFieldNumber.Bar";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "a", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestDupFieldNumber_Bar {
    return new TestDupFieldNumber_Bar().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestDupFieldNumber_Bar {
    return new TestDupFieldNumber_Bar().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestDupFieldNumber_Bar {
    return new TestDupFieldNumber_Bar().fromJsonString(jsonString, options);
  }

  static equals(a: TestDupFieldNumber_Bar | PlainMessage<TestDupFieldNumber_Bar> | undefined, b: TestDupFieldNumber_Bar | PlainMessage<TestDupFieldNumber_Bar> | undefined): boolean {
    return proto2.util.equals(TestDupFieldNumber_Bar, a, b);
  }
}

TestDupFieldNumber_Bar.prototype.a = 0;

/**
 * Additional messages for testing lazy fields.
 *
 * @generated from message protobuf_unittest.TestEagerMessage
 */
export class TestEagerMessage extends Message<TestEagerMessage> {
  /**
   * @generated from field: optional protobuf_unittest.TestAllTypes sub_message = 1;
   */
  subMessage?: TestAllTypes;

  constructor(data?: PartialMessage<TestEagerMessage>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestEagerMessage";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "sub_message", kind: "message", T: TestAllTypes, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestEagerMessage {
    return new TestEagerMessage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestEagerMessage {
    return new TestEagerMessage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestEagerMessage {
    return new TestEagerMessage().fromJsonString(jsonString, options);
  }

  static equals(a: TestEagerMessage | PlainMessage<TestEagerMessage> | undefined, b: TestEagerMessage | PlainMessage<TestEagerMessage> | undefined): boolean {
    return proto2.util.equals(TestEagerMessage, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.TestLazyMessage
 */
export class TestLazyMessage extends Message<TestLazyMessage> {
  /**
   * @generated from field: optional protobuf_unittest.TestAllTypes sub_message = 1;
   */
  subMessage?: TestAllTypes;

  constructor(data?: PartialMessage<TestLazyMessage>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestLazyMessage";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "sub_message", kind: "message", T: TestAllTypes, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestLazyMessage {
    return new TestLazyMessage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestLazyMessage {
    return new TestLazyMessage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestLazyMessage {
    return new TestLazyMessage().fromJsonString(jsonString, options);
  }

  static equals(a: TestLazyMessage | PlainMessage<TestLazyMessage> | undefined, b: TestLazyMessage | PlainMessage<TestLazyMessage> | undefined): boolean {
    return proto2.util.equals(TestLazyMessage, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.TestLazyMessageRepeated
 */
export class TestLazyMessageRepeated extends Message<TestLazyMessageRepeated> {
  /**
   * @generated from field: repeated protobuf_unittest.TestLazyMessage repeated_message = 1;
   */
  repeatedMessage: TestLazyMessage[] = [];

  constructor(data?: PartialMessage<TestLazyMessageRepeated>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestLazyMessageRepeated";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "repeated_message", kind: "message", T: TestLazyMessage, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestLazyMessageRepeated {
    return new TestLazyMessageRepeated().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestLazyMessageRepeated {
    return new TestLazyMessageRepeated().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestLazyMessageRepeated {
    return new TestLazyMessageRepeated().fromJsonString(jsonString, options);
  }

  static equals(a: TestLazyMessageRepeated | PlainMessage<TestLazyMessageRepeated> | undefined, b: TestLazyMessageRepeated | PlainMessage<TestLazyMessageRepeated> | undefined): boolean {
    return proto2.util.equals(TestLazyMessageRepeated, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.TestEagerMaybeLazy
 */
export class TestEagerMaybeLazy extends Message<TestEagerMaybeLazy> {
  /**
   * @generated from field: optional protobuf_unittest.TestAllTypes message_foo = 1;
   */
  messageFoo?: TestAllTypes;

  /**
   * @generated from field: optional protobuf_unittest.TestAllTypes message_bar = 2;
   */
  messageBar?: TestAllTypes;

  /**
   * @generated from field: optional protobuf_unittest.TestEagerMaybeLazy.NestedMessage message_baz = 3;
   */
  messageBaz?: TestEagerMaybeLazy_NestedMessage;

  constructor(data?: PartialMessage<TestEagerMaybeLazy>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestEagerMaybeLazy";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "message_foo", kind: "message", T: TestAllTypes, opt: true },
    { no: 2, name: "message_bar", kind: "message", T: TestAllTypes, opt: true },
    { no: 3, name: "message_baz", kind: "message", T: TestEagerMaybeLazy_NestedMessage, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestEagerMaybeLazy {
    return new TestEagerMaybeLazy().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestEagerMaybeLazy {
    return new TestEagerMaybeLazy().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestEagerMaybeLazy {
    return new TestEagerMaybeLazy().fromJsonString(jsonString, options);
  }

  static equals(a: TestEagerMaybeLazy | PlainMessage<TestEagerMaybeLazy> | undefined, b: TestEagerMaybeLazy | PlainMessage<TestEagerMaybeLazy> | undefined): boolean {
    return proto2.util.equals(TestEagerMaybeLazy, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.TestEagerMaybeLazy.NestedMessage
 */
export class TestEagerMaybeLazy_NestedMessage extends Message<TestEagerMaybeLazy_NestedMessage> {
  /**
   * @generated from field: optional protobuf_unittest.TestPackedTypes packed = 1;
   */
  packed?: TestPackedTypes;

  constructor(data?: PartialMessage<TestEagerMaybeLazy_NestedMessage>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestEagerMaybeLazy.NestedMessage";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "packed", kind: "message", T: TestPackedTypes, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestEagerMaybeLazy_NestedMessage {
    return new TestEagerMaybeLazy_NestedMessage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestEagerMaybeLazy_NestedMessage {
    return new TestEagerMaybeLazy_NestedMessage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestEagerMaybeLazy_NestedMessage {
    return new TestEagerMaybeLazy_NestedMessage().fromJsonString(jsonString, options);
  }

  static equals(a: TestEagerMaybeLazy_NestedMessage | PlainMessage<TestEagerMaybeLazy_NestedMessage> | undefined, b: TestEagerMaybeLazy_NestedMessage | PlainMessage<TestEagerMaybeLazy_NestedMessage> | undefined): boolean {
    return proto2.util.equals(TestEagerMaybeLazy_NestedMessage, a, b);
  }
}

/**
 * Needed for a Python test.
 *
 * @generated from message protobuf_unittest.TestNestedMessageHasBits
 */
export class TestNestedMessageHasBits extends Message<TestNestedMessageHasBits> {
  /**
   * @generated from field: optional protobuf_unittest.TestNestedMessageHasBits.NestedMessage optional_nested_message = 1;
   */
  optionalNestedMessage?: TestNestedMessageHasBits_NestedMessage;

  constructor(data?: PartialMessage<TestNestedMessageHasBits>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestNestedMessageHasBits";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "optional_nested_message", kind: "message", T: TestNestedMessageHasBits_NestedMessage, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestNestedMessageHasBits {
    return new TestNestedMessageHasBits().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestNestedMessageHasBits {
    return new TestNestedMessageHasBits().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestNestedMessageHasBits {
    return new TestNestedMessageHasBits().fromJsonString(jsonString, options);
  }

  static equals(a: TestNestedMessageHasBits | PlainMessage<TestNestedMessageHasBits> | undefined, b: TestNestedMessageHasBits | PlainMessage<TestNestedMessageHasBits> | undefined): boolean {
    return proto2.util.equals(TestNestedMessageHasBits, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.TestNestedMessageHasBits.NestedMessage
 */
export class TestNestedMessageHasBits_NestedMessage extends Message<TestNestedMessageHasBits_NestedMessage> {
  /**
   * @generated from field: repeated int32 nestedmessage_repeated_int32 = 1;
   */
  nestedmessageRepeatedInt32: number[] = [];

  /**
   * @generated from field: repeated protobuf_unittest.ForeignMessage nestedmessage_repeated_foreignmessage = 2;
   */
  nestedmessageRepeatedForeignmessage: ForeignMessage[] = [];

  constructor(data?: PartialMessage<TestNestedMessageHasBits_NestedMessage>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestNestedMessageHasBits.NestedMessage";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "nestedmessage_repeated_int32", kind: "scalar", T: 5 /* ScalarType.INT32 */, repeated: true },
    { no: 2, name: "nestedmessage_repeated_foreignmessage", kind: "message", T: ForeignMessage, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestNestedMessageHasBits_NestedMessage {
    return new TestNestedMessageHasBits_NestedMessage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestNestedMessageHasBits_NestedMessage {
    return new TestNestedMessageHasBits_NestedMessage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestNestedMessageHasBits_NestedMessage {
    return new TestNestedMessageHasBits_NestedMessage().fromJsonString(jsonString, options);
  }

  static equals(a: TestNestedMessageHasBits_NestedMessage | PlainMessage<TestNestedMessageHasBits_NestedMessage> | undefined, b: TestNestedMessageHasBits_NestedMessage | PlainMessage<TestNestedMessageHasBits_NestedMessage> | undefined): boolean {
    return proto2.util.equals(TestNestedMessageHasBits_NestedMessage, a, b);
  }
}

/**
 * Test message with CamelCase field names.  This violates Protocol Buffer
 * standard style.
 *
 * @generated from message protobuf_unittest.TestCamelCaseFieldNames
 */
export class TestCamelCaseFieldNames extends Message<TestCamelCaseFieldNames> {
  /**
   * @generated from field: optional int32 PrimitiveField = 1;
   */
  declare PrimitiveField: number;

  /**
   * @generated from field: optional string StringField = 2;
   */
  declare StringField: string;

  /**
   * @generated from field: optional protobuf_unittest.ForeignEnum EnumField = 3;
   */
  declare EnumField: ForeignEnum;

  /**
   * @generated from field: optional protobuf_unittest.ForeignMessage MessageField = 4;
   */
  MessageField?: ForeignMessage;

  /**
   * @generated from field: optional string StringPieceField = 5;
   */
  declare StringPieceField: string;

  /**
   * @generated from field: optional string CordField = 6;
   */
  declare CordField: string;

  /**
   * @generated from field: repeated int32 RepeatedPrimitiveField = 7;
   */
  RepeatedPrimitiveField: number[] = [];

  /**
   * @generated from field: repeated string RepeatedStringField = 8;
   */
  RepeatedStringField: string[] = [];

  /**
   * @generated from field: repeated protobuf_unittest.ForeignEnum RepeatedEnumField = 9;
   */
  RepeatedEnumField: ForeignEnum[] = [];

  /**
   * @generated from field: repeated protobuf_unittest.ForeignMessage RepeatedMessageField = 10;
   */
  RepeatedMessageField: ForeignMessage[] = [];

  /**
   * @generated from field: repeated string RepeatedStringPieceField = 11;
   */
  RepeatedStringPieceField: string[] = [];

  /**
   * @generated from field: repeated string RepeatedCordField = 12;
   */
  RepeatedCordField: string[] = [];

  constructor(data?: PartialMessage<TestCamelCaseFieldNames>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestCamelCaseFieldNames";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "PrimitiveField", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 2, name: "StringField", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "EnumField", kind: "enum", T: proto2.getEnumType(ForeignEnum), opt: true },
    { no: 4, name: "MessageField", kind: "message", T: ForeignMessage, opt: true },
    { no: 5, name: "StringPieceField", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "CordField", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 7, name: "RepeatedPrimitiveField", kind: "scalar", T: 5 /* ScalarType.INT32 */, repeated: true },
    { no: 8, name: "RepeatedStringField", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 9, name: "RepeatedEnumField", kind: "enum", T: proto2.getEnumType(ForeignEnum), repeated: true },
    { no: 10, name: "RepeatedMessageField", kind: "message", T: ForeignMessage, repeated: true },
    { no: 11, name: "RepeatedStringPieceField", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 12, name: "RepeatedCordField", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestCamelCaseFieldNames {
    return new TestCamelCaseFieldNames().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestCamelCaseFieldNames {
    return new TestCamelCaseFieldNames().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestCamelCaseFieldNames {
    return new TestCamelCaseFieldNames().fromJsonString(jsonString, options);
  }

  static equals(a: TestCamelCaseFieldNames | PlainMessage<TestCamelCaseFieldNames> | undefined, b: TestCamelCaseFieldNames | PlainMessage<TestCamelCaseFieldNames> | undefined): boolean {
    return proto2.util.equals(TestCamelCaseFieldNames, a, b);
  }
}

TestCamelCaseFieldNames.prototype.PrimitiveField = 0;
TestCamelCaseFieldNames.prototype.StringField = "";
TestCamelCaseFieldNames.prototype.EnumField = 4 as ForeignEnum.FOREIGN_FOO;
TestCamelCaseFieldNames.prototype.StringPieceField = "";
TestCamelCaseFieldNames.prototype.CordField = "";

/**
 * We list fields out of order, to ensure that we're using field number and not
 * field index to determine serialization order.
 *
 * @generated from message protobuf_unittest.TestFieldOrderings
 */
export class TestFieldOrderings extends Message<TestFieldOrderings> {
  /**
   * @generated from field: optional string my_string = 11;
   */
  declare myString: string;

  /**
   * @generated from field: optional int64 my_int = 1;
   */
  declare myInt: bigint;

  /**
   * @generated from field: optional float my_float = 101;
   */
  declare myFloat: number;

  /**
   * @generated from field: optional protobuf_unittest.TestFieldOrderings.NestedMessage optional_nested_message = 200;
   */
  optionalNestedMessage?: TestFieldOrderings_NestedMessage;

  constructor(data?: PartialMessage<TestFieldOrderings>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestFieldOrderings";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 11, name: "my_string", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 1, name: "my_int", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 101, name: "my_float", kind: "scalar", T: 2 /* ScalarType.FLOAT */, opt: true },
    { no: 200, name: "optional_nested_message", kind: "message", T: TestFieldOrderings_NestedMessage, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestFieldOrderings {
    return new TestFieldOrderings().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestFieldOrderings {
    return new TestFieldOrderings().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestFieldOrderings {
    return new TestFieldOrderings().fromJsonString(jsonString, options);
  }

  static equals(a: TestFieldOrderings | PlainMessage<TestFieldOrderings> | undefined, b: TestFieldOrderings | PlainMessage<TestFieldOrderings> | undefined): boolean {
    return proto2.util.equals(TestFieldOrderings, a, b);
  }
}

TestFieldOrderings.prototype.myString = "";
TestFieldOrderings.prototype.myInt = protoInt64.zero;
TestFieldOrderings.prototype.myFloat = 0;

/**
 * @generated from message protobuf_unittest.TestFieldOrderings.NestedMessage
 */
export class TestFieldOrderings_NestedMessage extends Message<TestFieldOrderings_NestedMessage> {
  /**
   * @generated from field: optional int64 oo = 2;
   */
  declare oo: bigint;

  /**
   * The field name "b" fails to compile in proto1 because it conflicts with
   * a local variable named "b" in one of the generated methods.  Doh.
   * This file needs to compile in proto1 to test backwards-compatibility.
   *
   * @generated from field: optional int32 bb = 1;
   */
  declare bb: number;

  constructor(data?: PartialMessage<TestFieldOrderings_NestedMessage>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestFieldOrderings.NestedMessage";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 2, name: "oo", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 1, name: "bb", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestFieldOrderings_NestedMessage {
    return new TestFieldOrderings_NestedMessage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestFieldOrderings_NestedMessage {
    return new TestFieldOrderings_NestedMessage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestFieldOrderings_NestedMessage {
    return new TestFieldOrderings_NestedMessage().fromJsonString(jsonString, options);
  }

  static equals(a: TestFieldOrderings_NestedMessage | PlainMessage<TestFieldOrderings_NestedMessage> | undefined, b: TestFieldOrderings_NestedMessage | PlainMessage<TestFieldOrderings_NestedMessage> | undefined): boolean {
    return proto2.util.equals(TestFieldOrderings_NestedMessage, a, b);
  }
}

TestFieldOrderings_NestedMessage.prototype.oo = protoInt64.zero;
TestFieldOrderings_NestedMessage.prototype.bb = 0;

/**
 * @generated from message protobuf_unittest.TestExtensionOrderings1
 */
export class TestExtensionOrderings1 extends Message<TestExtensionOrderings1> {
  /**
   * @generated from field: optional string my_string = 1;
   */
  declare myString: string;

  constructor(data?: PartialMessage<TestExtensionOrderings1>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestExtensionOrderings1";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "my_string", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestExtensionOrderings1 {
    return new TestExtensionOrderings1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestExtensionOrderings1 {
    return new TestExtensionOrderings1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestExtensionOrderings1 {
    return new TestExtensionOrderings1().fromJsonString(jsonString, options);
  }

  static equals(a: TestExtensionOrderings1 | PlainMessage<TestExtensionOrderings1> | undefined, b: TestExtensionOrderings1 | PlainMessage<TestExtensionOrderings1> | undefined): boolean {
    return proto2.util.equals(TestExtensionOrderings1, a, b);
  }
}

TestExtensionOrderings1.prototype.myString = "";

/**
 * @generated from extension: optional protobuf_unittest.TestExtensionOrderings1 test_ext_orderings1 = 13;
 */
export const TestExtensionOrderings1_test_ext_orderings1 = proto2.makeExtension<TestFieldOrderings, TestExtensionOrderings1>(
  "protobuf_unittest.TestExtensionOrderings1.test_ext_orderings1", 
  TestFieldOrderings, 
  () => ({ no: 13, kind: "message", T: TestExtensionOrderings1, opt: true }),
);

/**
 * @generated from message protobuf_unittest.TestExtensionOrderings2
 */
export class TestExtensionOrderings2 extends Message<TestExtensionOrderings2> {
  /**
   * @generated from field: optional string my_string = 1;
   */
  declare myString: string;

  constructor(data?: PartialMessage<TestExtensionOrderings2>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestExtensionOrderings2";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "my_string", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestExtensionOrderings2 {
    return new TestExtensionOrderings2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestExtensionOrderings2 {
    return new TestExtensionOrderings2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestExtensionOrderings2 {
    return new TestExtensionOrderings2().fromJsonString(jsonString, options);
  }

  static equals(a: TestExtensionOrderings2 | PlainMessage<TestExtensionOrderings2> | undefined, b: TestExtensionOrderings2 | PlainMessage<TestExtensionOrderings2> | undefined): boolean {
    return proto2.util.equals(TestExtensionOrderings2, a, b);
  }
}

TestExtensionOrderings2.prototype.myString = "";

/**
 * @generated from message protobuf_unittest.TestExtensionOrderings2.TestExtensionOrderings3
 */
export class TestExtensionOrderings2_TestExtensionOrderings3 extends Message<TestExtensionOrderings2_TestExtensionOrderings3> {
  /**
   * @generated from field: optional string my_string = 1;
   */
  declare myString: string;

  constructor(data?: PartialMessage<TestExtensionOrderings2_TestExtensionOrderings3>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestExtensionOrderings2.TestExtensionOrderings3";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "my_string", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestExtensionOrderings2_TestExtensionOrderings3 {
    return new TestExtensionOrderings2_TestExtensionOrderings3().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestExtensionOrderings2_TestExtensionOrderings3 {
    return new TestExtensionOrderings2_TestExtensionOrderings3().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestExtensionOrderings2_TestExtensionOrderings3 {
    return new TestExtensionOrderings2_TestExtensionOrderings3().fromJsonString(jsonString, options);
  }

  static equals(a: TestExtensionOrderings2_TestExtensionOrderings3 | PlainMessage<TestExtensionOrderings2_TestExtensionOrderings3> | undefined, b: TestExtensionOrderings2_TestExtensionOrderings3 | PlainMessage<TestExtensionOrderings2_TestExtensionOrderings3> | undefined): boolean {
    return proto2.util.equals(TestExtensionOrderings2_TestExtensionOrderings3, a, b);
  }
}

TestExtensionOrderings2_TestExtensionOrderings3.prototype.myString = "";

/**
 * @generated from extension: optional protobuf_unittest.TestExtensionOrderings2.TestExtensionOrderings3 test_ext_orderings3 = 14;
 */
export const TestExtensionOrderings2_TestExtensionOrderings3_test_ext_orderings3 = proto2.makeExtension<TestFieldOrderings, TestExtensionOrderings2_TestExtensionOrderings3>(
  "protobuf_unittest.TestExtensionOrderings2.TestExtensionOrderings3.test_ext_orderings3", 
  TestFieldOrderings, 
  () => ({ no: 14, kind: "message", T: TestExtensionOrderings2_TestExtensionOrderings3, opt: true }),
);

/**
 * @generated from extension: optional protobuf_unittest.TestExtensionOrderings2 test_ext_orderings2 = 12;
 */
export const TestExtensionOrderings2_test_ext_orderings2 = proto2.makeExtension<TestFieldOrderings, TestExtensionOrderings2>(
  "protobuf_unittest.TestExtensionOrderings2.test_ext_orderings2", 
  TestFieldOrderings, 
  () => ({ no: 12, kind: "message", T: TestExtensionOrderings2, opt: true }),
);

/**
 * @generated from message protobuf_unittest.TestExtremeDefaultValues
 */
export class TestExtremeDefaultValues extends Message<TestExtremeDefaultValues> {
  /**
   * @generated from field: optional bytes escaped_bytes = 1 [default = "\000\001\007\010\014\n\r\t\013\\\'\\"\376"];
   */
  declare escapedBytes: Uint8Array;

  /**
   * @generated from field: optional uint32 large_uint32 = 2 [default = 4294967295];
   */
  declare largeUint32: number;

  /**
   * @generated from field: optional uint64 large_uint64 = 3 [default = 18446744073709551615];
   */
  declare largeUint64: bigint;

  /**
   * @generated from field: optional int32 small_int32 = 4 [default = -2147483647];
   */
  declare smallInt32: number;

  /**
   * @generated from field: optional int64 small_int64 = 5 [default = -9223372036854775807];
   */
  declare smallInt64: bigint;

  /**
   * @generated from field: optional int32 really_small_int32 = 21 [default = -2147483648];
   */
  declare reallySmallInt32: number;

  /**
   * @generated from field: optional int64 really_small_int64 = 22 [default = -9223372036854775808];
   */
  declare reallySmallInt64: bigint;

  /**
   * The default value here is UTF-8 for "\u1234".  (We could also just type
   * the UTF-8 text directly into this text file rather than escape it, but
   * lots of people use editors that would be confused by this.)
   *
   * @generated from field: optional string utf8_string = 6 [default = ""];
   */
  declare utf8String: string;

  /**
   * Tests for single-precision floating-point values.
   *
   * @generated from field: optional float zero_float = 7 [default = 0];
   */
  declare zeroFloat: number;

  /**
   * @generated from field: optional float one_float = 8 [default = 1];
   */
  declare oneFloat: number;

  /**
   * @generated from field: optional float small_float = 9 [default = 1.5];
   */
  declare smallFloat: number;

  /**
   * @generated from field: optional float negative_one_float = 10 [default = -1];
   */
  declare negativeOneFloat: number;

  /**
   * @generated from field: optional float negative_float = 11 [default = -1.5];
   */
  declare negativeFloat: number;

  /**
   * Using exponents
   *
   * @generated from field: optional float large_float = 12 [default = 2e+08];
   */
  declare largeFloat: number;

  /**
   * @generated from field: optional float small_negative_float = 13 [default = -8e-28];
   */
  declare smallNegativeFloat: number;

  /**
   * Text for nonfinite floating-point values.
   *
   * @generated from field: optional double inf_double = 14 [default = inf];
   */
  declare infDouble: number;

  /**
   * @generated from field: optional double neg_inf_double = 15 [default = -inf];
   */
  declare negInfDouble: number;

  /**
   * @generated from field: optional double nan_double = 16 [default = nan];
   */
  declare nanDouble: number;

  /**
   * @generated from field: optional float inf_float = 17 [default = inf];
   */
  declare infFloat: number;

  /**
   * @generated from field: optional float neg_inf_float = 18 [default = -inf];
   */
  declare negInfFloat: number;

  /**
   * @generated from field: optional float nan_float = 19 [default = nan];
   */
  declare nanFloat: number;

  /**
   * Tests for C++ trigraphs.
   * Trigraphs should be escaped in C++ generated files, but they should not be
   * escaped for other languages.
   * Note that in .proto file, "\?" is a valid way to escape ? in string
   * literals.
   *
   * @generated from field: optional string cpp_trigraph = 20 [default = "? ? ?? ?? ??? ??/ ??-"];
   */
  declare cppTrigraph: string;

  /**
   * String defaults containing the character '\000'
   *
   * @generated from field: optional string string_with_zero = 23 [default = "hel lo"];
   */
  declare stringWithZero: string;

  /**
   * @generated from field: optional bytes bytes_with_zero = 24 [default = "wor\000ld"];
   */
  declare bytesWithZero: Uint8Array;

  /**
   * @generated from field: optional string string_piece_with_zero = 25 [default = "ab c"];
   */
  declare stringPieceWithZero: string;

  /**
   * @generated from field: optional string cord_with_zero = 26 [default = "12 3"];
   */
  declare cordWithZero: string;

  /**
   * @generated from field: optional string replacement_string = 27 [default = "${unknown}"];
   */
  declare replacementString: string;

  constructor(data?: PartialMessage<TestExtremeDefaultValues>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestExtremeDefaultValues";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "escaped_bytes", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true, default: new Uint8Array([0x00, 0x01, 0x07, 0x08, 0x0C, 0x0A, 0x0D, 0x09, 0x0B, 0x5C, 0xFE]) },
    { no: 2, name: "large_uint32", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true, default: 4294967295 },
    { no: 3, name: "large_uint64", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true, default: protoInt64.uParse("18446744073709551615") },
    { no: 4, name: "small_int32", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true, default: -2147483647 },
    { no: 5, name: "small_int64", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true, default: protoInt64.parse("-9223372036854775807") },
    { no: 21, name: "really_small_int32", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true, default: -2147483648 },
    { no: 22, name: "really_small_int64", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true, default: protoInt64.parse("-9223372036854775808") },
    { no: 6, name: "utf8_string", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true, default: "" },
    { no: 7, name: "zero_float", kind: "scalar", T: 2 /* ScalarType.FLOAT */, opt: true, default: 0 },
    { no: 8, name: "one_float", kind: "scalar", T: 2 /* ScalarType.FLOAT */, opt: true, default: 1 },
    { no: 9, name: "small_float", kind: "scalar", T: 2 /* ScalarType.FLOAT */, opt: true, default: 1.5 },
    { no: 10, name: "negative_one_float", kind: "scalar", T: 2 /* ScalarType.FLOAT */, opt: true, default: -1 },
    { no: 11, name: "negative_float", kind: "scalar", T: 2 /* ScalarType.FLOAT */, opt: true, default: -1.5 },
    { no: 12, name: "large_float", kind: "scalar", T: 2 /* ScalarType.FLOAT */, opt: true, default: 200000000 },
    { no: 13, name: "small_negative_float", kind: "scalar", T: 2 /* ScalarType.FLOAT */, opt: true, default: -8e-28 },
    { no: 14, name: "inf_double", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true, default: protoDouble.POSITIVE_INFINITY },
    { no: 15, name: "neg_inf_double", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true, default: protoDouble.NEGATIVE_INFINITY },
    { no: 16, name: "nan_double", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true, default: protoDouble.NaN },
    { no: 17, name: "inf_float", kind: "scalar", T: 2 /* ScalarType.FLOAT */, opt: true, default: protoDouble.POSITIVE_INFINITY },
    { no: 18, name: "neg_inf_float", kind: "scalar", T: 2 /* ScalarType.FLOAT */, opt: true, default: protoDouble.NEGATIVE_INFINITY },
    { no: 19, name: "nan_float", kind: "scalar", T: 2 /* ScalarType.FLOAT */, opt: true, default: protoDouble.NaN },
    { no: 20, name: "cpp_trigraph", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true, default: "? ? ?? ?? ??? ??/ ??-" },
    { no: 23, name: "string_with_zero", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true, default: "hel lo" },
    { no: 24, name: "bytes_with_zero", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true, default: new Uint8Array([0x77, 0x6F, 0x72, 0x00, 0x6C, 0x64]) },
    { no: 25, name: "string_piece_with_zero", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true, default: "ab c" },
    { no: 26, name: "cord_with_zero", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true, default: "12 3" },
    { no: 27, name: "replacement_string", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true, default: "${unknown}" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestExtremeDefaultValues {
    return new TestExtremeDefaultValues().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestExtremeDefaultValues {
    return new TestExtremeDefaultValues().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestExtremeDefaultValues {
    return new TestExtremeDefaultValues().fromJsonString(jsonString, options);
  }

  static equals(a: TestExtremeDefaultValues | PlainMessage<TestExtremeDefaultValues> | undefined, b: TestExtremeDefaultValues | PlainMessage<TestExtremeDefaultValues> | undefined): boolean {
    return proto2.util.equals(TestExtremeDefaultValues, a, b);
  }
}

TestExtremeDefaultValues.prototype.escapedBytes = new Uint8Array([0x00, 0x01, 0x07, 0x08, 0x0C, 0x0A, 0x0D, 0x09, 0x0B, 0x5C, 0xFE]);
TestExtremeDefaultValues.prototype.largeUint32 = 4294967295;
TestExtremeDefaultValues.prototype.largeUint64 = protoInt64.uParse("18446744073709551615");
TestExtremeDefaultValues.prototype.smallInt32 = -2147483647;
TestExtremeDefaultValues.prototype.smallInt64 = protoInt64.parse("-9223372036854775807");
TestExtremeDefaultValues.prototype.reallySmallInt32 = -2147483648;
TestExtremeDefaultValues.prototype.reallySmallInt64 = protoInt64.parse("-9223372036854775808");
TestExtremeDefaultValues.prototype.utf8String = "";
TestExtremeDefaultValues.prototype.zeroFloat = 0;
TestExtremeDefaultValues.prototype.oneFloat = 1;
TestExtremeDefaultValues.prototype.smallFloat = 1.5;
TestExtremeDefaultValues.prototype.negativeOneFloat = -1;
TestExtremeDefaultValues.prototype.negativeFloat = -1.5;
TestExtremeDefaultValues.prototype.largeFloat = 200000000;
TestExtremeDefaultValues.prototype.smallNegativeFloat = -8e-28;
TestExtremeDefaultValues.prototype.infDouble = protoDouble.POSITIVE_INFINITY;
TestExtremeDefaultValues.prototype.negInfDouble = protoDouble.NEGATIVE_INFINITY;
TestExtremeDefaultValues.prototype.nanDouble = protoDouble.NaN;
TestExtremeDefaultValues.prototype.infFloat = protoDouble.POSITIVE_INFINITY;
TestExtremeDefaultValues.prototype.negInfFloat = protoDouble.NEGATIVE_INFINITY;
TestExtremeDefaultValues.prototype.nanFloat = protoDouble.NaN;
TestExtremeDefaultValues.prototype.cppTrigraph = "? ? ?? ?? ??? ??/ ??-";
TestExtremeDefaultValues.prototype.stringWithZero = "hel lo";
TestExtremeDefaultValues.prototype.bytesWithZero = new Uint8Array([0x77, 0x6F, 0x72, 0x00, 0x6C, 0x64]);
TestExtremeDefaultValues.prototype.stringPieceWithZero = "ab c";
TestExtremeDefaultValues.prototype.cordWithZero = "12 3";
TestExtremeDefaultValues.prototype.replacementString = "${unknown}";

/**
 * @generated from message protobuf_unittest.SparseEnumMessage
 */
export class SparseEnumMessage extends Message<SparseEnumMessage> {
  /**
   * @generated from field: optional protobuf_unittest.TestSparseEnum sparse_enum = 1;
   */
  declare sparseEnum: TestSparseEnum;

  constructor(data?: PartialMessage<SparseEnumMessage>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.SparseEnumMessage";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "sparse_enum", kind: "enum", T: proto2.getEnumType(TestSparseEnum), opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SparseEnumMessage {
    return new SparseEnumMessage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SparseEnumMessage {
    return new SparseEnumMessage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SparseEnumMessage {
    return new SparseEnumMessage().fromJsonString(jsonString, options);
  }

  static equals(a: SparseEnumMessage | PlainMessage<SparseEnumMessage> | undefined, b: SparseEnumMessage | PlainMessage<SparseEnumMessage> | undefined): boolean {
    return proto2.util.equals(SparseEnumMessage, a, b);
  }
}

SparseEnumMessage.prototype.sparseEnum = 123 as TestSparseEnum.SPARSE_A;

/**
 * Test String and Bytes: string is for valid UTF-8 strings
 *
 * @generated from message protobuf_unittest.OneString
 */
export class OneString extends Message<OneString> {
  /**
   * @generated from field: optional string data = 1;
   */
  declare data: string;

  constructor(data?: PartialMessage<OneString>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.OneString";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "data", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OneString {
    return new OneString().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OneString {
    return new OneString().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OneString {
    return new OneString().fromJsonString(jsonString, options);
  }

  static equals(a: OneString | PlainMessage<OneString> | undefined, b: OneString | PlainMessage<OneString> | undefined): boolean {
    return proto2.util.equals(OneString, a, b);
  }
}

OneString.prototype.data = "";

/**
 * @generated from message protobuf_unittest.MoreString
 */
export class MoreString extends Message<MoreString> {
  /**
   * @generated from field: repeated string data = 1;
   */
  data: string[] = [];

  constructor(data?: PartialMessage<MoreString>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.MoreString";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "data", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MoreString {
    return new MoreString().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MoreString {
    return new MoreString().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MoreString {
    return new MoreString().fromJsonString(jsonString, options);
  }

  static equals(a: MoreString | PlainMessage<MoreString> | undefined, b: MoreString | PlainMessage<MoreString> | undefined): boolean {
    return proto2.util.equals(MoreString, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.OneBytes
 */
export class OneBytes extends Message<OneBytes> {
  /**
   * @generated from field: optional bytes data = 1;
   */
  declare data: Uint8Array;

  constructor(data?: PartialMessage<OneBytes>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.OneBytes";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "data", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OneBytes {
    return new OneBytes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OneBytes {
    return new OneBytes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OneBytes {
    return new OneBytes().fromJsonString(jsonString, options);
  }

  static equals(a: OneBytes | PlainMessage<OneBytes> | undefined, b: OneBytes | PlainMessage<OneBytes> | undefined): boolean {
    return proto2.util.equals(OneBytes, a, b);
  }
}

OneBytes.prototype.data = new Uint8Array(0);

/**
 * @generated from message protobuf_unittest.MoreBytes
 */
export class MoreBytes extends Message<MoreBytes> {
  /**
   * @generated from field: repeated bytes data = 1;
   */
  data: Uint8Array[] = [];

  constructor(data?: PartialMessage<MoreBytes>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.MoreBytes";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "data", kind: "scalar", T: 12 /* ScalarType.BYTES */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MoreBytes {
    return new MoreBytes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MoreBytes {
    return new MoreBytes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MoreBytes {
    return new MoreBytes().fromJsonString(jsonString, options);
  }

  static equals(a: MoreBytes | PlainMessage<MoreBytes> | undefined, b: MoreBytes | PlainMessage<MoreBytes> | undefined): boolean {
    return proto2.util.equals(MoreBytes, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.ManyOptionalString
 */
export class ManyOptionalString extends Message<ManyOptionalString> {
  /**
   * @generated from field: optional string str1 = 1;
   */
  declare str1: string;

  /**
   * @generated from field: optional string str2 = 2;
   */
  declare str2: string;

  /**
   * @generated from field: optional string str3 = 3;
   */
  declare str3: string;

  /**
   * @generated from field: optional string str4 = 4;
   */
  declare str4: string;

  /**
   * @generated from field: optional string str5 = 5;
   */
  declare str5: string;

  /**
   * @generated from field: optional string str6 = 6;
   */
  declare str6: string;

  /**
   * @generated from field: optional string str7 = 7;
   */
  declare str7: string;

  /**
   * @generated from field: optional string str8 = 8;
   */
  declare str8: string;

  /**
   * @generated from field: optional string str9 = 9;
   */
  declare str9: string;

  /**
   * @generated from field: optional string str10 = 10;
   */
  declare str10: string;

  /**
   * @generated from field: optional string str11 = 11;
   */
  declare str11: string;

  /**
   * @generated from field: optional string str12 = 12;
   */
  declare str12: string;

  /**
   * @generated from field: optional string str13 = 13;
   */
  declare str13: string;

  /**
   * @generated from field: optional string str14 = 14;
   */
  declare str14: string;

  /**
   * @generated from field: optional string str15 = 15;
   */
  declare str15: string;

  /**
   * @generated from field: optional string str16 = 16;
   */
  declare str16: string;

  /**
   * @generated from field: optional string str17 = 17;
   */
  declare str17: string;

  /**
   * @generated from field: optional string str18 = 18;
   */
  declare str18: string;

  /**
   * @generated from field: optional string str19 = 19;
   */
  declare str19: string;

  /**
   * @generated from field: optional string str20 = 20;
   */
  declare str20: string;

  /**
   * @generated from field: optional string str21 = 21;
   */
  declare str21: string;

  /**
   * @generated from field: optional string str22 = 22;
   */
  declare str22: string;

  /**
   * @generated from field: optional string str23 = 23;
   */
  declare str23: string;

  /**
   * @generated from field: optional string str24 = 24;
   */
  declare str24: string;

  /**
   * @generated from field: optional string str25 = 25;
   */
  declare str25: string;

  /**
   * @generated from field: optional string str26 = 26;
   */
  declare str26: string;

  /**
   * @generated from field: optional string str27 = 27;
   */
  declare str27: string;

  /**
   * @generated from field: optional string str28 = 28;
   */
  declare str28: string;

  /**
   * @generated from field: optional string str29 = 29;
   */
  declare str29: string;

  /**
   * @generated from field: optional string str30 = 30;
   */
  declare str30: string;

  /**
   * @generated from field: optional string str31 = 31;
   */
  declare str31: string;

  /**
   * @generated from field: optional string str32 = 32;
   */
  declare str32: string;

  constructor(data?: PartialMessage<ManyOptionalString>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.ManyOptionalString";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "str1", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "str2", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "str3", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "str4", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "str5", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "str6", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 7, name: "str7", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 8, name: "str8", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 9, name: "str9", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 10, name: "str10", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 11, name: "str11", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 12, name: "str12", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 13, name: "str13", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 14, name: "str14", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 15, name: "str15", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 16, name: "str16", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 17, name: "str17", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 18, name: "str18", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 19, name: "str19", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 20, name: "str20", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 21, name: "str21", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 22, name: "str22", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 23, name: "str23", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 24, name: "str24", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 25, name: "str25", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 26, name: "str26", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 27, name: "str27", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 28, name: "str28", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 29, name: "str29", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 30, name: "str30", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 31, name: "str31", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 32, name: "str32", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ManyOptionalString {
    return new ManyOptionalString().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ManyOptionalString {
    return new ManyOptionalString().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ManyOptionalString {
    return new ManyOptionalString().fromJsonString(jsonString, options);
  }

  static equals(a: ManyOptionalString | PlainMessage<ManyOptionalString> | undefined, b: ManyOptionalString | PlainMessage<ManyOptionalString> | undefined): boolean {
    return proto2.util.equals(ManyOptionalString, a, b);
  }
}

ManyOptionalString.prototype.str1 = "";
ManyOptionalString.prototype.str2 = "";
ManyOptionalString.prototype.str3 = "";
ManyOptionalString.prototype.str4 = "";
ManyOptionalString.prototype.str5 = "";
ManyOptionalString.prototype.str6 = "";
ManyOptionalString.prototype.str7 = "";
ManyOptionalString.prototype.str8 = "";
ManyOptionalString.prototype.str9 = "";
ManyOptionalString.prototype.str10 = "";
ManyOptionalString.prototype.str11 = "";
ManyOptionalString.prototype.str12 = "";
ManyOptionalString.prototype.str13 = "";
ManyOptionalString.prototype.str14 = "";
ManyOptionalString.prototype.str15 = "";
ManyOptionalString.prototype.str16 = "";
ManyOptionalString.prototype.str17 = "";
ManyOptionalString.prototype.str18 = "";
ManyOptionalString.prototype.str19 = "";
ManyOptionalString.prototype.str20 = "";
ManyOptionalString.prototype.str21 = "";
ManyOptionalString.prototype.str22 = "";
ManyOptionalString.prototype.str23 = "";
ManyOptionalString.prototype.str24 = "";
ManyOptionalString.prototype.str25 = "";
ManyOptionalString.prototype.str26 = "";
ManyOptionalString.prototype.str27 = "";
ManyOptionalString.prototype.str28 = "";
ManyOptionalString.prototype.str29 = "";
ManyOptionalString.prototype.str30 = "";
ManyOptionalString.prototype.str31 = "";
ManyOptionalString.prototype.str32 = "";

/**
 * Test int32, uint32, int64, uint64, and bool are all compatible
 *
 * @generated from message protobuf_unittest.Int32Message
 */
export class Int32Message extends Message<Int32Message> {
  /**
   * @generated from field: optional int32 data = 1;
   */
  declare data: number;

  constructor(data?: PartialMessage<Int32Message>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.Int32Message";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "data", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Int32Message {
    return new Int32Message().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Int32Message {
    return new Int32Message().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Int32Message {
    return new Int32Message().fromJsonString(jsonString, options);
  }

  static equals(a: Int32Message | PlainMessage<Int32Message> | undefined, b: Int32Message | PlainMessage<Int32Message> | undefined): boolean {
    return proto2.util.equals(Int32Message, a, b);
  }
}

Int32Message.prototype.data = 0;

/**
 * @generated from message protobuf_unittest.Uint32Message
 */
export class Uint32Message extends Message<Uint32Message> {
  /**
   * @generated from field: optional uint32 data = 1;
   */
  declare data: number;

  constructor(data?: PartialMessage<Uint32Message>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.Uint32Message";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "data", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Uint32Message {
    return new Uint32Message().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Uint32Message {
    return new Uint32Message().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Uint32Message {
    return new Uint32Message().fromJsonString(jsonString, options);
  }

  static equals(a: Uint32Message | PlainMessage<Uint32Message> | undefined, b: Uint32Message | PlainMessage<Uint32Message> | undefined): boolean {
    return proto2.util.equals(Uint32Message, a, b);
  }
}

Uint32Message.prototype.data = 0;

/**
 * @generated from message protobuf_unittest.Int64Message
 */
export class Int64Message extends Message<Int64Message> {
  /**
   * @generated from field: optional int64 data = 1;
   */
  declare data: bigint;

  constructor(data?: PartialMessage<Int64Message>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.Int64Message";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "data", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Int64Message {
    return new Int64Message().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Int64Message {
    return new Int64Message().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Int64Message {
    return new Int64Message().fromJsonString(jsonString, options);
  }

  static equals(a: Int64Message | PlainMessage<Int64Message> | undefined, b: Int64Message | PlainMessage<Int64Message> | undefined): boolean {
    return proto2.util.equals(Int64Message, a, b);
  }
}

Int64Message.prototype.data = protoInt64.zero;

/**
 * @generated from message protobuf_unittest.Uint64Message
 */
export class Uint64Message extends Message<Uint64Message> {
  /**
   * @generated from field: optional uint64 data = 1;
   */
  declare data: bigint;

  constructor(data?: PartialMessage<Uint64Message>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.Uint64Message";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "data", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Uint64Message {
    return new Uint64Message().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Uint64Message {
    return new Uint64Message().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Uint64Message {
    return new Uint64Message().fromJsonString(jsonString, options);
  }

  static equals(a: Uint64Message | PlainMessage<Uint64Message> | undefined, b: Uint64Message | PlainMessage<Uint64Message> | undefined): boolean {
    return proto2.util.equals(Uint64Message, a, b);
  }
}

Uint64Message.prototype.data = protoInt64.zero;

/**
 * @generated from message protobuf_unittest.BoolMessage
 */
export class BoolMessage extends Message<BoolMessage> {
  /**
   * @generated from field: optional bool data = 1;
   */
  declare data: boolean;

  constructor(data?: PartialMessage<BoolMessage>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.BoolMessage";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "data", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BoolMessage {
    return new BoolMessage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BoolMessage {
    return new BoolMessage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BoolMessage {
    return new BoolMessage().fromJsonString(jsonString, options);
  }

  static equals(a: BoolMessage | PlainMessage<BoolMessage> | undefined, b: BoolMessage | PlainMessage<BoolMessage> | undefined): boolean {
    return proto2.util.equals(BoolMessage, a, b);
  }
}

BoolMessage.prototype.data = false;

/**
 * Test oneofs.
 *
 * @generated from message protobuf_unittest.TestOneof
 */
export class TestOneof extends Message<TestOneof> {
  /**
   * @generated from oneof protobuf_unittest.TestOneof.foo
   */
  foo: {
    /**
     * @generated from field: int32 foo_int = 1;
     */
    value: number;
    case: "fooInt";
  } | {
    /**
     * @generated from field: string foo_string = 2;
     */
    value: string;
    case: "fooString";
  } | {
    /**
     * @generated from field: protobuf_unittest.TestAllTypes foo_message = 3;
     */
    value: TestAllTypes;
    case: "fooMessage";
  } | {
    /**
     * @generated from field: protobuf_unittest.TestOneof.FooGroup foogroup = 4;
     */
    value: TestOneof_FooGroup;
    case: "foogroup";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<TestOneof>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestOneof";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "foo_int", kind: "scalar", T: 5 /* ScalarType.INT32 */, oneof: "foo" },
    { no: 2, name: "foo_string", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "foo" },
    { no: 3, name: "foo_message", kind: "message", T: TestAllTypes, oneof: "foo" },
    { no: 4, name: "foogroup", kind: "message", T: TestOneof_FooGroup, delimited: true, oneof: "foo" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestOneof {
    return new TestOneof().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestOneof {
    return new TestOneof().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestOneof {
    return new TestOneof().fromJsonString(jsonString, options);
  }

  static equals(a: TestOneof | PlainMessage<TestOneof> | undefined, b: TestOneof | PlainMessage<TestOneof> | undefined): boolean {
    return proto2.util.equals(TestOneof, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.TestOneof.FooGroup
 */
export class TestOneof_FooGroup extends Message<TestOneof_FooGroup> {
  /**
   * @generated from field: optional int32 a = 5;
   */
  declare a: number;

  /**
   * @generated from field: optional string b = 6;
   */
  declare b: string;

  constructor(data?: PartialMessage<TestOneof_FooGroup>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestOneof.FooGroup";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 5, name: "a", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 6, name: "b", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestOneof_FooGroup {
    return new TestOneof_FooGroup().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestOneof_FooGroup {
    return new TestOneof_FooGroup().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestOneof_FooGroup {
    return new TestOneof_FooGroup().fromJsonString(jsonString, options);
  }

  static equals(a: TestOneof_FooGroup | PlainMessage<TestOneof_FooGroup> | undefined, b: TestOneof_FooGroup | PlainMessage<TestOneof_FooGroup> | undefined): boolean {
    return proto2.util.equals(TestOneof_FooGroup, a, b);
  }
}

TestOneof_FooGroup.prototype.a = 0;
TestOneof_FooGroup.prototype.b = "";

/**
 * @generated from message protobuf_unittest.TestOneofBackwardsCompatible
 */
export class TestOneofBackwardsCompatible extends Message<TestOneofBackwardsCompatible> {
  /**
   * @generated from field: optional int32 foo_int = 1;
   */
  declare fooInt: number;

  /**
   * @generated from field: optional string foo_string = 2;
   */
  declare fooString: string;

  /**
   * @generated from field: optional protobuf_unittest.TestAllTypes foo_message = 3;
   */
  fooMessage?: TestAllTypes;

  /**
   * @generated from field: optional protobuf_unittest.TestOneofBackwardsCompatible.FooGroup foogroup = 4;
   */
  foogroup?: TestOneofBackwardsCompatible_FooGroup;

  constructor(data?: PartialMessage<TestOneofBackwardsCompatible>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestOneofBackwardsCompatible";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "foo_int", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 2, name: "foo_string", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "foo_message", kind: "message", T: TestAllTypes, opt: true },
    { no: 4, name: "foogroup", kind: "message", T: TestOneofBackwardsCompatible_FooGroup, delimited: true, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestOneofBackwardsCompatible {
    return new TestOneofBackwardsCompatible().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestOneofBackwardsCompatible {
    return new TestOneofBackwardsCompatible().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestOneofBackwardsCompatible {
    return new TestOneofBackwardsCompatible().fromJsonString(jsonString, options);
  }

  static equals(a: TestOneofBackwardsCompatible | PlainMessage<TestOneofBackwardsCompatible> | undefined, b: TestOneofBackwardsCompatible | PlainMessage<TestOneofBackwardsCompatible> | undefined): boolean {
    return proto2.util.equals(TestOneofBackwardsCompatible, a, b);
  }
}

TestOneofBackwardsCompatible.prototype.fooInt = 0;
TestOneofBackwardsCompatible.prototype.fooString = "";

/**
 * @generated from message protobuf_unittest.TestOneofBackwardsCompatible.FooGroup
 */
export class TestOneofBackwardsCompatible_FooGroup extends Message<TestOneofBackwardsCompatible_FooGroup> {
  /**
   * @generated from field: optional int32 a = 5;
   */
  declare a: number;

  /**
   * @generated from field: optional string b = 6;
   */
  declare b: string;

  constructor(data?: PartialMessage<TestOneofBackwardsCompatible_FooGroup>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestOneofBackwardsCompatible.FooGroup";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 5, name: "a", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 6, name: "b", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestOneofBackwardsCompatible_FooGroup {
    return new TestOneofBackwardsCompatible_FooGroup().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestOneofBackwardsCompatible_FooGroup {
    return new TestOneofBackwardsCompatible_FooGroup().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestOneofBackwardsCompatible_FooGroup {
    return new TestOneofBackwardsCompatible_FooGroup().fromJsonString(jsonString, options);
  }

  static equals(a: TestOneofBackwardsCompatible_FooGroup | PlainMessage<TestOneofBackwardsCompatible_FooGroup> | undefined, b: TestOneofBackwardsCompatible_FooGroup | PlainMessage<TestOneofBackwardsCompatible_FooGroup> | undefined): boolean {
    return proto2.util.equals(TestOneofBackwardsCompatible_FooGroup, a, b);
  }
}

TestOneofBackwardsCompatible_FooGroup.prototype.a = 0;
TestOneofBackwardsCompatible_FooGroup.prototype.b = "";

/**
 * @generated from message protobuf_unittest.TestOneof2
 */
export class TestOneof2 extends Message<TestOneof2> {
  /**
   * @generated from oneof protobuf_unittest.TestOneof2.foo
   */
  foo: {
    /**
     * @generated from field: int32 foo_int = 1;
     */
    value: number;
    case: "fooInt";
  } | {
    /**
     * @generated from field: string foo_string = 2;
     */
    value: string;
    case: "fooString";
  } | {
    /**
     * @generated from field: string foo_cord = 3;
     */
    value: string;
    case: "fooCord";
  } | {
    /**
     * @generated from field: string foo_string_piece = 4;
     */
    value: string;
    case: "fooStringPiece";
  } | {
    /**
     * @generated from field: bytes foo_bytes = 5;
     */
    value: Uint8Array;
    case: "fooBytes";
  } | {
    /**
     * @generated from field: protobuf_unittest.TestOneof2.NestedEnum foo_enum = 6;
     */
    value: TestOneof2_NestedEnum;
    case: "fooEnum";
  } | {
    /**
     * @generated from field: protobuf_unittest.TestOneof2.NestedMessage foo_message = 7;
     */
    value: TestOneof2_NestedMessage;
    case: "fooMessage";
  } | {
    /**
     * @generated from field: protobuf_unittest.TestOneof2.FooGroup foogroup = 8;
     */
    value: TestOneof2_FooGroup;
    case: "foogroup";
  } | {
    /**
     * @generated from field: protobuf_unittest.TestOneof2.NestedMessage foo_lazy_message = 11;
     */
    value: TestOneof2_NestedMessage;
    case: "fooLazyMessage";
  } | {
    /**
     * @generated from field: bytes foo_bytes_cord = 30;
     */
    value: Uint8Array;
    case: "fooBytesCord";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * @generated from oneof protobuf_unittest.TestOneof2.bar
   */
  bar: {
    /**
     * @generated from field: int32 bar_int = 12 [default = 5];
     */
    value: number;
    case: "barInt";
  } | {
    /**
     * @generated from field: string bar_string = 13 [default = "STRING"];
     */
    value: string;
    case: "barString";
  } | {
    /**
     * @generated from field: string bar_cord = 14 [default = "CORD"];
     */
    value: string;
    case: "barCord";
  } | {
    /**
     * @generated from field: string bar_string_piece = 15 [default = "SPIECE"];
     */
    value: string;
    case: "barStringPiece";
  } | {
    /**
     * @generated from field: bytes bar_bytes = 16 [default = "BYTES"];
     */
    value: Uint8Array;
    case: "barBytes";
  } | {
    /**
     * @generated from field: protobuf_unittest.TestOneof2.NestedEnum bar_enum = 17 [default = BAR];
     */
    value: TestOneof2_NestedEnum;
    case: "barEnum";
  } | {
    /**
     * @generated from field: string bar_string_with_empty_default = 20 [default = ""];
     */
    value: string;
    case: "barStringWithEmptyDefault";
  } | {
    /**
     * @generated from field: string bar_cord_with_empty_default = 21 [default = ""];
     */
    value: string;
    case: "barCordWithEmptyDefault";
  } | {
    /**
     * @generated from field: string bar_string_piece_with_empty_default = 22 [default = ""];
     */
    value: string;
    case: "barStringPieceWithEmptyDefault";
  } | {
    /**
     * @generated from field: bytes bar_bytes_with_empty_default = 23 [default = ""];
     */
    value: Uint8Array;
    case: "barBytesWithEmptyDefault";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * @generated from field: optional int32 baz_int = 18;
   */
  declare bazInt: number;

  /**
   * @generated from field: optional string baz_string = 19 [default = "BAZ"];
   */
  declare bazString: string;

  constructor(data?: PartialMessage<TestOneof2>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestOneof2";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "foo_int", kind: "scalar", T: 5 /* ScalarType.INT32 */, oneof: "foo" },
    { no: 2, name: "foo_string", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "foo" },
    { no: 3, name: "foo_cord", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "foo" },
    { no: 4, name: "foo_string_piece", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "foo" },
    { no: 5, name: "foo_bytes", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "foo" },
    { no: 6, name: "foo_enum", kind: "enum", T: proto2.getEnumType(TestOneof2_NestedEnum), oneof: "foo" },
    { no: 7, name: "foo_message", kind: "message", T: TestOneof2_NestedMessage, oneof: "foo" },
    { no: 8, name: "foogroup", kind: "message", T: TestOneof2_FooGroup, delimited: true, oneof: "foo" },
    { no: 11, name: "foo_lazy_message", kind: "message", T: TestOneof2_NestedMessage, oneof: "foo" },
    { no: 30, name: "foo_bytes_cord", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "foo" },
    { no: 12, name: "bar_int", kind: "scalar", T: 5 /* ScalarType.INT32 */, default: 5, oneof: "bar" },
    { no: 13, name: "bar_string", kind: "scalar", T: 9 /* ScalarType.STRING */, default: "STRING", oneof: "bar" },
    { no: 14, name: "bar_cord", kind: "scalar", T: 9 /* ScalarType.STRING */, default: "CORD", oneof: "bar" },
    { no: 15, name: "bar_string_piece", kind: "scalar", T: 9 /* ScalarType.STRING */, default: "SPIECE", oneof: "bar" },
    { no: 16, name: "bar_bytes", kind: "scalar", T: 12 /* ScalarType.BYTES */, default: new Uint8Array([0x42, 0x59, 0x54, 0x45, 0x53]), oneof: "bar" },
    { no: 17, name: "bar_enum", kind: "enum", T: proto2.getEnumType(TestOneof2_NestedEnum), default: TestOneof2_NestedEnum.BAR, oneof: "bar" },
    { no: 20, name: "bar_string_with_empty_default", kind: "scalar", T: 9 /* ScalarType.STRING */, default: "", oneof: "bar" },
    { no: 21, name: "bar_cord_with_empty_default", kind: "scalar", T: 9 /* ScalarType.STRING */, default: "", oneof: "bar" },
    { no: 22, name: "bar_string_piece_with_empty_default", kind: "scalar", T: 9 /* ScalarType.STRING */, default: "", oneof: "bar" },
    { no: 23, name: "bar_bytes_with_empty_default", kind: "scalar", T: 12 /* ScalarType.BYTES */, default: new Uint8Array(0), oneof: "bar" },
    { no: 18, name: "baz_int", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 19, name: "baz_string", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true, default: "BAZ" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestOneof2 {
    return new TestOneof2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestOneof2 {
    return new TestOneof2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestOneof2 {
    return new TestOneof2().fromJsonString(jsonString, options);
  }

  static equals(a: TestOneof2 | PlainMessage<TestOneof2> | undefined, b: TestOneof2 | PlainMessage<TestOneof2> | undefined): boolean {
    return proto2.util.equals(TestOneof2, a, b);
  }
}

TestOneof2.prototype.bazInt = 0;
TestOneof2.prototype.bazString = "BAZ";

/**
 * @generated from enum protobuf_unittest.TestOneof2.NestedEnum
 */
export enum TestOneof2_NestedEnum {
  /**
   * @generated from enum value: FOO = 1;
   */
  FOO = 1,

  /**
   * @generated from enum value: BAR = 2;
   */
  BAR = 2,

  /**
   * @generated from enum value: BAZ = 3;
   */
  BAZ = 3,
}
// Retrieve enum metadata with: proto2.getEnumType(TestOneof2_NestedEnum)
proto2.util.setEnumType(TestOneof2_NestedEnum, "protobuf_unittest.TestOneof2.NestedEnum", [
  { no: 1, name: "FOO" },
  { no: 2, name: "BAR" },
  { no: 3, name: "BAZ" },
]);

/**
 * @generated from message protobuf_unittest.TestOneof2.FooGroup
 */
export class TestOneof2_FooGroup extends Message<TestOneof2_FooGroup> {
  /**
   * @generated from field: optional int32 a = 9;
   */
  declare a: number;

  /**
   * @generated from field: optional string b = 10;
   */
  declare b: string;

  constructor(data?: PartialMessage<TestOneof2_FooGroup>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestOneof2.FooGroup";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 9, name: "a", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 10, name: "b", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestOneof2_FooGroup {
    return new TestOneof2_FooGroup().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestOneof2_FooGroup {
    return new TestOneof2_FooGroup().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestOneof2_FooGroup {
    return new TestOneof2_FooGroup().fromJsonString(jsonString, options);
  }

  static equals(a: TestOneof2_FooGroup | PlainMessage<TestOneof2_FooGroup> | undefined, b: TestOneof2_FooGroup | PlainMessage<TestOneof2_FooGroup> | undefined): boolean {
    return proto2.util.equals(TestOneof2_FooGroup, a, b);
  }
}

TestOneof2_FooGroup.prototype.a = 0;
TestOneof2_FooGroup.prototype.b = "";

/**
 * @generated from message protobuf_unittest.TestOneof2.NestedMessage
 */
export class TestOneof2_NestedMessage extends Message<TestOneof2_NestedMessage> {
  /**
   * @generated from field: optional int64 moo_int = 1;
   */
  declare mooInt: bigint;

  /**
   * @generated from field: repeated int32 corge_int = 2;
   */
  corgeInt: number[] = [];

  constructor(data?: PartialMessage<TestOneof2_NestedMessage>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestOneof2.NestedMessage";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "moo_int", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 2, name: "corge_int", kind: "scalar", T: 5 /* ScalarType.INT32 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestOneof2_NestedMessage {
    return new TestOneof2_NestedMessage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestOneof2_NestedMessage {
    return new TestOneof2_NestedMessage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestOneof2_NestedMessage {
    return new TestOneof2_NestedMessage().fromJsonString(jsonString, options);
  }

  static equals(a: TestOneof2_NestedMessage | PlainMessage<TestOneof2_NestedMessage> | undefined, b: TestOneof2_NestedMessage | PlainMessage<TestOneof2_NestedMessage> | undefined): boolean {
    return proto2.util.equals(TestOneof2_NestedMessage, a, b);
  }
}

TestOneof2_NestedMessage.prototype.mooInt = protoInt64.zero;

/**
 * @generated from message protobuf_unittest.TestRequiredOneof
 */
export class TestRequiredOneof extends Message<TestRequiredOneof> {
  /**
   * @generated from oneof protobuf_unittest.TestRequiredOneof.foo
   */
  foo: {
    /**
     * @generated from field: int32 foo_int = 1;
     */
    value: number;
    case: "fooInt";
  } | {
    /**
     * @generated from field: string foo_string = 2;
     */
    value: string;
    case: "fooString";
  } | {
    /**
     * @generated from field: protobuf_unittest.TestRequiredOneof.NestedMessage foo_message = 3;
     */
    value: TestRequiredOneof_NestedMessage;
    case: "fooMessage";
  } | {
    /**
     * @generated from field: protobuf_unittest.TestRequiredOneof.NestedMessage foo_lazy_message = 4;
     */
    value: TestRequiredOneof_NestedMessage;
    case: "fooLazyMessage";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<TestRequiredOneof>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestRequiredOneof";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "foo_int", kind: "scalar", T: 5 /* ScalarType.INT32 */, oneof: "foo" },
    { no: 2, name: "foo_string", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "foo" },
    { no: 3, name: "foo_message", kind: "message", T: TestRequiredOneof_NestedMessage, oneof: "foo" },
    { no: 4, name: "foo_lazy_message", kind: "message", T: TestRequiredOneof_NestedMessage, oneof: "foo" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestRequiredOneof {
    return new TestRequiredOneof().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestRequiredOneof {
    return new TestRequiredOneof().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestRequiredOneof {
    return new TestRequiredOneof().fromJsonString(jsonString, options);
  }

  static equals(a: TestRequiredOneof | PlainMessage<TestRequiredOneof> | undefined, b: TestRequiredOneof | PlainMessage<TestRequiredOneof> | undefined): boolean {
    return proto2.util.equals(TestRequiredOneof, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.TestRequiredOneof.NestedMessage
 */
export class TestRequiredOneof_NestedMessage extends Message<TestRequiredOneof_NestedMessage> {
  /**
   * @generated from field: required double required_double = 1;
   */
  declare requiredDouble: number;

  constructor(data?: PartialMessage<TestRequiredOneof_NestedMessage>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestRequiredOneof.NestedMessage";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "required_double", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, req: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestRequiredOneof_NestedMessage {
    return new TestRequiredOneof_NestedMessage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestRequiredOneof_NestedMessage {
    return new TestRequiredOneof_NestedMessage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestRequiredOneof_NestedMessage {
    return new TestRequiredOneof_NestedMessage().fromJsonString(jsonString, options);
  }

  static equals(a: TestRequiredOneof_NestedMessage | PlainMessage<TestRequiredOneof_NestedMessage> | undefined, b: TestRequiredOneof_NestedMessage | PlainMessage<TestRequiredOneof_NestedMessage> | undefined): boolean {
    return proto2.util.equals(TestRequiredOneof_NestedMessage, a, b);
  }
}

TestRequiredOneof_NestedMessage.prototype.requiredDouble = 0;

/**
 * @generated from message protobuf_unittest.TestPackedTypes
 */
export class TestPackedTypes extends Message<TestPackedTypes> {
  /**
   * @generated from field: repeated int32 packed_int32 = 90 [packed = true];
   */
  packedInt32: number[] = [];

  /**
   * @generated from field: repeated int64 packed_int64 = 91 [packed = true];
   */
  packedInt64: bigint[] = [];

  /**
   * @generated from field: repeated uint32 packed_uint32 = 92 [packed = true];
   */
  packedUint32: number[] = [];

  /**
   * @generated from field: repeated uint64 packed_uint64 = 93 [packed = true];
   */
  packedUint64: bigint[] = [];

  /**
   * @generated from field: repeated sint32 packed_sint32 = 94 [packed = true];
   */
  packedSint32: number[] = [];

  /**
   * @generated from field: repeated sint64 packed_sint64 = 95 [packed = true];
   */
  packedSint64: bigint[] = [];

  /**
   * @generated from field: repeated fixed32 packed_fixed32 = 96 [packed = true];
   */
  packedFixed32: number[] = [];

  /**
   * @generated from field: repeated fixed64 packed_fixed64 = 97 [packed = true];
   */
  packedFixed64: bigint[] = [];

  /**
   * @generated from field: repeated sfixed32 packed_sfixed32 = 98 [packed = true];
   */
  packedSfixed32: number[] = [];

  /**
   * @generated from field: repeated sfixed64 packed_sfixed64 = 99 [packed = true];
   */
  packedSfixed64: bigint[] = [];

  /**
   * @generated from field: repeated float packed_float = 100 [packed = true];
   */
  packedFloat: number[] = [];

  /**
   * @generated from field: repeated double packed_double = 101 [packed = true];
   */
  packedDouble: number[] = [];

  /**
   * @generated from field: repeated bool packed_bool = 102 [packed = true];
   */
  packedBool: boolean[] = [];

  /**
   * @generated from field: repeated protobuf_unittest.ForeignEnum packed_enum = 103 [packed = true];
   */
  packedEnum: ForeignEnum[] = [];

  constructor(data?: PartialMessage<TestPackedTypes>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestPackedTypes";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 90, name: "packed_int32", kind: "scalar", T: 5 /* ScalarType.INT32 */, repeated: true, packed: true },
    { no: 91, name: "packed_int64", kind: "scalar", T: 3 /* ScalarType.INT64 */, repeated: true, packed: true },
    { no: 92, name: "packed_uint32", kind: "scalar", T: 13 /* ScalarType.UINT32 */, repeated: true, packed: true },
    { no: 93, name: "packed_uint64", kind: "scalar", T: 4 /* ScalarType.UINT64 */, repeated: true, packed: true },
    { no: 94, name: "packed_sint32", kind: "scalar", T: 17 /* ScalarType.SINT32 */, repeated: true, packed: true },
    { no: 95, name: "packed_sint64", kind: "scalar", T: 18 /* ScalarType.SINT64 */, repeated: true, packed: true },
    { no: 96, name: "packed_fixed32", kind: "scalar", T: 7 /* ScalarType.FIXED32 */, repeated: true, packed: true },
    { no: 97, name: "packed_fixed64", kind: "scalar", T: 6 /* ScalarType.FIXED64 */, repeated: true, packed: true },
    { no: 98, name: "packed_sfixed32", kind: "scalar", T: 15 /* ScalarType.SFIXED32 */, repeated: true, packed: true },
    { no: 99, name: "packed_sfixed64", kind: "scalar", T: 16 /* ScalarType.SFIXED64 */, repeated: true, packed: true },
    { no: 100, name: "packed_float", kind: "scalar", T: 2 /* ScalarType.FLOAT */, repeated: true, packed: true },
    { no: 101, name: "packed_double", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, repeated: true, packed: true },
    { no: 102, name: "packed_bool", kind: "scalar", T: 8 /* ScalarType.BOOL */, repeated: true, packed: true },
    { no: 103, name: "packed_enum", kind: "enum", T: proto2.getEnumType(ForeignEnum), repeated: true, packed: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestPackedTypes {
    return new TestPackedTypes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestPackedTypes {
    return new TestPackedTypes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestPackedTypes {
    return new TestPackedTypes().fromJsonString(jsonString, options);
  }

  static equals(a: TestPackedTypes | PlainMessage<TestPackedTypes> | undefined, b: TestPackedTypes | PlainMessage<TestPackedTypes> | undefined): boolean {
    return proto2.util.equals(TestPackedTypes, a, b);
  }
}

/**
 * A message with the same fields as TestPackedTypes, but without packing. Used
 * to test packed <-> unpacked wire compatibility.
 *
 * @generated from message protobuf_unittest.TestUnpackedTypes
 */
export class TestUnpackedTypes extends Message<TestUnpackedTypes> {
  /**
   * @generated from field: repeated int32 unpacked_int32 = 90 [packed = false];
   */
  unpackedInt32: number[] = [];

  /**
   * @generated from field: repeated int64 unpacked_int64 = 91 [packed = false];
   */
  unpackedInt64: bigint[] = [];

  /**
   * @generated from field: repeated uint32 unpacked_uint32 = 92 [packed = false];
   */
  unpackedUint32: number[] = [];

  /**
   * @generated from field: repeated uint64 unpacked_uint64 = 93 [packed = false];
   */
  unpackedUint64: bigint[] = [];

  /**
   * @generated from field: repeated sint32 unpacked_sint32 = 94 [packed = false];
   */
  unpackedSint32: number[] = [];

  /**
   * @generated from field: repeated sint64 unpacked_sint64 = 95 [packed = false];
   */
  unpackedSint64: bigint[] = [];

  /**
   * @generated from field: repeated fixed32 unpacked_fixed32 = 96 [packed = false];
   */
  unpackedFixed32: number[] = [];

  /**
   * @generated from field: repeated fixed64 unpacked_fixed64 = 97 [packed = false];
   */
  unpackedFixed64: bigint[] = [];

  /**
   * @generated from field: repeated sfixed32 unpacked_sfixed32 = 98 [packed = false];
   */
  unpackedSfixed32: number[] = [];

  /**
   * @generated from field: repeated sfixed64 unpacked_sfixed64 = 99 [packed = false];
   */
  unpackedSfixed64: bigint[] = [];

  /**
   * @generated from field: repeated float unpacked_float = 100 [packed = false];
   */
  unpackedFloat: number[] = [];

  /**
   * @generated from field: repeated double unpacked_double = 101 [packed = false];
   */
  unpackedDouble: number[] = [];

  /**
   * @generated from field: repeated bool unpacked_bool = 102 [packed = false];
   */
  unpackedBool: boolean[] = [];

  /**
   * @generated from field: repeated protobuf_unittest.ForeignEnum unpacked_enum = 103 [packed = false];
   */
  unpackedEnum: ForeignEnum[] = [];

  constructor(data?: PartialMessage<TestUnpackedTypes>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestUnpackedTypes";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 90, name: "unpacked_int32", kind: "scalar", T: 5 /* ScalarType.INT32 */, repeated: true },
    { no: 91, name: "unpacked_int64", kind: "scalar", T: 3 /* ScalarType.INT64 */, repeated: true },
    { no: 92, name: "unpacked_uint32", kind: "scalar", T: 13 /* ScalarType.UINT32 */, repeated: true },
    { no: 93, name: "unpacked_uint64", kind: "scalar", T: 4 /* ScalarType.UINT64 */, repeated: true },
    { no: 94, name: "unpacked_sint32", kind: "scalar", T: 17 /* ScalarType.SINT32 */, repeated: true },
    { no: 95, name: "unpacked_sint64", kind: "scalar", T: 18 /* ScalarType.SINT64 */, repeated: true },
    { no: 96, name: "unpacked_fixed32", kind: "scalar", T: 7 /* ScalarType.FIXED32 */, repeated: true },
    { no: 97, name: "unpacked_fixed64", kind: "scalar", T: 6 /* ScalarType.FIXED64 */, repeated: true },
    { no: 98, name: "unpacked_sfixed32", kind: "scalar", T: 15 /* ScalarType.SFIXED32 */, repeated: true },
    { no: 99, name: "unpacked_sfixed64", kind: "scalar", T: 16 /* ScalarType.SFIXED64 */, repeated: true },
    { no: 100, name: "unpacked_float", kind: "scalar", T: 2 /* ScalarType.FLOAT */, repeated: true },
    { no: 101, name: "unpacked_double", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, repeated: true },
    { no: 102, name: "unpacked_bool", kind: "scalar", T: 8 /* ScalarType.BOOL */, repeated: true },
    { no: 103, name: "unpacked_enum", kind: "enum", T: proto2.getEnumType(ForeignEnum), repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestUnpackedTypes {
    return new TestUnpackedTypes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestUnpackedTypes {
    return new TestUnpackedTypes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestUnpackedTypes {
    return new TestUnpackedTypes().fromJsonString(jsonString, options);
  }

  static equals(a: TestUnpackedTypes | PlainMessage<TestUnpackedTypes> | undefined, b: TestUnpackedTypes | PlainMessage<TestUnpackedTypes> | undefined): boolean {
    return proto2.util.equals(TestUnpackedTypes, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.TestPackedExtensions
 */
export class TestPackedExtensions extends Message<TestPackedExtensions> {
  constructor(data?: PartialMessage<TestPackedExtensions>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestPackedExtensions";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestPackedExtensions {
    return new TestPackedExtensions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestPackedExtensions {
    return new TestPackedExtensions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestPackedExtensions {
    return new TestPackedExtensions().fromJsonString(jsonString, options);
  }

  static equals(a: TestPackedExtensions | PlainMessage<TestPackedExtensions> | undefined, b: TestPackedExtensions | PlainMessage<TestPackedExtensions> | undefined): boolean {
    return proto2.util.equals(TestPackedExtensions, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.TestUnpackedExtensions
 */
export class TestUnpackedExtensions extends Message<TestUnpackedExtensions> {
  constructor(data?: PartialMessage<TestUnpackedExtensions>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestUnpackedExtensions";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestUnpackedExtensions {
    return new TestUnpackedExtensions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestUnpackedExtensions {
    return new TestUnpackedExtensions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestUnpackedExtensions {
    return new TestUnpackedExtensions().fromJsonString(jsonString, options);
  }

  static equals(a: TestUnpackedExtensions | PlainMessage<TestUnpackedExtensions> | undefined, b: TestUnpackedExtensions | PlainMessage<TestUnpackedExtensions> | undefined): boolean {
    return proto2.util.equals(TestUnpackedExtensions, a, b);
  }
}

/**
 * Used by ExtensionSetTest/DynamicExtensions.  The test actually builds
 * a set of extensions to TestAllExtensions dynamically, based on the fields
 * of this message type.
 *
 * @generated from message protobuf_unittest.TestDynamicExtensions
 */
export class TestDynamicExtensions extends Message<TestDynamicExtensions> {
  /**
   * @generated from field: optional fixed32 scalar_extension = 2000;
   */
  declare scalarExtension: number;

  /**
   * @generated from field: optional protobuf_unittest.ForeignEnum enum_extension = 2001;
   */
  declare enumExtension: ForeignEnum;

  /**
   * @generated from field: optional protobuf_unittest.TestDynamicExtensions.DynamicEnumType dynamic_enum_extension = 2002;
   */
  declare dynamicEnumExtension: TestDynamicExtensions_DynamicEnumType;

  /**
   * @generated from field: optional protobuf_unittest.ForeignMessage message_extension = 2003;
   */
  messageExtension?: ForeignMessage;

  /**
   * @generated from field: optional protobuf_unittest.TestDynamicExtensions.DynamicMessageType dynamic_message_extension = 2004;
   */
  dynamicMessageExtension?: TestDynamicExtensions_DynamicMessageType;

  /**
   * @generated from field: repeated string repeated_extension = 2005;
   */
  repeatedExtension: string[] = [];

  /**
   * @generated from field: repeated sint32 packed_extension = 2006 [packed = true];
   */
  packedExtension: number[] = [];

  constructor(data?: PartialMessage<TestDynamicExtensions>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestDynamicExtensions";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 2000, name: "scalar_extension", kind: "scalar", T: 7 /* ScalarType.FIXED32 */, opt: true },
    { no: 2001, name: "enum_extension", kind: "enum", T: proto2.getEnumType(ForeignEnum), opt: true },
    { no: 2002, name: "dynamic_enum_extension", kind: "enum", T: proto2.getEnumType(TestDynamicExtensions_DynamicEnumType), opt: true },
    { no: 2003, name: "message_extension", kind: "message", T: ForeignMessage, opt: true },
    { no: 2004, name: "dynamic_message_extension", kind: "message", T: TestDynamicExtensions_DynamicMessageType, opt: true },
    { no: 2005, name: "repeated_extension", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2006, name: "packed_extension", kind: "scalar", T: 17 /* ScalarType.SINT32 */, repeated: true, packed: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestDynamicExtensions {
    return new TestDynamicExtensions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestDynamicExtensions {
    return new TestDynamicExtensions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestDynamicExtensions {
    return new TestDynamicExtensions().fromJsonString(jsonString, options);
  }

  static equals(a: TestDynamicExtensions | PlainMessage<TestDynamicExtensions> | undefined, b: TestDynamicExtensions | PlainMessage<TestDynamicExtensions> | undefined): boolean {
    return proto2.util.equals(TestDynamicExtensions, a, b);
  }
}

TestDynamicExtensions.prototype.scalarExtension = 0;
TestDynamicExtensions.prototype.enumExtension = 4 as ForeignEnum.FOREIGN_FOO;
TestDynamicExtensions.prototype.dynamicEnumExtension = 2200 as TestDynamicExtensions_DynamicEnumType.DYNAMIC_FOO;

/**
 * @generated from enum protobuf_unittest.TestDynamicExtensions.DynamicEnumType
 */
export enum TestDynamicExtensions_DynamicEnumType {
  /**
   * @generated from enum value: DYNAMIC_FOO = 2200;
   */
  DYNAMIC_FOO = 2200,

  /**
   * @generated from enum value: DYNAMIC_BAR = 2201;
   */
  DYNAMIC_BAR = 2201,

  /**
   * @generated from enum value: DYNAMIC_BAZ = 2202;
   */
  DYNAMIC_BAZ = 2202,
}
// Retrieve enum metadata with: proto2.getEnumType(TestDynamicExtensions_DynamicEnumType)
proto2.util.setEnumType(TestDynamicExtensions_DynamicEnumType, "protobuf_unittest.TestDynamicExtensions.DynamicEnumType", [
  { no: 2200, name: "DYNAMIC_FOO" },
  { no: 2201, name: "DYNAMIC_BAR" },
  { no: 2202, name: "DYNAMIC_BAZ" },
]);

/**
 * @generated from message protobuf_unittest.TestDynamicExtensions.DynamicMessageType
 */
export class TestDynamicExtensions_DynamicMessageType extends Message<TestDynamicExtensions_DynamicMessageType> {
  /**
   * @generated from field: optional int32 dynamic_field = 2100;
   */
  declare dynamicField: number;

  constructor(data?: PartialMessage<TestDynamicExtensions_DynamicMessageType>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestDynamicExtensions.DynamicMessageType";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 2100, name: "dynamic_field", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestDynamicExtensions_DynamicMessageType {
    return new TestDynamicExtensions_DynamicMessageType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestDynamicExtensions_DynamicMessageType {
    return new TestDynamicExtensions_DynamicMessageType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestDynamicExtensions_DynamicMessageType {
    return new TestDynamicExtensions_DynamicMessageType().fromJsonString(jsonString, options);
  }

  static equals(a: TestDynamicExtensions_DynamicMessageType | PlainMessage<TestDynamicExtensions_DynamicMessageType> | undefined, b: TestDynamicExtensions_DynamicMessageType | PlainMessage<TestDynamicExtensions_DynamicMessageType> | undefined): boolean {
    return proto2.util.equals(TestDynamicExtensions_DynamicMessageType, a, b);
  }
}

TestDynamicExtensions_DynamicMessageType.prototype.dynamicField = 0;

/**
 * @generated from message protobuf_unittest.TestRepeatedString
 */
export class TestRepeatedString extends Message<TestRepeatedString> {
  /**
   * @generated from field: repeated string repeated_string1 = 1;
   */
  repeatedString1: string[] = [];

  /**
   * @generated from field: repeated string repeated_string2 = 2;
   */
  repeatedString2: string[] = [];

  /**
   * @generated from field: repeated bytes repeated_bytes11 = 11;
   */
  repeatedBytes11: Uint8Array[] = [];

  /**
   * @generated from field: repeated bytes repeated_bytes12 = 12;
   */
  repeatedBytes12: Uint8Array[] = [];

  constructor(data?: PartialMessage<TestRepeatedString>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestRepeatedString";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "repeated_string1", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "repeated_string2", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 11, name: "repeated_bytes11", kind: "scalar", T: 12 /* ScalarType.BYTES */, repeated: true },
    { no: 12, name: "repeated_bytes12", kind: "scalar", T: 12 /* ScalarType.BYTES */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestRepeatedString {
    return new TestRepeatedString().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestRepeatedString {
    return new TestRepeatedString().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestRepeatedString {
    return new TestRepeatedString().fromJsonString(jsonString, options);
  }

  static equals(a: TestRepeatedString | PlainMessage<TestRepeatedString> | undefined, b: TestRepeatedString | PlainMessage<TestRepeatedString> | undefined): boolean {
    return proto2.util.equals(TestRepeatedString, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.TestRepeatedScalarDifferentTagSizes
 */
export class TestRepeatedScalarDifferentTagSizes extends Message<TestRepeatedScalarDifferentTagSizes> {
  /**
   * Parsing repeated fixed size values used to fail. This message needs to be
   * used in order to get a tag of the right size; all of the repeated fields
   * in TestAllTypes didn't trigger the check.
   *
   * @generated from field: repeated fixed32 repeated_fixed32 = 12;
   */
  repeatedFixed32: number[] = [];

  /**
   * Check for a varint type, just for good measure.
   *
   * @generated from field: repeated int32 repeated_int32 = 13;
   */
  repeatedInt32: number[] = [];

  /**
   * These have two-byte tags.
   *
   * @generated from field: repeated fixed64 repeated_fixed64 = 2046;
   */
  repeatedFixed64: bigint[] = [];

  /**
   * @generated from field: repeated int64 repeated_int64 = 2047;
   */
  repeatedInt64: bigint[] = [];

  /**
   * Three byte tags.
   *
   * @generated from field: repeated float repeated_float = 262142;
   */
  repeatedFloat: number[] = [];

  /**
   * @generated from field: repeated uint64 repeated_uint64 = 262143;
   */
  repeatedUint64: bigint[] = [];

  constructor(data?: PartialMessage<TestRepeatedScalarDifferentTagSizes>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestRepeatedScalarDifferentTagSizes";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 12, name: "repeated_fixed32", kind: "scalar", T: 7 /* ScalarType.FIXED32 */, repeated: true },
    { no: 13, name: "repeated_int32", kind: "scalar", T: 5 /* ScalarType.INT32 */, repeated: true },
    { no: 2046, name: "repeated_fixed64", kind: "scalar", T: 6 /* ScalarType.FIXED64 */, repeated: true },
    { no: 2047, name: "repeated_int64", kind: "scalar", T: 3 /* ScalarType.INT64 */, repeated: true },
    { no: 262142, name: "repeated_float", kind: "scalar", T: 2 /* ScalarType.FLOAT */, repeated: true },
    { no: 262143, name: "repeated_uint64", kind: "scalar", T: 4 /* ScalarType.UINT64 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestRepeatedScalarDifferentTagSizes {
    return new TestRepeatedScalarDifferentTagSizes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestRepeatedScalarDifferentTagSizes {
    return new TestRepeatedScalarDifferentTagSizes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestRepeatedScalarDifferentTagSizes {
    return new TestRepeatedScalarDifferentTagSizes().fromJsonString(jsonString, options);
  }

  static equals(a: TestRepeatedScalarDifferentTagSizes | PlainMessage<TestRepeatedScalarDifferentTagSizes> | undefined, b: TestRepeatedScalarDifferentTagSizes | PlainMessage<TestRepeatedScalarDifferentTagSizes> | undefined): boolean {
    return proto2.util.equals(TestRepeatedScalarDifferentTagSizes, a, b);
  }
}

/**
 * Test that if an optional or required message/group field appears multiple
 * times in the input, they need to be merged.
 *
 * @generated from message protobuf_unittest.TestParsingMerge
 */
export class TestParsingMerge extends Message<TestParsingMerge> {
  /**
   * @generated from field: required protobuf_unittest.TestAllTypes required_all_types = 1;
   */
  requiredAllTypes?: TestAllTypes;

  /**
   * @generated from field: optional protobuf_unittest.TestAllTypes optional_all_types = 2;
   */
  optionalAllTypes?: TestAllTypes;

  /**
   * @generated from field: repeated protobuf_unittest.TestAllTypes repeated_all_types = 3;
   */
  repeatedAllTypes: TestAllTypes[] = [];

  /**
   * @generated from field: optional protobuf_unittest.TestParsingMerge.OptionalGroup optionalgroup = 10;
   */
  optionalgroup?: TestParsingMerge_OptionalGroup;

  /**
   * @generated from field: repeated protobuf_unittest.TestParsingMerge.RepeatedGroup repeatedgroup = 20;
   */
  repeatedgroup: TestParsingMerge_RepeatedGroup[] = [];

  constructor(data?: PartialMessage<TestParsingMerge>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestParsingMerge";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "required_all_types", kind: "message", T: TestAllTypes, req: true },
    { no: 2, name: "optional_all_types", kind: "message", T: TestAllTypes, opt: true },
    { no: 3, name: "repeated_all_types", kind: "message", T: TestAllTypes, repeated: true },
    { no: 10, name: "optionalgroup", kind: "message", T: TestParsingMerge_OptionalGroup, delimited: true, opt: true },
    { no: 20, name: "repeatedgroup", kind: "message", T: TestParsingMerge_RepeatedGroup, delimited: true, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestParsingMerge {
    return new TestParsingMerge().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestParsingMerge {
    return new TestParsingMerge().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestParsingMerge {
    return new TestParsingMerge().fromJsonString(jsonString, options);
  }

  static equals(a: TestParsingMerge | PlainMessage<TestParsingMerge> | undefined, b: TestParsingMerge | PlainMessage<TestParsingMerge> | undefined): boolean {
    return proto2.util.equals(TestParsingMerge, a, b);
  }
}

/**
 * RepeatedFieldsGenerator defines matching field types as TestParsingMerge,
 * except that all fields are repeated. In the tests, we will serialize the
 * RepeatedFieldsGenerator to bytes, and parse the bytes to TestParsingMerge.
 * Repeated fields in RepeatedFieldsGenerator are expected to be merged into
 * the corresponding required/optional fields in TestParsingMerge.
 *
 * @generated from message protobuf_unittest.TestParsingMerge.RepeatedFieldsGenerator
 */
export class TestParsingMerge_RepeatedFieldsGenerator extends Message<TestParsingMerge_RepeatedFieldsGenerator> {
  /**
   * @generated from field: repeated protobuf_unittest.TestAllTypes field1 = 1;
   */
  field1: TestAllTypes[] = [];

  /**
   * @generated from field: repeated protobuf_unittest.TestAllTypes field2 = 2;
   */
  field2: TestAllTypes[] = [];

  /**
   * @generated from field: repeated protobuf_unittest.TestAllTypes field3 = 3;
   */
  field3: TestAllTypes[] = [];

  /**
   * @generated from field: repeated protobuf_unittest.TestParsingMerge.RepeatedFieldsGenerator.Group1 group1 = 10;
   */
  group1: TestParsingMerge_RepeatedFieldsGenerator_Group1[] = [];

  /**
   * @generated from field: repeated protobuf_unittest.TestParsingMerge.RepeatedFieldsGenerator.Group2 group2 = 20;
   */
  group2: TestParsingMerge_RepeatedFieldsGenerator_Group2[] = [];

  /**
   * @generated from field: repeated protobuf_unittest.TestAllTypes ext1 = 1000;
   */
  ext1: TestAllTypes[] = [];

  /**
   * @generated from field: repeated protobuf_unittest.TestAllTypes ext2 = 1001;
   */
  ext2: TestAllTypes[] = [];

  constructor(data?: PartialMessage<TestParsingMerge_RepeatedFieldsGenerator>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestParsingMerge.RepeatedFieldsGenerator";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "field1", kind: "message", T: TestAllTypes, repeated: true },
    { no: 2, name: "field2", kind: "message", T: TestAllTypes, repeated: true },
    { no: 3, name: "field3", kind: "message", T: TestAllTypes, repeated: true },
    { no: 10, name: "group1", kind: "message", T: TestParsingMerge_RepeatedFieldsGenerator_Group1, delimited: true, repeated: true },
    { no: 20, name: "group2", kind: "message", T: TestParsingMerge_RepeatedFieldsGenerator_Group2, delimited: true, repeated: true },
    { no: 1000, name: "ext1", kind: "message", T: TestAllTypes, repeated: true },
    { no: 1001, name: "ext2", kind: "message", T: TestAllTypes, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestParsingMerge_RepeatedFieldsGenerator {
    return new TestParsingMerge_RepeatedFieldsGenerator().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestParsingMerge_RepeatedFieldsGenerator {
    return new TestParsingMerge_RepeatedFieldsGenerator().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestParsingMerge_RepeatedFieldsGenerator {
    return new TestParsingMerge_RepeatedFieldsGenerator().fromJsonString(jsonString, options);
  }

  static equals(a: TestParsingMerge_RepeatedFieldsGenerator | PlainMessage<TestParsingMerge_RepeatedFieldsGenerator> | undefined, b: TestParsingMerge_RepeatedFieldsGenerator | PlainMessage<TestParsingMerge_RepeatedFieldsGenerator> | undefined): boolean {
    return proto2.util.equals(TestParsingMerge_RepeatedFieldsGenerator, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.TestParsingMerge.RepeatedFieldsGenerator.Group1
 */
export class TestParsingMerge_RepeatedFieldsGenerator_Group1 extends Message<TestParsingMerge_RepeatedFieldsGenerator_Group1> {
  /**
   * @generated from field: optional protobuf_unittest.TestAllTypes field1 = 11;
   */
  field1?: TestAllTypes;

  constructor(data?: PartialMessage<TestParsingMerge_RepeatedFieldsGenerator_Group1>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestParsingMerge.RepeatedFieldsGenerator.Group1";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 11, name: "field1", kind: "message", T: TestAllTypes, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestParsingMerge_RepeatedFieldsGenerator_Group1 {
    return new TestParsingMerge_RepeatedFieldsGenerator_Group1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestParsingMerge_RepeatedFieldsGenerator_Group1 {
    return new TestParsingMerge_RepeatedFieldsGenerator_Group1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestParsingMerge_RepeatedFieldsGenerator_Group1 {
    return new TestParsingMerge_RepeatedFieldsGenerator_Group1().fromJsonString(jsonString, options);
  }

  static equals(a: TestParsingMerge_RepeatedFieldsGenerator_Group1 | PlainMessage<TestParsingMerge_RepeatedFieldsGenerator_Group1> | undefined, b: TestParsingMerge_RepeatedFieldsGenerator_Group1 | PlainMessage<TestParsingMerge_RepeatedFieldsGenerator_Group1> | undefined): boolean {
    return proto2.util.equals(TestParsingMerge_RepeatedFieldsGenerator_Group1, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.TestParsingMerge.RepeatedFieldsGenerator.Group2
 */
export class TestParsingMerge_RepeatedFieldsGenerator_Group2 extends Message<TestParsingMerge_RepeatedFieldsGenerator_Group2> {
  /**
   * @generated from field: optional protobuf_unittest.TestAllTypes field1 = 21;
   */
  field1?: TestAllTypes;

  constructor(data?: PartialMessage<TestParsingMerge_RepeatedFieldsGenerator_Group2>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestParsingMerge.RepeatedFieldsGenerator.Group2";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 21, name: "field1", kind: "message", T: TestAllTypes, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestParsingMerge_RepeatedFieldsGenerator_Group2 {
    return new TestParsingMerge_RepeatedFieldsGenerator_Group2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestParsingMerge_RepeatedFieldsGenerator_Group2 {
    return new TestParsingMerge_RepeatedFieldsGenerator_Group2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestParsingMerge_RepeatedFieldsGenerator_Group2 {
    return new TestParsingMerge_RepeatedFieldsGenerator_Group2().fromJsonString(jsonString, options);
  }

  static equals(a: TestParsingMerge_RepeatedFieldsGenerator_Group2 | PlainMessage<TestParsingMerge_RepeatedFieldsGenerator_Group2> | undefined, b: TestParsingMerge_RepeatedFieldsGenerator_Group2 | PlainMessage<TestParsingMerge_RepeatedFieldsGenerator_Group2> | undefined): boolean {
    return proto2.util.equals(TestParsingMerge_RepeatedFieldsGenerator_Group2, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.TestParsingMerge.OptionalGroup
 */
export class TestParsingMerge_OptionalGroup extends Message<TestParsingMerge_OptionalGroup> {
  /**
   * @generated from field: optional protobuf_unittest.TestAllTypes optional_group_all_types = 11;
   */
  optionalGroupAllTypes?: TestAllTypes;

  constructor(data?: PartialMessage<TestParsingMerge_OptionalGroup>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestParsingMerge.OptionalGroup";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 11, name: "optional_group_all_types", kind: "message", T: TestAllTypes, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestParsingMerge_OptionalGroup {
    return new TestParsingMerge_OptionalGroup().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestParsingMerge_OptionalGroup {
    return new TestParsingMerge_OptionalGroup().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestParsingMerge_OptionalGroup {
    return new TestParsingMerge_OptionalGroup().fromJsonString(jsonString, options);
  }

  static equals(a: TestParsingMerge_OptionalGroup | PlainMessage<TestParsingMerge_OptionalGroup> | undefined, b: TestParsingMerge_OptionalGroup | PlainMessage<TestParsingMerge_OptionalGroup> | undefined): boolean {
    return proto2.util.equals(TestParsingMerge_OptionalGroup, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.TestParsingMerge.RepeatedGroup
 */
export class TestParsingMerge_RepeatedGroup extends Message<TestParsingMerge_RepeatedGroup> {
  /**
   * @generated from field: optional protobuf_unittest.TestAllTypes repeated_group_all_types = 21;
   */
  repeatedGroupAllTypes?: TestAllTypes;

  constructor(data?: PartialMessage<TestParsingMerge_RepeatedGroup>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestParsingMerge.RepeatedGroup";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 21, name: "repeated_group_all_types", kind: "message", T: TestAllTypes, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestParsingMerge_RepeatedGroup {
    return new TestParsingMerge_RepeatedGroup().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestParsingMerge_RepeatedGroup {
    return new TestParsingMerge_RepeatedGroup().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestParsingMerge_RepeatedGroup {
    return new TestParsingMerge_RepeatedGroup().fromJsonString(jsonString, options);
  }

  static equals(a: TestParsingMerge_RepeatedGroup | PlainMessage<TestParsingMerge_RepeatedGroup> | undefined, b: TestParsingMerge_RepeatedGroup | PlainMessage<TestParsingMerge_RepeatedGroup> | undefined): boolean {
    return proto2.util.equals(TestParsingMerge_RepeatedGroup, a, b);
  }
}

/**
 * @generated from extension: optional protobuf_unittest.TestAllTypes optional_ext = 1000;
 */
export const TestParsingMerge_optional_ext = proto2.makeExtension<TestParsingMerge, TestAllTypes>(
  "protobuf_unittest.TestParsingMerge.optional_ext", 
  TestParsingMerge, 
  () => ({ no: 1000, kind: "message", T: TestAllTypes, opt: true }),
);

/**
 * @generated from extension: repeated protobuf_unittest.TestAllTypes repeated_ext = 1001;
 */
export const TestParsingMerge_repeated_ext = proto2.makeExtension<TestParsingMerge, TestAllTypes[]>(
  "protobuf_unittest.TestParsingMerge.repeated_ext", 
  TestParsingMerge, 
  () => ({ no: 1001, kind: "message", T: TestAllTypes, repeated: true }),
);

/**
 * Test that the correct exception is thrown by parseFrom in a corner case
 * involving merging, extensions, and required fields.
 *
 * @generated from message protobuf_unittest.TestMergeException
 */
export class TestMergeException extends Message<TestMergeException> {
  /**
   * @generated from field: optional protobuf_unittest.TestAllExtensions all_extensions = 1;
   */
  allExtensions?: TestAllExtensions;

  constructor(data?: PartialMessage<TestMergeException>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestMergeException";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "all_extensions", kind: "message", T: TestAllExtensions, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestMergeException {
    return new TestMergeException().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestMergeException {
    return new TestMergeException().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestMergeException {
    return new TestMergeException().fromJsonString(jsonString, options);
  }

  static equals(a: TestMergeException | PlainMessage<TestMergeException> | undefined, b: TestMergeException | PlainMessage<TestMergeException> | undefined): boolean {
    return proto2.util.equals(TestMergeException, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.TestCommentInjectionMessage
 */
export class TestCommentInjectionMessage extends Message<TestCommentInjectionMessage> {
  /**
   * *\/ <- This should not close the generated doc comment
   *
   * @generated from field: optional string a = 1 [default = "*\/ <- Neither should this."];
   */
  declare a: string;

  constructor(data?: PartialMessage<TestCommentInjectionMessage>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestCommentInjectionMessage";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "a", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true, default: "*/ <- Neither should this." },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestCommentInjectionMessage {
    return new TestCommentInjectionMessage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestCommentInjectionMessage {
    return new TestCommentInjectionMessage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestCommentInjectionMessage {
    return new TestCommentInjectionMessage().fromJsonString(jsonString, options);
  }

  static equals(a: TestCommentInjectionMessage | PlainMessage<TestCommentInjectionMessage> | undefined, b: TestCommentInjectionMessage | PlainMessage<TestCommentInjectionMessage> | undefined): boolean {
    return proto2.util.equals(TestCommentInjectionMessage, a, b);
  }
}

TestCommentInjectionMessage.prototype.a = "*/ <- Neither should this.";

/**
 * Used to check that the c++ code generator re-orders messages to reduce
 * padding.
 *
 * @generated from message protobuf_unittest.TestMessageSize
 */
export class TestMessageSize extends Message<TestMessageSize> {
  /**
   * @generated from field: optional bool m1 = 1;
   */
  declare m1: boolean;

  /**
   * @generated from field: optional int64 m2 = 2;
   */
  declare m2: bigint;

  /**
   * @generated from field: optional bool m3 = 3;
   */
  declare m3: boolean;

  /**
   * @generated from field: optional string m4 = 4;
   */
  declare m4: string;

  /**
   * @generated from field: optional int32 m5 = 5;
   */
  declare m5: number;

  /**
   * @generated from field: optional int64 m6 = 6;
   */
  declare m6: bigint;

  constructor(data?: PartialMessage<TestMessageSize>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestMessageSize";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "m1", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 2, name: "m2", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 3, name: "m3", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 4, name: "m4", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "m5", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 6, name: "m6", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestMessageSize {
    return new TestMessageSize().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestMessageSize {
    return new TestMessageSize().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestMessageSize {
    return new TestMessageSize().fromJsonString(jsonString, options);
  }

  static equals(a: TestMessageSize | PlainMessage<TestMessageSize> | undefined, b: TestMessageSize | PlainMessage<TestMessageSize> | undefined): boolean {
    return proto2.util.equals(TestMessageSize, a, b);
  }
}

TestMessageSize.prototype.m1 = false;
TestMessageSize.prototype.m2 = protoInt64.zero;
TestMessageSize.prototype.m3 = false;
TestMessageSize.prototype.m4 = "";
TestMessageSize.prototype.m5 = 0;
TestMessageSize.prototype.m6 = protoInt64.zero;

/**
 * Test that RPC services work.
 *
 * @generated from message protobuf_unittest.FooRequest
 */
export class FooRequest extends Message<FooRequest> {
  constructor(data?: PartialMessage<FooRequest>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.FooRequest";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FooRequest {
    return new FooRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FooRequest {
    return new FooRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FooRequest {
    return new FooRequest().fromJsonString(jsonString, options);
  }

  static equals(a: FooRequest | PlainMessage<FooRequest> | undefined, b: FooRequest | PlainMessage<FooRequest> | undefined): boolean {
    return proto2.util.equals(FooRequest, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.FooResponse
 */
export class FooResponse extends Message<FooResponse> {
  constructor(data?: PartialMessage<FooResponse>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.FooResponse";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FooResponse {
    return new FooResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FooResponse {
    return new FooResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FooResponse {
    return new FooResponse().fromJsonString(jsonString, options);
  }

  static equals(a: FooResponse | PlainMessage<FooResponse> | undefined, b: FooResponse | PlainMessage<FooResponse> | undefined): boolean {
    return proto2.util.equals(FooResponse, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.FooClientMessage
 */
export class FooClientMessage extends Message<FooClientMessage> {
  constructor(data?: PartialMessage<FooClientMessage>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.FooClientMessage";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FooClientMessage {
    return new FooClientMessage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FooClientMessage {
    return new FooClientMessage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FooClientMessage {
    return new FooClientMessage().fromJsonString(jsonString, options);
  }

  static equals(a: FooClientMessage | PlainMessage<FooClientMessage> | undefined, b: FooClientMessage | PlainMessage<FooClientMessage> | undefined): boolean {
    return proto2.util.equals(FooClientMessage, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.FooServerMessage
 */
export class FooServerMessage extends Message<FooServerMessage> {
  constructor(data?: PartialMessage<FooServerMessage>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.FooServerMessage";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FooServerMessage {
    return new FooServerMessage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FooServerMessage {
    return new FooServerMessage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FooServerMessage {
    return new FooServerMessage().fromJsonString(jsonString, options);
  }

  static equals(a: FooServerMessage | PlainMessage<FooServerMessage> | undefined, b: FooServerMessage | PlainMessage<FooServerMessage> | undefined): boolean {
    return proto2.util.equals(FooServerMessage, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.BarRequest
 */
export class BarRequest extends Message<BarRequest> {
  constructor(data?: PartialMessage<BarRequest>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.BarRequest";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BarRequest {
    return new BarRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BarRequest {
    return new BarRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BarRequest {
    return new BarRequest().fromJsonString(jsonString, options);
  }

  static equals(a: BarRequest | PlainMessage<BarRequest> | undefined, b: BarRequest | PlainMessage<BarRequest> | undefined): boolean {
    return proto2.util.equals(BarRequest, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.BarResponse
 */
export class BarResponse extends Message<BarResponse> {
  constructor(data?: PartialMessage<BarResponse>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.BarResponse";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BarResponse {
    return new BarResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BarResponse {
    return new BarResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BarResponse {
    return new BarResponse().fromJsonString(jsonString, options);
  }

  static equals(a: BarResponse | PlainMessage<BarResponse> | undefined, b: BarResponse | PlainMessage<BarResponse> | undefined): boolean {
    return proto2.util.equals(BarResponse, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.TestJsonName
 */
export class TestJsonName extends Message<TestJsonName> {
  /**
   * @generated from field: optional int32 field_name1 = 1;
   */
  declare fieldName1: number;

  /**
   * @generated from field: optional int32 fieldName2 = 2;
   */
  declare fieldName2: number;

  /**
   * @generated from field: optional int32 FieldName3 = 3;
   */
  declare FieldName3: number;

  /**
   * @generated from field: optional int32 _field_name4 = 4;
   */
  declare FieldName4: number;

  /**
   * @generated from field: optional int32 FIELD_NAME5 = 5;
   */
  declare FIELDNAME5: number;

  /**
   * @generated from field: optional int32 field_name6 = 6 [json_name = "@type"];
   */
  declare fieldName6: number;

  /**
   * @generated from field: optional int32 fieldname7 = 7;
   */
  declare fieldname7: number;

  constructor(data?: PartialMessage<TestJsonName>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestJsonName";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "field_name1", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 2, name: "fieldName2", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 3, name: "FieldName3", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 4, name: "_field_name4", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 5, name: "FIELD_NAME5", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 6, name: "field_name6", jsonName: "@type", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 7, name: "fieldname7", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestJsonName {
    return new TestJsonName().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestJsonName {
    return new TestJsonName().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestJsonName {
    return new TestJsonName().fromJsonString(jsonString, options);
  }

  static equals(a: TestJsonName | PlainMessage<TestJsonName> | undefined, b: TestJsonName | PlainMessage<TestJsonName> | undefined): boolean {
    return proto2.util.equals(TestJsonName, a, b);
  }
}

TestJsonName.prototype.fieldName1 = 0;
TestJsonName.prototype.fieldName2 = 0;
TestJsonName.prototype.FieldName3 = 0;
TestJsonName.prototype.FieldName4 = 0;
TestJsonName.prototype.FIELDNAME5 = 0;
TestJsonName.prototype.fieldName6 = 0;
TestJsonName.prototype.fieldname7 = 0;

/**
 * @generated from message protobuf_unittest.TestHugeFieldNumbers
 */
export class TestHugeFieldNumbers extends Message<TestHugeFieldNumbers> {
  /**
   * @generated from field: optional int32 optional_int32 = 536870000;
   */
  declare optionalInt32: number;

  /**
   * @generated from field: optional int32 fixed_32 = 536870001;
   */
  declare fixed32: number;

  /**
   * @generated from field: repeated int32 repeated_int32 = 536870002 [packed = false];
   */
  repeatedInt32: number[] = [];

  /**
   * @generated from field: repeated int32 packed_int32 = 536870003 [packed = true];
   */
  packedInt32: number[] = [];

  /**
   * @generated from field: optional protobuf_unittest.ForeignEnum optional_enum = 536870004;
   */
  declare optionalEnum: ForeignEnum;

  /**
   * @generated from field: optional string optional_string = 536870005;
   */
  declare optionalString: string;

  /**
   * @generated from field: optional bytes optional_bytes = 536870006;
   */
  declare optionalBytes: Uint8Array;

  /**
   * @generated from field: optional protobuf_unittest.ForeignMessage optional_message = 536870007;
   */
  optionalMessage?: ForeignMessage;

  /**
   * @generated from field: optional protobuf_unittest.TestHugeFieldNumbers.OptionalGroup optionalgroup = 536870008;
   */
  optionalgroup?: TestHugeFieldNumbers_OptionalGroup;

  /**
   * @generated from field: map<string, string> string_string_map = 536870010;
   */
  stringStringMap: { [key: string]: string } = {};

  /**
   * @generated from oneof protobuf_unittest.TestHugeFieldNumbers.oneof_field
   */
  oneofField: {
    /**
     * @generated from field: uint32 oneof_uint32 = 536870011;
     */
    value: number;
    case: "oneofUint32";
  } | {
    /**
     * @generated from field: protobuf_unittest.TestAllTypes oneof_test_all_types = 536870012;
     */
    value: TestAllTypes;
    case: "oneofTestAllTypes";
  } | {
    /**
     * @generated from field: string oneof_string = 536870013;
     */
    value: string;
    case: "oneofString";
  } | {
    /**
     * @generated from field: bytes oneof_bytes = 536870014;
     */
    value: Uint8Array;
    case: "oneofBytes";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<TestHugeFieldNumbers>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestHugeFieldNumbers";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 536870000, name: "optional_int32", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 536870001, name: "fixed_32", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 536870002, name: "repeated_int32", kind: "scalar", T: 5 /* ScalarType.INT32 */, repeated: true },
    { no: 536870003, name: "packed_int32", kind: "scalar", T: 5 /* ScalarType.INT32 */, repeated: true, packed: true },
    { no: 536870004, name: "optional_enum", kind: "enum", T: proto2.getEnumType(ForeignEnum), opt: true },
    { no: 536870005, name: "optional_string", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 536870006, name: "optional_bytes", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 536870007, name: "optional_message", kind: "message", T: ForeignMessage, opt: true },
    { no: 536870008, name: "optionalgroup", kind: "message", T: TestHugeFieldNumbers_OptionalGroup, delimited: true, opt: true },
    { no: 536870010, name: "string_string_map", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 536870011, name: "oneof_uint32", kind: "scalar", T: 13 /* ScalarType.UINT32 */, oneof: "oneof_field" },
    { no: 536870012, name: "oneof_test_all_types", kind: "message", T: TestAllTypes, oneof: "oneof_field" },
    { no: 536870013, name: "oneof_string", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "oneof_field" },
    { no: 536870014, name: "oneof_bytes", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "oneof_field" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestHugeFieldNumbers {
    return new TestHugeFieldNumbers().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestHugeFieldNumbers {
    return new TestHugeFieldNumbers().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestHugeFieldNumbers {
    return new TestHugeFieldNumbers().fromJsonString(jsonString, options);
  }

  static equals(a: TestHugeFieldNumbers | PlainMessage<TestHugeFieldNumbers> | undefined, b: TestHugeFieldNumbers | PlainMessage<TestHugeFieldNumbers> | undefined): boolean {
    return proto2.util.equals(TestHugeFieldNumbers, a, b);
  }
}

TestHugeFieldNumbers.prototype.optionalInt32 = 0;
TestHugeFieldNumbers.prototype.fixed32 = 0;
TestHugeFieldNumbers.prototype.optionalEnum = 4 as ForeignEnum.FOREIGN_FOO;
TestHugeFieldNumbers.prototype.optionalString = "";
TestHugeFieldNumbers.prototype.optionalBytes = new Uint8Array(0);

/**
 * @generated from message protobuf_unittest.TestHugeFieldNumbers.OptionalGroup
 */
export class TestHugeFieldNumbers_OptionalGroup extends Message<TestHugeFieldNumbers_OptionalGroup> {
  /**
   * @generated from field: optional int32 group_a = 536870009;
   */
  declare groupA: number;

  constructor(data?: PartialMessage<TestHugeFieldNumbers_OptionalGroup>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestHugeFieldNumbers.OptionalGroup";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 536870009, name: "group_a", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestHugeFieldNumbers_OptionalGroup {
    return new TestHugeFieldNumbers_OptionalGroup().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestHugeFieldNumbers_OptionalGroup {
    return new TestHugeFieldNumbers_OptionalGroup().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestHugeFieldNumbers_OptionalGroup {
    return new TestHugeFieldNumbers_OptionalGroup().fromJsonString(jsonString, options);
  }

  static equals(a: TestHugeFieldNumbers_OptionalGroup | PlainMessage<TestHugeFieldNumbers_OptionalGroup> | undefined, b: TestHugeFieldNumbers_OptionalGroup | PlainMessage<TestHugeFieldNumbers_OptionalGroup> | undefined): boolean {
    return proto2.util.equals(TestHugeFieldNumbers_OptionalGroup, a, b);
  }
}

TestHugeFieldNumbers_OptionalGroup.prototype.groupA = 0;

/**
 * @generated from message protobuf_unittest.TestExtensionInsideTable
 */
export class TestExtensionInsideTable extends Message<TestExtensionInsideTable> {
  /**
   * @generated from field: optional int32 field1 = 1;
   */
  declare field1: number;

  /**
   * @generated from field: optional int32 field2 = 2;
   */
  declare field2: number;

  /**
   * @generated from field: optional int32 field3 = 3;
   */
  declare field3: number;

  /**
   * @generated from field: optional int32 field4 = 4;
   */
  declare field4: number;

  /**
   * @generated from field: optional int32 field6 = 6;
   */
  declare field6: number;

  /**
   * @generated from field: optional int32 field7 = 7;
   */
  declare field7: number;

  /**
   * @generated from field: optional int32 field8 = 8;
   */
  declare field8: number;

  /**
   * @generated from field: optional int32 field9 = 9;
   */
  declare field9: number;

  /**
   * @generated from field: optional int32 field10 = 10;
   */
  declare field10: number;

  constructor(data?: PartialMessage<TestExtensionInsideTable>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestExtensionInsideTable";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "field1", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 2, name: "field2", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 3, name: "field3", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 4, name: "field4", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 6, name: "field6", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 7, name: "field7", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 8, name: "field8", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 9, name: "field9", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 10, name: "field10", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestExtensionInsideTable {
    return new TestExtensionInsideTable().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestExtensionInsideTable {
    return new TestExtensionInsideTable().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestExtensionInsideTable {
    return new TestExtensionInsideTable().fromJsonString(jsonString, options);
  }

  static equals(a: TestExtensionInsideTable | PlainMessage<TestExtensionInsideTable> | undefined, b: TestExtensionInsideTable | PlainMessage<TestExtensionInsideTable> | undefined): boolean {
    return proto2.util.equals(TestExtensionInsideTable, a, b);
  }
}

TestExtensionInsideTable.prototype.field1 = 0;
TestExtensionInsideTable.prototype.field2 = 0;
TestExtensionInsideTable.prototype.field3 = 0;
TestExtensionInsideTable.prototype.field4 = 0;
TestExtensionInsideTable.prototype.field6 = 0;
TestExtensionInsideTable.prototype.field7 = 0;
TestExtensionInsideTable.prototype.field8 = 0;
TestExtensionInsideTable.prototype.field9 = 0;
TestExtensionInsideTable.prototype.field10 = 0;

/**
 * NOTE: Intentionally nested to mirror go/glep.
 *
 * @generated from message protobuf_unittest.TestNestedGroupExtensionOuter
 */
export class TestNestedGroupExtensionOuter extends Message<TestNestedGroupExtensionOuter> {
  /**
   * @generated from field: optional protobuf_unittest.TestNestedGroupExtensionOuter.Layer1OptionalGroup layer1optionalgroup = 1;
   */
  layer1optionalgroup?: TestNestedGroupExtensionOuter_Layer1OptionalGroup;

  constructor(data?: PartialMessage<TestNestedGroupExtensionOuter>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestNestedGroupExtensionOuter";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "layer1optionalgroup", kind: "message", T: TestNestedGroupExtensionOuter_Layer1OptionalGroup, delimited: true, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestNestedGroupExtensionOuter {
    return new TestNestedGroupExtensionOuter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestNestedGroupExtensionOuter {
    return new TestNestedGroupExtensionOuter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestNestedGroupExtensionOuter {
    return new TestNestedGroupExtensionOuter().fromJsonString(jsonString, options);
  }

  static equals(a: TestNestedGroupExtensionOuter | PlainMessage<TestNestedGroupExtensionOuter> | undefined, b: TestNestedGroupExtensionOuter | PlainMessage<TestNestedGroupExtensionOuter> | undefined): boolean {
    return proto2.util.equals(TestNestedGroupExtensionOuter, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.TestNestedGroupExtensionOuter.Layer1OptionalGroup
 */
export class TestNestedGroupExtensionOuter_Layer1OptionalGroup extends Message<TestNestedGroupExtensionOuter_Layer1OptionalGroup> {
  /**
   * @generated from field: repeated protobuf_unittest.TestNestedGroupExtensionOuter.Layer1OptionalGroup.Layer2RepeatedGroup layer2repeatedgroup = 2;
   */
  layer2repeatedgroup: TestNestedGroupExtensionOuter_Layer1OptionalGroup_Layer2RepeatedGroup[] = [];

  /**
   * @generated from field: repeated protobuf_unittest.TestNestedGroupExtensionOuter.Layer1OptionalGroup.Layer2AnotherOptionalRepeatedGroup layer2anotheroptionalrepeatedgroup = 4;
   */
  layer2anotheroptionalrepeatedgroup: TestNestedGroupExtensionOuter_Layer1OptionalGroup_Layer2AnotherOptionalRepeatedGroup[] = [];

  constructor(data?: PartialMessage<TestNestedGroupExtensionOuter_Layer1OptionalGroup>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestNestedGroupExtensionOuter.Layer1OptionalGroup";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 2, name: "layer2repeatedgroup", kind: "message", T: TestNestedGroupExtensionOuter_Layer1OptionalGroup_Layer2RepeatedGroup, delimited: true, repeated: true },
    { no: 4, name: "layer2anotheroptionalrepeatedgroup", kind: "message", T: TestNestedGroupExtensionOuter_Layer1OptionalGroup_Layer2AnotherOptionalRepeatedGroup, delimited: true, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestNestedGroupExtensionOuter_Layer1OptionalGroup {
    return new TestNestedGroupExtensionOuter_Layer1OptionalGroup().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestNestedGroupExtensionOuter_Layer1OptionalGroup {
    return new TestNestedGroupExtensionOuter_Layer1OptionalGroup().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestNestedGroupExtensionOuter_Layer1OptionalGroup {
    return new TestNestedGroupExtensionOuter_Layer1OptionalGroup().fromJsonString(jsonString, options);
  }

  static equals(a: TestNestedGroupExtensionOuter_Layer1OptionalGroup | PlainMessage<TestNestedGroupExtensionOuter_Layer1OptionalGroup> | undefined, b: TestNestedGroupExtensionOuter_Layer1OptionalGroup | PlainMessage<TestNestedGroupExtensionOuter_Layer1OptionalGroup> | undefined): boolean {
    return proto2.util.equals(TestNestedGroupExtensionOuter_Layer1OptionalGroup, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.TestNestedGroupExtensionOuter.Layer1OptionalGroup.Layer2RepeatedGroup
 */
export class TestNestedGroupExtensionOuter_Layer1OptionalGroup_Layer2RepeatedGroup extends Message<TestNestedGroupExtensionOuter_Layer1OptionalGroup_Layer2RepeatedGroup> {
  /**
   * @generated from field: optional string another_field = 6;
   */
  declare anotherField: string;

  constructor(data?: PartialMessage<TestNestedGroupExtensionOuter_Layer1OptionalGroup_Layer2RepeatedGroup>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestNestedGroupExtensionOuter.Layer1OptionalGroup.Layer2RepeatedGroup";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 6, name: "another_field", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestNestedGroupExtensionOuter_Layer1OptionalGroup_Layer2RepeatedGroup {
    return new TestNestedGroupExtensionOuter_Layer1OptionalGroup_Layer2RepeatedGroup().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestNestedGroupExtensionOuter_Layer1OptionalGroup_Layer2RepeatedGroup {
    return new TestNestedGroupExtensionOuter_Layer1OptionalGroup_Layer2RepeatedGroup().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestNestedGroupExtensionOuter_Layer1OptionalGroup_Layer2RepeatedGroup {
    return new TestNestedGroupExtensionOuter_Layer1OptionalGroup_Layer2RepeatedGroup().fromJsonString(jsonString, options);
  }

  static equals(a: TestNestedGroupExtensionOuter_Layer1OptionalGroup_Layer2RepeatedGroup | PlainMessage<TestNestedGroupExtensionOuter_Layer1OptionalGroup_Layer2RepeatedGroup> | undefined, b: TestNestedGroupExtensionOuter_Layer1OptionalGroup_Layer2RepeatedGroup | PlainMessage<TestNestedGroupExtensionOuter_Layer1OptionalGroup_Layer2RepeatedGroup> | undefined): boolean {
    return proto2.util.equals(TestNestedGroupExtensionOuter_Layer1OptionalGroup_Layer2RepeatedGroup, a, b);
  }
}

TestNestedGroupExtensionOuter_Layer1OptionalGroup_Layer2RepeatedGroup.prototype.anotherField = "";

/**
 * @generated from message protobuf_unittest.TestNestedGroupExtensionOuter.Layer1OptionalGroup.Layer2AnotherOptionalRepeatedGroup
 */
export class TestNestedGroupExtensionOuter_Layer1OptionalGroup_Layer2AnotherOptionalRepeatedGroup extends Message<TestNestedGroupExtensionOuter_Layer1OptionalGroup_Layer2AnotherOptionalRepeatedGroup> {
  /**
   * @generated from field: optional string but_why_tho = 5;
   */
  declare butWhyTho: string;

  constructor(data?: PartialMessage<TestNestedGroupExtensionOuter_Layer1OptionalGroup_Layer2AnotherOptionalRepeatedGroup>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestNestedGroupExtensionOuter.Layer1OptionalGroup.Layer2AnotherOptionalRepeatedGroup";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 5, name: "but_why_tho", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestNestedGroupExtensionOuter_Layer1OptionalGroup_Layer2AnotherOptionalRepeatedGroup {
    return new TestNestedGroupExtensionOuter_Layer1OptionalGroup_Layer2AnotherOptionalRepeatedGroup().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestNestedGroupExtensionOuter_Layer1OptionalGroup_Layer2AnotherOptionalRepeatedGroup {
    return new TestNestedGroupExtensionOuter_Layer1OptionalGroup_Layer2AnotherOptionalRepeatedGroup().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestNestedGroupExtensionOuter_Layer1OptionalGroup_Layer2AnotherOptionalRepeatedGroup {
    return new TestNestedGroupExtensionOuter_Layer1OptionalGroup_Layer2AnotherOptionalRepeatedGroup().fromJsonString(jsonString, options);
  }

  static equals(a: TestNestedGroupExtensionOuter_Layer1OptionalGroup_Layer2AnotherOptionalRepeatedGroup | PlainMessage<TestNestedGroupExtensionOuter_Layer1OptionalGroup_Layer2AnotherOptionalRepeatedGroup> | undefined, b: TestNestedGroupExtensionOuter_Layer1OptionalGroup_Layer2AnotherOptionalRepeatedGroup | PlainMessage<TestNestedGroupExtensionOuter_Layer1OptionalGroup_Layer2AnotherOptionalRepeatedGroup> | undefined): boolean {
    return proto2.util.equals(TestNestedGroupExtensionOuter_Layer1OptionalGroup_Layer2AnotherOptionalRepeatedGroup, a, b);
  }
}

TestNestedGroupExtensionOuter_Layer1OptionalGroup_Layer2AnotherOptionalRepeatedGroup.prototype.butWhyTho = "";

/**
 * @generated from message protobuf_unittest.TestNestedGroupExtensionInnerExtension
 */
export class TestNestedGroupExtensionInnerExtension extends Message<TestNestedGroupExtensionInnerExtension> {
  /**
   * @generated from field: optional string inner_name = 1;
   */
  declare innerName: string;

  constructor(data?: PartialMessage<TestNestedGroupExtensionInnerExtension>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestNestedGroupExtensionInnerExtension";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "inner_name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestNestedGroupExtensionInnerExtension {
    return new TestNestedGroupExtensionInnerExtension().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestNestedGroupExtensionInnerExtension {
    return new TestNestedGroupExtensionInnerExtension().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestNestedGroupExtensionInnerExtension {
    return new TestNestedGroupExtensionInnerExtension().fromJsonString(jsonString, options);
  }

  static equals(a: TestNestedGroupExtensionInnerExtension | PlainMessage<TestNestedGroupExtensionInnerExtension> | undefined, b: TestNestedGroupExtensionInnerExtension | PlainMessage<TestNestedGroupExtensionInnerExtension> | undefined): boolean {
    return proto2.util.equals(TestNestedGroupExtensionInnerExtension, a, b);
  }
}

TestNestedGroupExtensionInnerExtension.prototype.innerName = "";

/**
 * @generated from message protobuf_unittest.TestExtensionRangeSerialize
 */
export class TestExtensionRangeSerialize extends Message<TestExtensionRangeSerialize> {
  /**
   * @generated from field: optional int32 foo_one = 1;
   */
  declare fooOne: number;

  /**
   * @generated from field: optional int32 foo_two = 6;
   */
  declare fooTwo: number;

  /**
   * @generated from field: optional int32 foo_three = 7;
   */
  declare fooThree: number;

  /**
   * @generated from field: optional int32 foo_four = 13;
   */
  declare fooFour: number;

  constructor(data?: PartialMessage<TestExtensionRangeSerialize>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestExtensionRangeSerialize";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "foo_one", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 6, name: "foo_two", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 7, name: "foo_three", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 13, name: "foo_four", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestExtensionRangeSerialize {
    return new TestExtensionRangeSerialize().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestExtensionRangeSerialize {
    return new TestExtensionRangeSerialize().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestExtensionRangeSerialize {
    return new TestExtensionRangeSerialize().fromJsonString(jsonString, options);
  }

  static equals(a: TestExtensionRangeSerialize | PlainMessage<TestExtensionRangeSerialize> | undefined, b: TestExtensionRangeSerialize | PlainMessage<TestExtensionRangeSerialize> | undefined): boolean {
    return proto2.util.equals(TestExtensionRangeSerialize, a, b);
  }
}

TestExtensionRangeSerialize.prototype.fooOne = 0;
TestExtensionRangeSerialize.prototype.fooTwo = 0;
TestExtensionRangeSerialize.prototype.fooThree = 0;
TestExtensionRangeSerialize.prototype.fooFour = 0;

/**
 * @generated from extension: optional int32 bar_one = 2;
 */
export const TestExtensionRangeSerialize_bar_one = proto2.makeExtension<TestExtensionRangeSerialize, number>(
  "protobuf_unittest.TestExtensionRangeSerialize.bar_one", 
  TestExtensionRangeSerialize, 
  { no: 2, kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
);

/**
 * @generated from extension: optional int32 bar_two = 4;
 */
export const TestExtensionRangeSerialize_bar_two = proto2.makeExtension<TestExtensionRangeSerialize, number>(
  "protobuf_unittest.TestExtensionRangeSerialize.bar_two", 
  TestExtensionRangeSerialize, 
  { no: 4, kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
);

/**
 * @generated from extension: optional int32 bar_three = 10;
 */
export const TestExtensionRangeSerialize_bar_three = proto2.makeExtension<TestExtensionRangeSerialize, number>(
  "protobuf_unittest.TestExtensionRangeSerialize.bar_three", 
  TestExtensionRangeSerialize, 
  { no: 10, kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
);

/**
 * @generated from extension: optional int32 bar_four = 15;
 */
export const TestExtensionRangeSerialize_bar_four = proto2.makeExtension<TestExtensionRangeSerialize, number>(
  "protobuf_unittest.TestExtensionRangeSerialize.bar_four", 
  TestExtensionRangeSerialize, 
  { no: 15, kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
);

/**
 * @generated from extension: optional int32 bar_five = 19;
 */
export const TestExtensionRangeSerialize_bar_five = proto2.makeExtension<TestExtensionRangeSerialize, number>(
  "protobuf_unittest.TestExtensionRangeSerialize.bar_five", 
  TestExtensionRangeSerialize, 
  { no: 19, kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
);

/**
 * @generated from message protobuf_unittest.TestVerifyInt32Simple
 */
export class TestVerifyInt32Simple extends Message<TestVerifyInt32Simple> {
  /**
   * @generated from field: optional int32 optional_int32_1 = 1;
   */
  declare optionalInt321: number;

  /**
   * @generated from field: optional int32 optional_int32_2 = 2;
   */
  declare optionalInt322: number;

  /**
   * @generated from field: optional int32 optional_int32_63 = 63;
   */
  declare optionalInt3263: number;

  /**
   * @generated from field: optional int32 optional_int32_64 = 64;
   */
  declare optionalInt3264: number;

  constructor(data?: PartialMessage<TestVerifyInt32Simple>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestVerifyInt32Simple";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "optional_int32_1", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 2, name: "optional_int32_2", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 63, name: "optional_int32_63", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 64, name: "optional_int32_64", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestVerifyInt32Simple {
    return new TestVerifyInt32Simple().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestVerifyInt32Simple {
    return new TestVerifyInt32Simple().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestVerifyInt32Simple {
    return new TestVerifyInt32Simple().fromJsonString(jsonString, options);
  }

  static equals(a: TestVerifyInt32Simple | PlainMessage<TestVerifyInt32Simple> | undefined, b: TestVerifyInt32Simple | PlainMessage<TestVerifyInt32Simple> | undefined): boolean {
    return proto2.util.equals(TestVerifyInt32Simple, a, b);
  }
}

TestVerifyInt32Simple.prototype.optionalInt321 = 0;
TestVerifyInt32Simple.prototype.optionalInt322 = 0;
TestVerifyInt32Simple.prototype.optionalInt3263 = 0;
TestVerifyInt32Simple.prototype.optionalInt3264 = 0;

/**
 * @generated from message protobuf_unittest.TestVerifyInt32
 */
export class TestVerifyInt32 extends Message<TestVerifyInt32> {
  /**
   * @generated from field: optional int32 optional_int32_1 = 1;
   */
  declare optionalInt321: number;

  /**
   * @generated from field: optional int32 optional_int32_2 = 2;
   */
  declare optionalInt322: number;

  /**
   * @generated from field: optional int32 optional_int32_63 = 63;
   */
  declare optionalInt3263: number;

  /**
   * @generated from field: optional int32 optional_int32_64 = 64;
   */
  declare optionalInt3264: number;

  /**
   * @generated from field: optional protobuf_unittest.TestAllTypes optional_all_types = 9;
   */
  optionalAllTypes?: TestAllTypes;

  /**
   * @generated from field: repeated protobuf_unittest.TestAllTypes repeated_all_types = 10;
   */
  repeatedAllTypes: TestAllTypes[] = [];

  constructor(data?: PartialMessage<TestVerifyInt32>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestVerifyInt32";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "optional_int32_1", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 2, name: "optional_int32_2", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 63, name: "optional_int32_63", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 64, name: "optional_int32_64", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 9, name: "optional_all_types", kind: "message", T: TestAllTypes, opt: true },
    { no: 10, name: "repeated_all_types", kind: "message", T: TestAllTypes, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestVerifyInt32 {
    return new TestVerifyInt32().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestVerifyInt32 {
    return new TestVerifyInt32().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestVerifyInt32 {
    return new TestVerifyInt32().fromJsonString(jsonString, options);
  }

  static equals(a: TestVerifyInt32 | PlainMessage<TestVerifyInt32> | undefined, b: TestVerifyInt32 | PlainMessage<TestVerifyInt32> | undefined): boolean {
    return proto2.util.equals(TestVerifyInt32, a, b);
  }
}

TestVerifyInt32.prototype.optionalInt321 = 0;
TestVerifyInt32.prototype.optionalInt322 = 0;
TestVerifyInt32.prototype.optionalInt3263 = 0;
TestVerifyInt32.prototype.optionalInt3264 = 0;

/**
 * @generated from message protobuf_unittest.TestVerifyMostlyInt32
 */
export class TestVerifyMostlyInt32 extends Message<TestVerifyMostlyInt32> {
  /**
   * @generated from field: optional int64 optional_int64_30 = 30;
   */
  declare optionalInt6430: bigint;

  /**
   * @generated from field: optional int32 optional_int32_1 = 1;
   */
  declare optionalInt321: number;

  /**
   * @generated from field: optional int32 optional_int32_2 = 2;
   */
  declare optionalInt322: number;

  /**
   * @generated from field: optional int32 optional_int32_3 = 3;
   */
  declare optionalInt323: number;

  /**
   * @generated from field: optional int32 optional_int32_4 = 4;
   */
  declare optionalInt324: number;

  /**
   * @generated from field: optional int32 optional_int32_63 = 63;
   */
  declare optionalInt3263: number;

  /**
   * @generated from field: optional int32 optional_int32_64 = 64;
   */
  declare optionalInt3264: number;

  /**
   * @generated from field: optional protobuf_unittest.TestAllTypes optional_all_types = 9;
   */
  optionalAllTypes?: TestAllTypes;

  /**
   * @generated from field: repeated protobuf_unittest.TestAllTypes repeated_all_types = 10;
   */
  repeatedAllTypes: TestAllTypes[] = [];

  constructor(data?: PartialMessage<TestVerifyMostlyInt32>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestVerifyMostlyInt32";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 30, name: "optional_int64_30", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 1, name: "optional_int32_1", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 2, name: "optional_int32_2", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 3, name: "optional_int32_3", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 4, name: "optional_int32_4", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 63, name: "optional_int32_63", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 64, name: "optional_int32_64", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 9, name: "optional_all_types", kind: "message", T: TestAllTypes, opt: true },
    { no: 10, name: "repeated_all_types", kind: "message", T: TestAllTypes, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestVerifyMostlyInt32 {
    return new TestVerifyMostlyInt32().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestVerifyMostlyInt32 {
    return new TestVerifyMostlyInt32().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestVerifyMostlyInt32 {
    return new TestVerifyMostlyInt32().fromJsonString(jsonString, options);
  }

  static equals(a: TestVerifyMostlyInt32 | PlainMessage<TestVerifyMostlyInt32> | undefined, b: TestVerifyMostlyInt32 | PlainMessage<TestVerifyMostlyInt32> | undefined): boolean {
    return proto2.util.equals(TestVerifyMostlyInt32, a, b);
  }
}

TestVerifyMostlyInt32.prototype.optionalInt6430 = protoInt64.zero;
TestVerifyMostlyInt32.prototype.optionalInt321 = 0;
TestVerifyMostlyInt32.prototype.optionalInt322 = 0;
TestVerifyMostlyInt32.prototype.optionalInt323 = 0;
TestVerifyMostlyInt32.prototype.optionalInt324 = 0;
TestVerifyMostlyInt32.prototype.optionalInt3263 = 0;
TestVerifyMostlyInt32.prototype.optionalInt3264 = 0;

/**
 * @generated from message protobuf_unittest.TestVerifyMostlyInt32BigFieldNumber
 */
export class TestVerifyMostlyInt32BigFieldNumber extends Message<TestVerifyMostlyInt32BigFieldNumber> {
  /**
   * @generated from field: optional int64 optional_int64_30 = 30;
   */
  declare optionalInt6430: bigint;

  /**
   * @generated from field: optional int32 optional_int32_300 = 300;
   */
  declare optionalInt32300: number;

  /**
   * @generated from field: optional int32 optional_int32_1 = 1;
   */
  declare optionalInt321: number;

  /**
   * @generated from field: optional int32 optional_int32_2 = 2;
   */
  declare optionalInt322: number;

  /**
   * @generated from field: optional int32 optional_int32_3 = 3;
   */
  declare optionalInt323: number;

  /**
   * @generated from field: optional int32 optional_int32_4 = 4;
   */
  declare optionalInt324: number;

  /**
   * @generated from field: optional int32 optional_int32_63 = 63;
   */
  declare optionalInt3263: number;

  /**
   * @generated from field: optional int32 optional_int32_64 = 64;
   */
  declare optionalInt3264: number;

  /**
   * @generated from field: optional protobuf_unittest.TestAllTypes optional_all_types = 9;
   */
  optionalAllTypes?: TestAllTypes;

  /**
   * @generated from field: repeated protobuf_unittest.TestAllTypes repeated_all_types = 10;
   */
  repeatedAllTypes: TestAllTypes[] = [];

  constructor(data?: PartialMessage<TestVerifyMostlyInt32BigFieldNumber>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestVerifyMostlyInt32BigFieldNumber";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 30, name: "optional_int64_30", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 300, name: "optional_int32_300", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 1, name: "optional_int32_1", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 2, name: "optional_int32_2", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 3, name: "optional_int32_3", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 4, name: "optional_int32_4", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 63, name: "optional_int32_63", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 64, name: "optional_int32_64", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 9, name: "optional_all_types", kind: "message", T: TestAllTypes, opt: true },
    { no: 10, name: "repeated_all_types", kind: "message", T: TestAllTypes, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestVerifyMostlyInt32BigFieldNumber {
    return new TestVerifyMostlyInt32BigFieldNumber().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestVerifyMostlyInt32BigFieldNumber {
    return new TestVerifyMostlyInt32BigFieldNumber().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestVerifyMostlyInt32BigFieldNumber {
    return new TestVerifyMostlyInt32BigFieldNumber().fromJsonString(jsonString, options);
  }

  static equals(a: TestVerifyMostlyInt32BigFieldNumber | PlainMessage<TestVerifyMostlyInt32BigFieldNumber> | undefined, b: TestVerifyMostlyInt32BigFieldNumber | PlainMessage<TestVerifyMostlyInt32BigFieldNumber> | undefined): boolean {
    return proto2.util.equals(TestVerifyMostlyInt32BigFieldNumber, a, b);
  }
}

TestVerifyMostlyInt32BigFieldNumber.prototype.optionalInt6430 = protoInt64.zero;
TestVerifyMostlyInt32BigFieldNumber.prototype.optionalInt32300 = 0;
TestVerifyMostlyInt32BigFieldNumber.prototype.optionalInt321 = 0;
TestVerifyMostlyInt32BigFieldNumber.prototype.optionalInt322 = 0;
TestVerifyMostlyInt32BigFieldNumber.prototype.optionalInt323 = 0;
TestVerifyMostlyInt32BigFieldNumber.prototype.optionalInt324 = 0;
TestVerifyMostlyInt32BigFieldNumber.prototype.optionalInt3263 = 0;
TestVerifyMostlyInt32BigFieldNumber.prototype.optionalInt3264 = 0;

/**
 * @generated from message protobuf_unittest.TestVerifyUint32Simple
 */
export class TestVerifyUint32Simple extends Message<TestVerifyUint32Simple> {
  /**
   * @generated from field: optional uint32 optional_uint32_1 = 1;
   */
  declare optionalUint321: number;

  /**
   * @generated from field: optional uint32 optional_uint32_2 = 2;
   */
  declare optionalUint322: number;

  /**
   * @generated from field: optional uint32 optional_uint32_63 = 63;
   */
  declare optionalUint3263: number;

  /**
   * @generated from field: optional uint32 optional_uint32_64 = 64;
   */
  declare optionalUint3264: number;

  constructor(data?: PartialMessage<TestVerifyUint32Simple>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestVerifyUint32Simple";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "optional_uint32_1", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 2, name: "optional_uint32_2", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 63, name: "optional_uint32_63", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 64, name: "optional_uint32_64", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestVerifyUint32Simple {
    return new TestVerifyUint32Simple().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestVerifyUint32Simple {
    return new TestVerifyUint32Simple().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestVerifyUint32Simple {
    return new TestVerifyUint32Simple().fromJsonString(jsonString, options);
  }

  static equals(a: TestVerifyUint32Simple | PlainMessage<TestVerifyUint32Simple> | undefined, b: TestVerifyUint32Simple | PlainMessage<TestVerifyUint32Simple> | undefined): boolean {
    return proto2.util.equals(TestVerifyUint32Simple, a, b);
  }
}

TestVerifyUint32Simple.prototype.optionalUint321 = 0;
TestVerifyUint32Simple.prototype.optionalUint322 = 0;
TestVerifyUint32Simple.prototype.optionalUint3263 = 0;
TestVerifyUint32Simple.prototype.optionalUint3264 = 0;

/**
 * @generated from message protobuf_unittest.TestVerifyUint32
 */
export class TestVerifyUint32 extends Message<TestVerifyUint32> {
  /**
   * @generated from field: optional uint32 optional_uint32_1 = 1;
   */
  declare optionalUint321: number;

  /**
   * @generated from field: optional uint32 optional_uint32_2 = 2;
   */
  declare optionalUint322: number;

  /**
   * @generated from field: optional uint32 optional_uint32_63 = 63;
   */
  declare optionalUint3263: number;

  /**
   * @generated from field: optional uint32 optional_uint32_64 = 64;
   */
  declare optionalUint3264: number;

  /**
   * @generated from field: optional protobuf_unittest.TestAllTypes optional_all_types = 9;
   */
  optionalAllTypes?: TestAllTypes;

  /**
   * @generated from field: repeated protobuf_unittest.TestAllTypes repeated_all_types = 10;
   */
  repeatedAllTypes: TestAllTypes[] = [];

  constructor(data?: PartialMessage<TestVerifyUint32>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestVerifyUint32";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "optional_uint32_1", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 2, name: "optional_uint32_2", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 63, name: "optional_uint32_63", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 64, name: "optional_uint32_64", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 9, name: "optional_all_types", kind: "message", T: TestAllTypes, opt: true },
    { no: 10, name: "repeated_all_types", kind: "message", T: TestAllTypes, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestVerifyUint32 {
    return new TestVerifyUint32().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestVerifyUint32 {
    return new TestVerifyUint32().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestVerifyUint32 {
    return new TestVerifyUint32().fromJsonString(jsonString, options);
  }

  static equals(a: TestVerifyUint32 | PlainMessage<TestVerifyUint32> | undefined, b: TestVerifyUint32 | PlainMessage<TestVerifyUint32> | undefined): boolean {
    return proto2.util.equals(TestVerifyUint32, a, b);
  }
}

TestVerifyUint32.prototype.optionalUint321 = 0;
TestVerifyUint32.prototype.optionalUint322 = 0;
TestVerifyUint32.prototype.optionalUint3263 = 0;
TestVerifyUint32.prototype.optionalUint3264 = 0;

/**
 * @generated from message protobuf_unittest.TestVerifyOneUint32
 */
export class TestVerifyOneUint32 extends Message<TestVerifyOneUint32> {
  /**
   * @generated from field: optional uint32 optional_uint32_1 = 1;
   */
  declare optionalUint321: number;

  /**
   * @generated from field: optional int32 optional_int32_2 = 2;
   */
  declare optionalInt322: number;

  /**
   * @generated from field: optional int32 optional_int32_63 = 63;
   */
  declare optionalInt3263: number;

  /**
   * @generated from field: optional int32 optional_int32_64 = 64;
   */
  declare optionalInt3264: number;

  /**
   * @generated from field: optional protobuf_unittest.TestAllTypes optional_all_types = 9;
   */
  optionalAllTypes?: TestAllTypes;

  /**
   * @generated from field: repeated protobuf_unittest.TestAllTypes repeated_all_types = 10;
   */
  repeatedAllTypes: TestAllTypes[] = [];

  constructor(data?: PartialMessage<TestVerifyOneUint32>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestVerifyOneUint32";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "optional_uint32_1", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 2, name: "optional_int32_2", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 63, name: "optional_int32_63", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 64, name: "optional_int32_64", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 9, name: "optional_all_types", kind: "message", T: TestAllTypes, opt: true },
    { no: 10, name: "repeated_all_types", kind: "message", T: TestAllTypes, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestVerifyOneUint32 {
    return new TestVerifyOneUint32().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestVerifyOneUint32 {
    return new TestVerifyOneUint32().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestVerifyOneUint32 {
    return new TestVerifyOneUint32().fromJsonString(jsonString, options);
  }

  static equals(a: TestVerifyOneUint32 | PlainMessage<TestVerifyOneUint32> | undefined, b: TestVerifyOneUint32 | PlainMessage<TestVerifyOneUint32> | undefined): boolean {
    return proto2.util.equals(TestVerifyOneUint32, a, b);
  }
}

TestVerifyOneUint32.prototype.optionalUint321 = 0;
TestVerifyOneUint32.prototype.optionalInt322 = 0;
TestVerifyOneUint32.prototype.optionalInt3263 = 0;
TestVerifyOneUint32.prototype.optionalInt3264 = 0;

/**
 * @generated from message protobuf_unittest.TestVerifyOneInt32BigFieldNumber
 */
export class TestVerifyOneInt32BigFieldNumber extends Message<TestVerifyOneInt32BigFieldNumber> {
  /**
   * @generated from field: optional int32 optional_int32_65 = 65;
   */
  declare optionalInt3265: number;

  /**
   * @generated from field: optional int64 optional_int64_1 = 1;
   */
  declare optionalInt641: bigint;

  /**
   * @generated from field: optional int64 optional_int64_2 = 2;
   */
  declare optionalInt642: bigint;

  /**
   * @generated from field: optional int64 optional_int64_63 = 63;
   */
  declare optionalInt6463: bigint;

  /**
   * @generated from field: optional int64 optional_int64_64 = 64;
   */
  declare optionalInt6464: bigint;

  /**
   * @generated from field: optional protobuf_unittest.TestAllTypes optional_all_types = 9;
   */
  optionalAllTypes?: TestAllTypes;

  /**
   * @generated from field: repeated protobuf_unittest.TestAllTypes repeated_all_types = 10;
   */
  repeatedAllTypes: TestAllTypes[] = [];

  constructor(data?: PartialMessage<TestVerifyOneInt32BigFieldNumber>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestVerifyOneInt32BigFieldNumber";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 65, name: "optional_int32_65", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 1, name: "optional_int64_1", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 2, name: "optional_int64_2", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 63, name: "optional_int64_63", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 64, name: "optional_int64_64", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 9, name: "optional_all_types", kind: "message", T: TestAllTypes, opt: true },
    { no: 10, name: "repeated_all_types", kind: "message", T: TestAllTypes, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestVerifyOneInt32BigFieldNumber {
    return new TestVerifyOneInt32BigFieldNumber().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestVerifyOneInt32BigFieldNumber {
    return new TestVerifyOneInt32BigFieldNumber().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestVerifyOneInt32BigFieldNumber {
    return new TestVerifyOneInt32BigFieldNumber().fromJsonString(jsonString, options);
  }

  static equals(a: TestVerifyOneInt32BigFieldNumber | PlainMessage<TestVerifyOneInt32BigFieldNumber> | undefined, b: TestVerifyOneInt32BigFieldNumber | PlainMessage<TestVerifyOneInt32BigFieldNumber> | undefined): boolean {
    return proto2.util.equals(TestVerifyOneInt32BigFieldNumber, a, b);
  }
}

TestVerifyOneInt32BigFieldNumber.prototype.optionalInt3265 = 0;
TestVerifyOneInt32BigFieldNumber.prototype.optionalInt641 = protoInt64.zero;
TestVerifyOneInt32BigFieldNumber.prototype.optionalInt642 = protoInt64.zero;
TestVerifyOneInt32BigFieldNumber.prototype.optionalInt6463 = protoInt64.zero;
TestVerifyOneInt32BigFieldNumber.prototype.optionalInt6464 = protoInt64.zero;

/**
 * @generated from message protobuf_unittest.TestVerifyInt32BigFieldNumber
 */
export class TestVerifyInt32BigFieldNumber extends Message<TestVerifyInt32BigFieldNumber> {
  /**
   * @generated from field: optional int32 optional_int32_1000 = 1000;
   */
  declare optionalInt321000: number;

  /**
   * @generated from field: optional int32 optional_int32_65 = 65;
   */
  declare optionalInt3265: number;

  /**
   * @generated from field: optional int32 optional_int32_1 = 1;
   */
  declare optionalInt321: number;

  /**
   * @generated from field: optional int32 optional_int32_2 = 2;
   */
  declare optionalInt322: number;

  /**
   * @generated from field: optional int32 optional_int32_63 = 63;
   */
  declare optionalInt3263: number;

  /**
   * @generated from field: optional int32 optional_int32_64 = 64;
   */
  declare optionalInt3264: number;

  /**
   * @generated from field: optional protobuf_unittest.TestAllTypes optional_all_types = 9;
   */
  optionalAllTypes?: TestAllTypes;

  /**
   * @generated from field: repeated protobuf_unittest.TestAllTypes repeated_all_types = 10;
   */
  repeatedAllTypes: TestAllTypes[] = [];

  constructor(data?: PartialMessage<TestVerifyInt32BigFieldNumber>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestVerifyInt32BigFieldNumber";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1000, name: "optional_int32_1000", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 65, name: "optional_int32_65", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 1, name: "optional_int32_1", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 2, name: "optional_int32_2", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 63, name: "optional_int32_63", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 64, name: "optional_int32_64", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 9, name: "optional_all_types", kind: "message", T: TestAllTypes, opt: true },
    { no: 10, name: "repeated_all_types", kind: "message", T: TestAllTypes, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestVerifyInt32BigFieldNumber {
    return new TestVerifyInt32BigFieldNumber().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestVerifyInt32BigFieldNumber {
    return new TestVerifyInt32BigFieldNumber().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestVerifyInt32BigFieldNumber {
    return new TestVerifyInt32BigFieldNumber().fromJsonString(jsonString, options);
  }

  static equals(a: TestVerifyInt32BigFieldNumber | PlainMessage<TestVerifyInt32BigFieldNumber> | undefined, b: TestVerifyInt32BigFieldNumber | PlainMessage<TestVerifyInt32BigFieldNumber> | undefined): boolean {
    return proto2.util.equals(TestVerifyInt32BigFieldNumber, a, b);
  }
}

TestVerifyInt32BigFieldNumber.prototype.optionalInt321000 = 0;
TestVerifyInt32BigFieldNumber.prototype.optionalInt3265 = 0;
TestVerifyInt32BigFieldNumber.prototype.optionalInt321 = 0;
TestVerifyInt32BigFieldNumber.prototype.optionalInt322 = 0;
TestVerifyInt32BigFieldNumber.prototype.optionalInt3263 = 0;
TestVerifyInt32BigFieldNumber.prototype.optionalInt3264 = 0;

/**
 * @generated from message protobuf_unittest.TestVerifyUint32BigFieldNumber
 */
export class TestVerifyUint32BigFieldNumber extends Message<TestVerifyUint32BigFieldNumber> {
  /**
   * @generated from field: optional uint32 optional_uint32_1000 = 1000;
   */
  declare optionalUint321000: number;

  /**
   * @generated from field: optional uint32 optional_uint32_65 = 65;
   */
  declare optionalUint3265: number;

  /**
   * @generated from field: optional uint32 optional_uint32_1 = 1;
   */
  declare optionalUint321: number;

  /**
   * @generated from field: optional uint32 optional_uint32_2 = 2;
   */
  declare optionalUint322: number;

  /**
   * @generated from field: optional uint32 optional_uint32_63 = 63;
   */
  declare optionalUint3263: number;

  /**
   * @generated from field: optional uint32 optional_uint32_64 = 64;
   */
  declare optionalUint3264: number;

  /**
   * @generated from field: optional protobuf_unittest.TestAllTypes optional_all_types = 9;
   */
  optionalAllTypes?: TestAllTypes;

  /**
   * @generated from field: repeated protobuf_unittest.TestAllTypes repeated_all_types = 10;
   */
  repeatedAllTypes: TestAllTypes[] = [];

  constructor(data?: PartialMessage<TestVerifyUint32BigFieldNumber>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestVerifyUint32BigFieldNumber";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1000, name: "optional_uint32_1000", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 65, name: "optional_uint32_65", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 1, name: "optional_uint32_1", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 2, name: "optional_uint32_2", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 63, name: "optional_uint32_63", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 64, name: "optional_uint32_64", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 9, name: "optional_all_types", kind: "message", T: TestAllTypes, opt: true },
    { no: 10, name: "repeated_all_types", kind: "message", T: TestAllTypes, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestVerifyUint32BigFieldNumber {
    return new TestVerifyUint32BigFieldNumber().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestVerifyUint32BigFieldNumber {
    return new TestVerifyUint32BigFieldNumber().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestVerifyUint32BigFieldNumber {
    return new TestVerifyUint32BigFieldNumber().fromJsonString(jsonString, options);
  }

  static equals(a: TestVerifyUint32BigFieldNumber | PlainMessage<TestVerifyUint32BigFieldNumber> | undefined, b: TestVerifyUint32BigFieldNumber | PlainMessage<TestVerifyUint32BigFieldNumber> | undefined): boolean {
    return proto2.util.equals(TestVerifyUint32BigFieldNumber, a, b);
  }
}

TestVerifyUint32BigFieldNumber.prototype.optionalUint321000 = 0;
TestVerifyUint32BigFieldNumber.prototype.optionalUint3265 = 0;
TestVerifyUint32BigFieldNumber.prototype.optionalUint321 = 0;
TestVerifyUint32BigFieldNumber.prototype.optionalUint322 = 0;
TestVerifyUint32BigFieldNumber.prototype.optionalUint3263 = 0;
TestVerifyUint32BigFieldNumber.prototype.optionalUint3264 = 0;

/**
 * @generated from message protobuf_unittest.TestVerifyBigFieldNumberUint32
 */
export class TestVerifyBigFieldNumberUint32 extends Message<TestVerifyBigFieldNumberUint32> {
  /**
   * @generated from field: optional protobuf_unittest.TestVerifyBigFieldNumberUint32.Nested optional_nested = 1;
   */
  optionalNested?: TestVerifyBigFieldNumberUint32_Nested;

  constructor(data?: PartialMessage<TestVerifyBigFieldNumberUint32>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestVerifyBigFieldNumberUint32";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "optional_nested", kind: "message", T: TestVerifyBigFieldNumberUint32_Nested, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestVerifyBigFieldNumberUint32 {
    return new TestVerifyBigFieldNumberUint32().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestVerifyBigFieldNumberUint32 {
    return new TestVerifyBigFieldNumberUint32().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestVerifyBigFieldNumberUint32 {
    return new TestVerifyBigFieldNumberUint32().fromJsonString(jsonString, options);
  }

  static equals(a: TestVerifyBigFieldNumberUint32 | PlainMessage<TestVerifyBigFieldNumberUint32> | undefined, b: TestVerifyBigFieldNumberUint32 | PlainMessage<TestVerifyBigFieldNumberUint32> | undefined): boolean {
    return proto2.util.equals(TestVerifyBigFieldNumberUint32, a, b);
  }
}

/**
 * @generated from message protobuf_unittest.TestVerifyBigFieldNumberUint32.Nested
 */
export class TestVerifyBigFieldNumberUint32_Nested extends Message<TestVerifyBigFieldNumberUint32_Nested> {
  /**
   * @generated from field: optional uint32 optional_uint32_5000 = 5000;
   */
  declare optionalUint325000: number;

  /**
   * @generated from field: optional uint32 optional_uint32_1000 = 1000;
   */
  declare optionalUint321000: number;

  /**
   * @generated from field: optional uint32 optional_uint32_66 = 66;
   */
  declare optionalUint3266: number;

  /**
   * @generated from field: optional uint32 optional_uint32_65 = 65;
   */
  declare optionalUint3265: number;

  /**
   * @generated from field: optional uint32 optional_uint32_1 = 1;
   */
  declare optionalUint321: number;

  /**
   * @generated from field: optional uint32 optional_uint32_2 = 2;
   */
  declare optionalUint322: number;

  /**
   * @generated from field: optional uint32 optional_uint32_63 = 63;
   */
  declare optionalUint3263: number;

  /**
   * @generated from field: optional uint32 optional_uint32_64 = 64;
   */
  declare optionalUint3264: number;

  /**
   * @generated from field: optional protobuf_unittest.TestVerifyBigFieldNumberUint32.Nested optional_nested = 9;
   */
  optionalNested?: TestVerifyBigFieldNumberUint32_Nested;

  /**
   * @generated from field: repeated protobuf_unittest.TestVerifyBigFieldNumberUint32.Nested repeated_nested = 10;
   */
  repeatedNested: TestVerifyBigFieldNumberUint32_Nested[] = [];

  constructor(data?: PartialMessage<TestVerifyBigFieldNumberUint32_Nested>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestVerifyBigFieldNumberUint32.Nested";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 5000, name: "optional_uint32_5000", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 1000, name: "optional_uint32_1000", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 66, name: "optional_uint32_66", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 65, name: "optional_uint32_65", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 1, name: "optional_uint32_1", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 2, name: "optional_uint32_2", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 63, name: "optional_uint32_63", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 64, name: "optional_uint32_64", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 9, name: "optional_nested", kind: "message", T: TestVerifyBigFieldNumberUint32_Nested, opt: true },
    { no: 10, name: "repeated_nested", kind: "message", T: TestVerifyBigFieldNumberUint32_Nested, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestVerifyBigFieldNumberUint32_Nested {
    return new TestVerifyBigFieldNumberUint32_Nested().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestVerifyBigFieldNumberUint32_Nested {
    return new TestVerifyBigFieldNumberUint32_Nested().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestVerifyBigFieldNumberUint32_Nested {
    return new TestVerifyBigFieldNumberUint32_Nested().fromJsonString(jsonString, options);
  }

  static equals(a: TestVerifyBigFieldNumberUint32_Nested | PlainMessage<TestVerifyBigFieldNumberUint32_Nested> | undefined, b: TestVerifyBigFieldNumberUint32_Nested | PlainMessage<TestVerifyBigFieldNumberUint32_Nested> | undefined): boolean {
    return proto2.util.equals(TestVerifyBigFieldNumberUint32_Nested, a, b);
  }
}

TestVerifyBigFieldNumberUint32_Nested.prototype.optionalUint325000 = 0;
TestVerifyBigFieldNumberUint32_Nested.prototype.optionalUint321000 = 0;
TestVerifyBigFieldNumberUint32_Nested.prototype.optionalUint3266 = 0;
TestVerifyBigFieldNumberUint32_Nested.prototype.optionalUint3265 = 0;
TestVerifyBigFieldNumberUint32_Nested.prototype.optionalUint321 = 0;
TestVerifyBigFieldNumberUint32_Nested.prototype.optionalUint322 = 0;
TestVerifyBigFieldNumberUint32_Nested.prototype.optionalUint3263 = 0;
TestVerifyBigFieldNumberUint32_Nested.prototype.optionalUint3264 = 0;

/**
 * This message contains different kind of enums to exercise the different
 * parsers in table-driven.
 *
 * @generated from message protobuf_unittest.EnumParseTester
 */
export class EnumParseTester extends Message<EnumParseTester> {
  /**
   * @generated from field: optional protobuf_unittest.EnumParseTester.SeqSmall0 optional_seq_small_0_lowfield = 1;
   */
  declare optionalSeqSmall0Lowfield: EnumParseTester_SeqSmall0;

  /**
   * @generated from field: optional protobuf_unittest.EnumParseTester.SeqSmall0 optional_seq_small_0_midfield = 1001;
   */
  declare optionalSeqSmall0Midfield: EnumParseTester_SeqSmall0;

  /**
   * @generated from field: optional protobuf_unittest.EnumParseTester.SeqSmall0 optional_seq_small_0_hifield = 1000001;
   */
  declare optionalSeqSmall0Hifield: EnumParseTester_SeqSmall0;

  /**
   * @generated from field: repeated protobuf_unittest.EnumParseTester.SeqSmall0 repeated_seq_small_0_lowfield = 2;
   */
  repeatedSeqSmall0Lowfield: EnumParseTester_SeqSmall0[] = [];

  /**
   * @generated from field: repeated protobuf_unittest.EnumParseTester.SeqSmall0 repeated_seq_small_0_midfield = 1002;
   */
  repeatedSeqSmall0Midfield: EnumParseTester_SeqSmall0[] = [];

  /**
   * @generated from field: repeated protobuf_unittest.EnumParseTester.SeqSmall0 repeated_seq_small_0_hifield = 1000002;
   */
  repeatedSeqSmall0Hifield: EnumParseTester_SeqSmall0[] = [];

  /**
   * @generated from field: repeated protobuf_unittest.EnumParseTester.SeqSmall0 packed_seq_small_0_lowfield = 3 [packed = true];
   */
  packedSeqSmall0Lowfield: EnumParseTester_SeqSmall0[] = [];

  /**
   * @generated from field: repeated protobuf_unittest.EnumParseTester.SeqSmall0 packed_seq_small_0_midfield = 1003 [packed = true];
   */
  packedSeqSmall0Midfield: EnumParseTester_SeqSmall0[] = [];

  /**
   * @generated from field: repeated protobuf_unittest.EnumParseTester.SeqSmall0 packed_seq_small_0_hifield = 1000003 [packed = true];
   */
  packedSeqSmall0Hifield: EnumParseTester_SeqSmall0[] = [];

  /**
   * @generated from field: optional protobuf_unittest.EnumParseTester.SeqSmall1 optional_seq_small_1_lowfield = 4;
   */
  declare optionalSeqSmall1Lowfield: EnumParseTester_SeqSmall1;

  /**
   * @generated from field: optional protobuf_unittest.EnumParseTester.SeqSmall1 optional_seq_small_1_midfield = 1004;
   */
  declare optionalSeqSmall1Midfield: EnumParseTester_SeqSmall1;

  /**
   * @generated from field: optional protobuf_unittest.EnumParseTester.SeqSmall1 optional_seq_small_1_hifield = 1000004;
   */
  declare optionalSeqSmall1Hifield: EnumParseTester_SeqSmall1;

  /**
   * @generated from field: repeated protobuf_unittest.EnumParseTester.SeqSmall1 repeated_seq_small_1_lowfield = 5;
   */
  repeatedSeqSmall1Lowfield: EnumParseTester_SeqSmall1[] = [];

  /**
   * @generated from field: repeated protobuf_unittest.EnumParseTester.SeqSmall1 repeated_seq_small_1_midfield = 1005;
   */
  repeatedSeqSmall1Midfield: EnumParseTester_SeqSmall1[] = [];

  /**
   * @generated from field: repeated protobuf_unittest.EnumParseTester.SeqSmall1 repeated_seq_small_1_hifield = 1000005;
   */
  repeatedSeqSmall1Hifield: EnumParseTester_SeqSmall1[] = [];

  /**
   * @generated from field: repeated protobuf_unittest.EnumParseTester.SeqSmall1 packed_seq_small_1_lowfield = 6 [packed = true];
   */
  packedSeqSmall1Lowfield: EnumParseTester_SeqSmall1[] = [];

  /**
   * @generated from field: repeated protobuf_unittest.EnumParseTester.SeqSmall1 packed_seq_small_1_midfield = 1006 [packed = true];
   */
  packedSeqSmall1Midfield: EnumParseTester_SeqSmall1[] = [];

  /**
   * @generated from field: repeated protobuf_unittest.EnumParseTester.SeqSmall1 packed_seq_small_1_hifield = 1000006 [packed = true];
   */
  packedSeqSmall1Hifield: EnumParseTester_SeqSmall1[] = [];

  /**
   * @generated from field: optional protobuf_unittest.EnumParseTester.SeqLarge optional_seq_large_lowfield = 7;
   */
  declare optionalSeqLargeLowfield: EnumParseTester_SeqLarge;

  /**
   * @generated from field: optional protobuf_unittest.EnumParseTester.SeqLarge optional_seq_large_midfield = 1007;
   */
  declare optionalSeqLargeMidfield: EnumParseTester_SeqLarge;

  /**
   * @generated from field: optional protobuf_unittest.EnumParseTester.SeqLarge optional_seq_large_hifield = 1000007;
   */
  declare optionalSeqLargeHifield: EnumParseTester_SeqLarge;

  /**
   * @generated from field: repeated protobuf_unittest.EnumParseTester.SeqLarge repeated_seq_large_lowfield = 8;
   */
  repeatedSeqLargeLowfield: EnumParseTester_SeqLarge[] = [];

  /**
   * @generated from field: repeated protobuf_unittest.EnumParseTester.SeqLarge repeated_seq_large_midfield = 1008;
   */
  repeatedSeqLargeMidfield: EnumParseTester_SeqLarge[] = [];

  /**
   * @generated from field: repeated protobuf_unittest.EnumParseTester.SeqLarge repeated_seq_large_hifield = 1000008;
   */
  repeatedSeqLargeHifield: EnumParseTester_SeqLarge[] = [];

  /**
   * @generated from field: repeated protobuf_unittest.EnumParseTester.SeqLarge packed_seq_large_lowfield = 9 [packed = true];
   */
  packedSeqLargeLowfield: EnumParseTester_SeqLarge[] = [];

  /**
   * @generated from field: repeated protobuf_unittest.EnumParseTester.SeqLarge packed_seq_large_midfield = 1009 [packed = true];
   */
  packedSeqLargeMidfield: EnumParseTester_SeqLarge[] = [];

  /**
   * @generated from field: repeated protobuf_unittest.EnumParseTester.SeqLarge packed_seq_large_hifield = 1000009 [packed = true];
   */
  packedSeqLargeHifield: EnumParseTester_SeqLarge[] = [];

  /**
   * @generated from field: optional protobuf_unittest.EnumParseTester.Arbitrary optional_arbitrary_lowfield = 10;
   */
  declare optionalArbitraryLowfield: EnumParseTester_Arbitrary;

  /**
   * @generated from field: optional protobuf_unittest.EnumParseTester.Arbitrary optional_arbitrary_midfield = 1010;
   */
  declare optionalArbitraryMidfield: EnumParseTester_Arbitrary;

  /**
   * @generated from field: optional protobuf_unittest.EnumParseTester.Arbitrary optional_arbitrary_hifield = 1000010;
   */
  declare optionalArbitraryHifield: EnumParseTester_Arbitrary;

  /**
   * @generated from field: repeated protobuf_unittest.EnumParseTester.Arbitrary repeated_arbitrary_lowfield = 11;
   */
  repeatedArbitraryLowfield: EnumParseTester_Arbitrary[] = [];

  /**
   * @generated from field: repeated protobuf_unittest.EnumParseTester.Arbitrary repeated_arbitrary_midfield = 1011;
   */
  repeatedArbitraryMidfield: EnumParseTester_Arbitrary[] = [];

  /**
   * @generated from field: repeated protobuf_unittest.EnumParseTester.Arbitrary repeated_arbitrary_hifield = 1000011;
   */
  repeatedArbitraryHifield: EnumParseTester_Arbitrary[] = [];

  /**
   * @generated from field: repeated protobuf_unittest.EnumParseTester.Arbitrary packed_arbitrary_lowfield = 12 [packed = true];
   */
  packedArbitraryLowfield: EnumParseTester_Arbitrary[] = [];

  /**
   * @generated from field: repeated protobuf_unittest.EnumParseTester.Arbitrary packed_arbitrary_midfield = 1012 [packed = true];
   */
  packedArbitraryMidfield: EnumParseTester_Arbitrary[] = [];

  /**
   * @generated from field: repeated protobuf_unittest.EnumParseTester.Arbitrary packed_arbitrary_hifield = 1000012 [packed = true];
   */
  packedArbitraryHifield: EnumParseTester_Arbitrary[] = [];

  /**
   * An arbitrary field we can append to to break the runs of repeated fields.
   *
   * @generated from field: optional int32 other_field = 99;
   */
  declare otherField: number;

  constructor(data?: PartialMessage<EnumParseTester>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.EnumParseTester";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "optional_seq_small_0_lowfield", kind: "enum", T: proto2.getEnumType(EnumParseTester_SeqSmall0), opt: true },
    { no: 1001, name: "optional_seq_small_0_midfield", kind: "enum", T: proto2.getEnumType(EnumParseTester_SeqSmall0), opt: true },
    { no: 1000001, name: "optional_seq_small_0_hifield", kind: "enum", T: proto2.getEnumType(EnumParseTester_SeqSmall0), opt: true },
    { no: 2, name: "repeated_seq_small_0_lowfield", kind: "enum", T: proto2.getEnumType(EnumParseTester_SeqSmall0), repeated: true },
    { no: 1002, name: "repeated_seq_small_0_midfield", kind: "enum", T: proto2.getEnumType(EnumParseTester_SeqSmall0), repeated: true },
    { no: 1000002, name: "repeated_seq_small_0_hifield", kind: "enum", T: proto2.getEnumType(EnumParseTester_SeqSmall0), repeated: true },
    { no: 3, name: "packed_seq_small_0_lowfield", kind: "enum", T: proto2.getEnumType(EnumParseTester_SeqSmall0), repeated: true, packed: true },
    { no: 1003, name: "packed_seq_small_0_midfield", kind: "enum", T: proto2.getEnumType(EnumParseTester_SeqSmall0), repeated: true, packed: true },
    { no: 1000003, name: "packed_seq_small_0_hifield", kind: "enum", T: proto2.getEnumType(EnumParseTester_SeqSmall0), repeated: true, packed: true },
    { no: 4, name: "optional_seq_small_1_lowfield", kind: "enum", T: proto2.getEnumType(EnumParseTester_SeqSmall1), opt: true },
    { no: 1004, name: "optional_seq_small_1_midfield", kind: "enum", T: proto2.getEnumType(EnumParseTester_SeqSmall1), opt: true },
    { no: 1000004, name: "optional_seq_small_1_hifield", kind: "enum", T: proto2.getEnumType(EnumParseTester_SeqSmall1), opt: true },
    { no: 5, name: "repeated_seq_small_1_lowfield", kind: "enum", T: proto2.getEnumType(EnumParseTester_SeqSmall1), repeated: true },
    { no: 1005, name: "repeated_seq_small_1_midfield", kind: "enum", T: proto2.getEnumType(EnumParseTester_SeqSmall1), repeated: true },
    { no: 1000005, name: "repeated_seq_small_1_hifield", kind: "enum", T: proto2.getEnumType(EnumParseTester_SeqSmall1), repeated: true },
    { no: 6, name: "packed_seq_small_1_lowfield", kind: "enum", T: proto2.getEnumType(EnumParseTester_SeqSmall1), repeated: true, packed: true },
    { no: 1006, name: "packed_seq_small_1_midfield", kind: "enum", T: proto2.getEnumType(EnumParseTester_SeqSmall1), repeated: true, packed: true },
    { no: 1000006, name: "packed_seq_small_1_hifield", kind: "enum", T: proto2.getEnumType(EnumParseTester_SeqSmall1), repeated: true, packed: true },
    { no: 7, name: "optional_seq_large_lowfield", kind: "enum", T: proto2.getEnumType(EnumParseTester_SeqLarge), opt: true },
    { no: 1007, name: "optional_seq_large_midfield", kind: "enum", T: proto2.getEnumType(EnumParseTester_SeqLarge), opt: true },
    { no: 1000007, name: "optional_seq_large_hifield", kind: "enum", T: proto2.getEnumType(EnumParseTester_SeqLarge), opt: true },
    { no: 8, name: "repeated_seq_large_lowfield", kind: "enum", T: proto2.getEnumType(EnumParseTester_SeqLarge), repeated: true },
    { no: 1008, name: "repeated_seq_large_midfield", kind: "enum", T: proto2.getEnumType(EnumParseTester_SeqLarge), repeated: true },
    { no: 1000008, name: "repeated_seq_large_hifield", kind: "enum", T: proto2.getEnumType(EnumParseTester_SeqLarge), repeated: true },
    { no: 9, name: "packed_seq_large_lowfield", kind: "enum", T: proto2.getEnumType(EnumParseTester_SeqLarge), repeated: true, packed: true },
    { no: 1009, name: "packed_seq_large_midfield", kind: "enum", T: proto2.getEnumType(EnumParseTester_SeqLarge), repeated: true, packed: true },
    { no: 1000009, name: "packed_seq_large_hifield", kind: "enum", T: proto2.getEnumType(EnumParseTester_SeqLarge), repeated: true, packed: true },
    { no: 10, name: "optional_arbitrary_lowfield", kind: "enum", T: proto2.getEnumType(EnumParseTester_Arbitrary), opt: true },
    { no: 1010, name: "optional_arbitrary_midfield", kind: "enum", T: proto2.getEnumType(EnumParseTester_Arbitrary), opt: true },
    { no: 1000010, name: "optional_arbitrary_hifield", kind: "enum", T: proto2.getEnumType(EnumParseTester_Arbitrary), opt: true },
    { no: 11, name: "repeated_arbitrary_lowfield", kind: "enum", T: proto2.getEnumType(EnumParseTester_Arbitrary), repeated: true },
    { no: 1011, name: "repeated_arbitrary_midfield", kind: "enum", T: proto2.getEnumType(EnumParseTester_Arbitrary), repeated: true },
    { no: 1000011, name: "repeated_arbitrary_hifield", kind: "enum", T: proto2.getEnumType(EnumParseTester_Arbitrary), repeated: true },
    { no: 12, name: "packed_arbitrary_lowfield", kind: "enum", T: proto2.getEnumType(EnumParseTester_Arbitrary), repeated: true, packed: true },
    { no: 1012, name: "packed_arbitrary_midfield", kind: "enum", T: proto2.getEnumType(EnumParseTester_Arbitrary), repeated: true, packed: true },
    { no: 1000012, name: "packed_arbitrary_hifield", kind: "enum", T: proto2.getEnumType(EnumParseTester_Arbitrary), repeated: true, packed: true },
    { no: 99, name: "other_field", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EnumParseTester {
    return new EnumParseTester().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EnumParseTester {
    return new EnumParseTester().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EnumParseTester {
    return new EnumParseTester().fromJsonString(jsonString, options);
  }

  static equals(a: EnumParseTester | PlainMessage<EnumParseTester> | undefined, b: EnumParseTester | PlainMessage<EnumParseTester> | undefined): boolean {
    return proto2.util.equals(EnumParseTester, a, b);
  }
}

EnumParseTester.prototype.optionalSeqSmall0Lowfield = 0 as EnumParseTester_SeqSmall0.SEQ_SMALL_0_DEFAULT;
EnumParseTester.prototype.optionalSeqSmall0Midfield = 0 as EnumParseTester_SeqSmall0.SEQ_SMALL_0_DEFAULT;
EnumParseTester.prototype.optionalSeqSmall0Hifield = 0 as EnumParseTester_SeqSmall0.SEQ_SMALL_0_DEFAULT;
EnumParseTester.prototype.optionalSeqSmall1Lowfield = 1 as EnumParseTester_SeqSmall1.SEQ_SMALL_1_DEFAULT;
EnumParseTester.prototype.optionalSeqSmall1Midfield = 1 as EnumParseTester_SeqSmall1.SEQ_SMALL_1_DEFAULT;
EnumParseTester.prototype.optionalSeqSmall1Hifield = 1 as EnumParseTester_SeqSmall1.SEQ_SMALL_1_DEFAULT;
EnumParseTester.prototype.optionalSeqLargeLowfield = -1 as EnumParseTester_SeqLarge.SEQ_LARGE_DEFAULT;
EnumParseTester.prototype.optionalSeqLargeMidfield = -1 as EnumParseTester_SeqLarge.SEQ_LARGE_DEFAULT;
EnumParseTester.prototype.optionalSeqLargeHifield = -1 as EnumParseTester_SeqLarge.SEQ_LARGE_DEFAULT;
EnumParseTester.prototype.optionalArbitraryLowfield = -123123 as EnumParseTester_Arbitrary.ARBITRARY_DEFAULT;
EnumParseTester.prototype.optionalArbitraryMidfield = -123123 as EnumParseTester_Arbitrary.ARBITRARY_DEFAULT;
EnumParseTester.prototype.optionalArbitraryHifield = -123123 as EnumParseTester_Arbitrary.ARBITRARY_DEFAULT;
EnumParseTester.prototype.otherField = 0;

/**
 * @generated from enum protobuf_unittest.EnumParseTester.SeqSmall0
 */
export enum EnumParseTester_SeqSmall0 {
  /**
   * @generated from enum value: SEQ_SMALL_0_DEFAULT = 0;
   */
  SEQ_SMALL_0_DEFAULT = 0,

  /**
   * @generated from enum value: SEQ_SMALL_0_1 = 1;
   */
  SEQ_SMALL_0_1 = 1,

  /**
   * @generated from enum value: SEQ_SMALL_0_2 = 2;
   */
  SEQ_SMALL_0_2 = 2,
}
// Retrieve enum metadata with: proto2.getEnumType(EnumParseTester_SeqSmall0)
proto2.util.setEnumType(EnumParseTester_SeqSmall0, "protobuf_unittest.EnumParseTester.SeqSmall0", [
  { no: 0, name: "SEQ_SMALL_0_DEFAULT" },
  { no: 1, name: "SEQ_SMALL_0_1" },
  { no: 2, name: "SEQ_SMALL_0_2" },
]);

/**
 * @generated from enum protobuf_unittest.EnumParseTester.SeqSmall1
 */
export enum EnumParseTester_SeqSmall1 {
  /**
   * @generated from enum value: SEQ_SMALL_1_DEFAULT = 1;
   */
  SEQ_SMALL_1_DEFAULT = 1,

  /**
   * @generated from enum value: SEQ_SMALL_1_2 = 2;
   */
  SEQ_SMALL_1_2 = 2,

  /**
   * @generated from enum value: SEQ_SMALL_1_3 = 3;
   */
  SEQ_SMALL_1_3 = 3,
}
// Retrieve enum metadata with: proto2.getEnumType(EnumParseTester_SeqSmall1)
proto2.util.setEnumType(EnumParseTester_SeqSmall1, "protobuf_unittest.EnumParseTester.SeqSmall1", [
  { no: 1, name: "SEQ_SMALL_1_DEFAULT" },
  { no: 2, name: "SEQ_SMALL_1_2" },
  { no: 3, name: "SEQ_SMALL_1_3" },
]);

/**
 * @generated from enum protobuf_unittest.EnumParseTester.SeqLarge
 */
export enum EnumParseTester_SeqLarge {
  /**
   * @generated from enum value: SEQ_LARGE_DEFAULT = -1;
   */
  SEQ_LARGE_DEFAULT = -1,

  /**
   * @generated from enum value: SEQ_LARGE_0 = 0;
   */
  SEQ_LARGE_0 = 0,

  /**
   * @generated from enum value: SEQ_LARGE_1 = 1;
   */
  SEQ_LARGE_1 = 1,

  /**
   * @generated from enum value: SEQ_LARGE_2 = 2;
   */
  SEQ_LARGE_2 = 2,

  /**
   * @generated from enum value: SEQ_LARGE_3 = 3;
   */
  SEQ_LARGE_3 = 3,

  /**
   * @generated from enum value: SEQ_LARGE_4 = 4;
   */
  SEQ_LARGE_4 = 4,

  /**
   * @generated from enum value: SEQ_LARGE_5 = 5;
   */
  SEQ_LARGE_5 = 5,

  /**
   * @generated from enum value: SEQ_LARGE_6 = 6;
   */
  SEQ_LARGE_6 = 6,

  /**
   * @generated from enum value: SEQ_LARGE_7 = 7;
   */
  SEQ_LARGE_7 = 7,

  /**
   * @generated from enum value: SEQ_LARGE_8 = 8;
   */
  SEQ_LARGE_8 = 8,

  /**
   * @generated from enum value: SEQ_LARGE_9 = 9;
   */
  SEQ_LARGE_9 = 9,

  /**
   * @generated from enum value: SEQ_LARGE_10 = 10;
   */
  SEQ_LARGE_10 = 10,

  /**
   * @generated from enum value: SEQ_LARGE_11 = 11;
   */
  SEQ_LARGE_11 = 11,

  /**
   * @generated from enum value: SEQ_LARGE_12 = 12;
   */
  SEQ_LARGE_12 = 12,

  /**
   * @generated from enum value: SEQ_LARGE_13 = 13;
   */
  SEQ_LARGE_13 = 13,

  /**
   * @generated from enum value: SEQ_LARGE_14 = 14;
   */
  SEQ_LARGE_14 = 14,

  /**
   * @generated from enum value: SEQ_LARGE_15 = 15;
   */
  SEQ_LARGE_15 = 15,

  /**
   * @generated from enum value: SEQ_LARGE_16 = 16;
   */
  SEQ_LARGE_16 = 16,

  /**
   * @generated from enum value: SEQ_LARGE_17 = 17;
   */
  SEQ_LARGE_17 = 17,

  /**
   * @generated from enum value: SEQ_LARGE_18 = 18;
   */
  SEQ_LARGE_18 = 18,

  /**
   * @generated from enum value: SEQ_LARGE_19 = 19;
   */
  SEQ_LARGE_19 = 19,

  /**
   * @generated from enum value: SEQ_LARGE_20 = 20;
   */
  SEQ_LARGE_20 = 20,

  /**
   * @generated from enum value: SEQ_LARGE_21 = 21;
   */
  SEQ_LARGE_21 = 21,

  /**
   * @generated from enum value: SEQ_LARGE_22 = 22;
   */
  SEQ_LARGE_22 = 22,

  /**
   * @generated from enum value: SEQ_LARGE_23 = 23;
   */
  SEQ_LARGE_23 = 23,

  /**
   * @generated from enum value: SEQ_LARGE_24 = 24;
   */
  SEQ_LARGE_24 = 24,

  /**
   * @generated from enum value: SEQ_LARGE_25 = 25;
   */
  SEQ_LARGE_25 = 25,

  /**
   * @generated from enum value: SEQ_LARGE_26 = 26;
   */
  SEQ_LARGE_26 = 26,

  /**
   * @generated from enum value: SEQ_LARGE_27 = 27;
   */
  SEQ_LARGE_27 = 27,

  /**
   * @generated from enum value: SEQ_LARGE_28 = 28;
   */
  SEQ_LARGE_28 = 28,

  /**
   * @generated from enum value: SEQ_LARGE_29 = 29;
   */
  SEQ_LARGE_29 = 29,

  /**
   * @generated from enum value: SEQ_LARGE_30 = 30;
   */
  SEQ_LARGE_30 = 30,

  /**
   * @generated from enum value: SEQ_LARGE_31 = 31;
   */
  SEQ_LARGE_31 = 31,

  /**
   * @generated from enum value: SEQ_LARGE_32 = 32;
   */
  SEQ_LARGE_32 = 32,

  /**
   * @generated from enum value: SEQ_LARGE_33 = 33;
   */
  SEQ_LARGE_33 = 33,
}
// Retrieve enum metadata with: proto2.getEnumType(EnumParseTester_SeqLarge)
proto2.util.setEnumType(EnumParseTester_SeqLarge, "protobuf_unittest.EnumParseTester.SeqLarge", [
  { no: -1, name: "SEQ_LARGE_DEFAULT" },
  { no: 0, name: "SEQ_LARGE_0" },
  { no: 1, name: "SEQ_LARGE_1" },
  { no: 2, name: "SEQ_LARGE_2" },
  { no: 3, name: "SEQ_LARGE_3" },
  { no: 4, name: "SEQ_LARGE_4" },
  { no: 5, name: "SEQ_LARGE_5" },
  { no: 6, name: "SEQ_LARGE_6" },
  { no: 7, name: "SEQ_LARGE_7" },
  { no: 8, name: "SEQ_LARGE_8" },
  { no: 9, name: "SEQ_LARGE_9" },
  { no: 10, name: "SEQ_LARGE_10" },
  { no: 11, name: "SEQ_LARGE_11" },
  { no: 12, name: "SEQ_LARGE_12" },
  { no: 13, name: "SEQ_LARGE_13" },
  { no: 14, name: "SEQ_LARGE_14" },
  { no: 15, name: "SEQ_LARGE_15" },
  { no: 16, name: "SEQ_LARGE_16" },
  { no: 17, name: "SEQ_LARGE_17" },
  { no: 18, name: "SEQ_LARGE_18" },
  { no: 19, name: "SEQ_LARGE_19" },
  { no: 20, name: "SEQ_LARGE_20" },
  { no: 21, name: "SEQ_LARGE_21" },
  { no: 22, name: "SEQ_LARGE_22" },
  { no: 23, name: "SEQ_LARGE_23" },
  { no: 24, name: "SEQ_LARGE_24" },
  { no: 25, name: "SEQ_LARGE_25" },
  { no: 26, name: "SEQ_LARGE_26" },
  { no: 27, name: "SEQ_LARGE_27" },
  { no: 28, name: "SEQ_LARGE_28" },
  { no: 29, name: "SEQ_LARGE_29" },
  { no: 30, name: "SEQ_LARGE_30" },
  { no: 31, name: "SEQ_LARGE_31" },
  { no: 32, name: "SEQ_LARGE_32" },
  { no: 33, name: "SEQ_LARGE_33" },
]);

/**
 * @generated from enum protobuf_unittest.EnumParseTester.Arbitrary
 */
export enum EnumParseTester_Arbitrary {
  /**
   * @generated from enum value: ARBITRARY_DEFAULT = -123123;
   */
  ARBITRARY_DEFAULT = -123123,

  /**
   * @generated from enum value: ARBITRARY_1 = -123;
   */
  ARBITRARY_1 = -123,

  /**
   * @generated from enum value: ARBITRARY_2 = 213;
   */
  ARBITRARY_2 = 213,

  /**
   * @generated from enum value: ARBITRARY_3 = 213213;
   */
  ARBITRARY_3 = 213213,

  /**
   * @generated from enum value: ARBITRARY_MIN = -2147483648;
   */
  ARBITRARY_MIN = -2147483648,

  /**
   * @generated from enum value: ARBITRARY_MAX = 2147483647;
   */
  ARBITRARY_MAX = 2147483647,
}
// Retrieve enum metadata with: proto2.getEnumType(EnumParseTester_Arbitrary)
proto2.util.setEnumType(EnumParseTester_Arbitrary, "protobuf_unittest.EnumParseTester.Arbitrary", [
  { no: -123123, name: "ARBITRARY_DEFAULT" },
  { no: -123, name: "ARBITRARY_1" },
  { no: 213, name: "ARBITRARY_2" },
  { no: 213213, name: "ARBITRARY_3" },
  { no: -2147483648, name: "ARBITRARY_MIN" },
  { no: 2147483647, name: "ARBITRARY_MAX" },
]);

/**
 * @generated from extension: optional protobuf_unittest.EnumParseTester.Arbitrary optional_arbitrary_ext = 2000000;
 */
export const EnumParseTester_optional_arbitrary_ext = proto2.makeExtension<EnumParseTester, EnumParseTester_Arbitrary>(
  "protobuf_unittest.EnumParseTester.optional_arbitrary_ext", 
  EnumParseTester, 
  () => ({ no: 2000000, kind: "enum", T: proto2.getEnumType(EnumParseTester_Arbitrary), opt: true }),
);

/**
 * @generated from extension: repeated protobuf_unittest.EnumParseTester.Arbitrary repeated_arbitrary_ext = 2000001;
 */
export const EnumParseTester_repeated_arbitrary_ext = proto2.makeExtension<EnumParseTester, EnumParseTester_Arbitrary[]>(
  "protobuf_unittest.EnumParseTester.repeated_arbitrary_ext", 
  EnumParseTester, 
  () => ({ no: 2000001, kind: "enum", T: proto2.getEnumType(EnumParseTester_Arbitrary), repeated: true }),
);

/**
 * @generated from extension: repeated protobuf_unittest.EnumParseTester.Arbitrary packed_arbitrary_ext = 2000002 [packed = true];
 */
export const EnumParseTester_packed_arbitrary_ext = proto2.makeExtension<EnumParseTester, EnumParseTester_Arbitrary[]>(
  "protobuf_unittest.EnumParseTester.packed_arbitrary_ext", 
  EnumParseTester, 
  () => ({ no: 2000002, kind: "enum", T: proto2.getEnumType(EnumParseTester_Arbitrary), repeated: true, packed: true }),
);

/**
 * This message contains different kind of bool fields to exercise the different
 * parsers in table-drived.
 *
 * @generated from message protobuf_unittest.BoolParseTester
 */
export class BoolParseTester extends Message<BoolParseTester> {
  /**
   * @generated from field: optional bool optional_bool_lowfield = 1;
   */
  declare optionalBoolLowfield: boolean;

  /**
   * @generated from field: optional bool optional_bool_midfield = 1001;
   */
  declare optionalBoolMidfield: boolean;

  /**
   * @generated from field: optional bool optional_bool_hifield = 1000001;
   */
  declare optionalBoolHifield: boolean;

  /**
   * @generated from field: repeated bool repeated_bool_lowfield = 2;
   */
  repeatedBoolLowfield: boolean[] = [];

  /**
   * @generated from field: repeated bool repeated_bool_midfield = 1002;
   */
  repeatedBoolMidfield: boolean[] = [];

  /**
   * @generated from field: repeated bool repeated_bool_hifield = 1000002;
   */
  repeatedBoolHifield: boolean[] = [];

  /**
   * @generated from field: repeated bool packed_bool_lowfield = 3 [packed = true];
   */
  packedBoolLowfield: boolean[] = [];

  /**
   * @generated from field: repeated bool packed_bool_midfield = 1003 [packed = true];
   */
  packedBoolMidfield: boolean[] = [];

  /**
   * @generated from field: repeated bool packed_bool_hifield = 1000003 [packed = true];
   */
  packedBoolHifield: boolean[] = [];

  /**
   * An arbitrary field we can append to to break the runs of repeated fields.
   *
   * @generated from field: optional int32 other_field = 99;
   */
  declare otherField: number;

  constructor(data?: PartialMessage<BoolParseTester>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.BoolParseTester";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "optional_bool_lowfield", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 1001, name: "optional_bool_midfield", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 1000001, name: "optional_bool_hifield", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 2, name: "repeated_bool_lowfield", kind: "scalar", T: 8 /* ScalarType.BOOL */, repeated: true },
    { no: 1002, name: "repeated_bool_midfield", kind: "scalar", T: 8 /* ScalarType.BOOL */, repeated: true },
    { no: 1000002, name: "repeated_bool_hifield", kind: "scalar", T: 8 /* ScalarType.BOOL */, repeated: true },
    { no: 3, name: "packed_bool_lowfield", kind: "scalar", T: 8 /* ScalarType.BOOL */, repeated: true, packed: true },
    { no: 1003, name: "packed_bool_midfield", kind: "scalar", T: 8 /* ScalarType.BOOL */, repeated: true, packed: true },
    { no: 1000003, name: "packed_bool_hifield", kind: "scalar", T: 8 /* ScalarType.BOOL */, repeated: true, packed: true },
    { no: 99, name: "other_field", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BoolParseTester {
    return new BoolParseTester().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BoolParseTester {
    return new BoolParseTester().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BoolParseTester {
    return new BoolParseTester().fromJsonString(jsonString, options);
  }

  static equals(a: BoolParseTester | PlainMessage<BoolParseTester> | undefined, b: BoolParseTester | PlainMessage<BoolParseTester> | undefined): boolean {
    return proto2.util.equals(BoolParseTester, a, b);
  }
}

BoolParseTester.prototype.optionalBoolLowfield = false;
BoolParseTester.prototype.optionalBoolMidfield = false;
BoolParseTester.prototype.optionalBoolHifield = false;
BoolParseTester.prototype.otherField = 0;

/**
 * @generated from extension: optional bool optional_bool_ext = 2000000;
 */
export const BoolParseTester_optional_bool_ext = proto2.makeExtension<BoolParseTester, boolean>(
  "protobuf_unittest.BoolParseTester.optional_bool_ext", 
  BoolParseTester, 
  { no: 2000000, kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
);

/**
 * @generated from extension: repeated bool repeated_bool_ext = 2000001;
 */
export const BoolParseTester_repeated_bool_ext = proto2.makeExtension<BoolParseTester, boolean[]>(
  "protobuf_unittest.BoolParseTester.repeated_bool_ext", 
  BoolParseTester, 
  { no: 2000001, kind: "scalar", T: 8 /* ScalarType.BOOL */, repeated: true },
);

/**
 * @generated from extension: repeated bool packed_bool_ext = 2000002 [packed = true];
 */
export const BoolParseTester_packed_bool_ext = proto2.makeExtension<BoolParseTester, boolean[]>(
  "protobuf_unittest.BoolParseTester.packed_bool_ext", 
  BoolParseTester, 
  { no: 2000002, kind: "scalar", T: 8 /* ScalarType.BOOL */, repeated: true, packed: true },
);

/**
 * @generated from message protobuf_unittest.Int32ParseTester
 */
export class Int32ParseTester extends Message<Int32ParseTester> {
  /**
   * @generated from field: optional int32 optional_int32_lowfield = 1;
   */
  declare optionalInt32Lowfield: number;

  /**
   * @generated from field: optional int32 optional_int32_midfield = 1001;
   */
  declare optionalInt32Midfield: number;

  /**
   * @generated from field: optional int32 optional_int32_hifield = 1000001;
   */
  declare optionalInt32Hifield: number;

  /**
   * @generated from field: repeated int32 repeated_int32_lowfield = 2;
   */
  repeatedInt32Lowfield: number[] = [];

  /**
   * @generated from field: repeated int32 repeated_int32_midfield = 1002;
   */
  repeatedInt32Midfield: number[] = [];

  /**
   * @generated from field: repeated int32 repeated_int32_hifield = 1000002;
   */
  repeatedInt32Hifield: number[] = [];

  /**
   * @generated from field: repeated int32 packed_int32_lowfield = 3 [packed = true];
   */
  packedInt32Lowfield: number[] = [];

  /**
   * @generated from field: repeated int32 packed_int32_midfield = 1003 [packed = true];
   */
  packedInt32Midfield: number[] = [];

  /**
   * @generated from field: repeated int32 packed_int32_hifield = 1000003 [packed = true];
   */
  packedInt32Hifield: number[] = [];

  /**
   * An arbitrary field we can append to to break the runs of repeated fields.
   *
   * @generated from field: optional int32 other_field = 99;
   */
  declare otherField: number;

  constructor(data?: PartialMessage<Int32ParseTester>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.Int32ParseTester";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "optional_int32_lowfield", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 1001, name: "optional_int32_midfield", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 1000001, name: "optional_int32_hifield", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 2, name: "repeated_int32_lowfield", kind: "scalar", T: 5 /* ScalarType.INT32 */, repeated: true },
    { no: 1002, name: "repeated_int32_midfield", kind: "scalar", T: 5 /* ScalarType.INT32 */, repeated: true },
    { no: 1000002, name: "repeated_int32_hifield", kind: "scalar", T: 5 /* ScalarType.INT32 */, repeated: true },
    { no: 3, name: "packed_int32_lowfield", kind: "scalar", T: 5 /* ScalarType.INT32 */, repeated: true, packed: true },
    { no: 1003, name: "packed_int32_midfield", kind: "scalar", T: 5 /* ScalarType.INT32 */, repeated: true, packed: true },
    { no: 1000003, name: "packed_int32_hifield", kind: "scalar", T: 5 /* ScalarType.INT32 */, repeated: true, packed: true },
    { no: 99, name: "other_field", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Int32ParseTester {
    return new Int32ParseTester().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Int32ParseTester {
    return new Int32ParseTester().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Int32ParseTester {
    return new Int32ParseTester().fromJsonString(jsonString, options);
  }

  static equals(a: Int32ParseTester | PlainMessage<Int32ParseTester> | undefined, b: Int32ParseTester | PlainMessage<Int32ParseTester> | undefined): boolean {
    return proto2.util.equals(Int32ParseTester, a, b);
  }
}

Int32ParseTester.prototype.optionalInt32Lowfield = 0;
Int32ParseTester.prototype.optionalInt32Midfield = 0;
Int32ParseTester.prototype.optionalInt32Hifield = 0;
Int32ParseTester.prototype.otherField = 0;

/**
 * @generated from extension: optional int32 optional_int32_ext = 2000000;
 */
export const Int32ParseTester_optional_int32_ext = proto2.makeExtension<Int32ParseTester, number>(
  "protobuf_unittest.Int32ParseTester.optional_int32_ext", 
  Int32ParseTester, 
  { no: 2000000, kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
);

/**
 * @generated from extension: repeated int32 repeated_int32_ext = 2000001;
 */
export const Int32ParseTester_repeated_int32_ext = proto2.makeExtension<Int32ParseTester, number[]>(
  "protobuf_unittest.Int32ParseTester.repeated_int32_ext", 
  Int32ParseTester, 
  { no: 2000001, kind: "scalar", T: 5 /* ScalarType.INT32 */, repeated: true },
);

/**
 * @generated from extension: repeated int32 packed_int32_ext = 2000002 [packed = true];
 */
export const Int32ParseTester_packed_int32_ext = proto2.makeExtension<Int32ParseTester, number[]>(
  "protobuf_unittest.Int32ParseTester.packed_int32_ext", 
  Int32ParseTester, 
  { no: 2000002, kind: "scalar", T: 5 /* ScalarType.INT32 */, repeated: true, packed: true },
);

/**
 * @generated from message protobuf_unittest.Int64ParseTester
 */
export class Int64ParseTester extends Message<Int64ParseTester> {
  /**
   * @generated from field: optional int64 optional_int64_lowfield = 1;
   */
  declare optionalInt64Lowfield: bigint;

  /**
   * @generated from field: optional int64 optional_int64_midfield = 1001;
   */
  declare optionalInt64Midfield: bigint;

  /**
   * @generated from field: optional int64 optional_int64_hifield = 1000001;
   */
  declare optionalInt64Hifield: bigint;

  /**
   * @generated from field: repeated int64 repeated_int64_lowfield = 2;
   */
  repeatedInt64Lowfield: bigint[] = [];

  /**
   * @generated from field: repeated int64 repeated_int64_midfield = 1002;
   */
  repeatedInt64Midfield: bigint[] = [];

  /**
   * @generated from field: repeated int64 repeated_int64_hifield = 1000002;
   */
  repeatedInt64Hifield: bigint[] = [];

  /**
   * @generated from field: repeated int64 packed_int64_lowfield = 3 [packed = true];
   */
  packedInt64Lowfield: bigint[] = [];

  /**
   * @generated from field: repeated int64 packed_int64_midfield = 1003 [packed = true];
   */
  packedInt64Midfield: bigint[] = [];

  /**
   * @generated from field: repeated int64 packed_int64_hifield = 1000003 [packed = true];
   */
  packedInt64Hifield: bigint[] = [];

  /**
   * An arbitrary field we can append to to break the runs of repeated fields.
   *
   * @generated from field: optional int32 other_field = 99;
   */
  declare otherField: number;

  constructor(data?: PartialMessage<Int64ParseTester>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.Int64ParseTester";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "optional_int64_lowfield", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 1001, name: "optional_int64_midfield", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 1000001, name: "optional_int64_hifield", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 2, name: "repeated_int64_lowfield", kind: "scalar", T: 3 /* ScalarType.INT64 */, repeated: true },
    { no: 1002, name: "repeated_int64_midfield", kind: "scalar", T: 3 /* ScalarType.INT64 */, repeated: true },
    { no: 1000002, name: "repeated_int64_hifield", kind: "scalar", T: 3 /* ScalarType.INT64 */, repeated: true },
    { no: 3, name: "packed_int64_lowfield", kind: "scalar", T: 3 /* ScalarType.INT64 */, repeated: true, packed: true },
    { no: 1003, name: "packed_int64_midfield", kind: "scalar", T: 3 /* ScalarType.INT64 */, repeated: true, packed: true },
    { no: 1000003, name: "packed_int64_hifield", kind: "scalar", T: 3 /* ScalarType.INT64 */, repeated: true, packed: true },
    { no: 99, name: "other_field", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Int64ParseTester {
    return new Int64ParseTester().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Int64ParseTester {
    return new Int64ParseTester().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Int64ParseTester {
    return new Int64ParseTester().fromJsonString(jsonString, options);
  }

  static equals(a: Int64ParseTester | PlainMessage<Int64ParseTester> | undefined, b: Int64ParseTester | PlainMessage<Int64ParseTester> | undefined): boolean {
    return proto2.util.equals(Int64ParseTester, a, b);
  }
}

Int64ParseTester.prototype.optionalInt64Lowfield = protoInt64.zero;
Int64ParseTester.prototype.optionalInt64Midfield = protoInt64.zero;
Int64ParseTester.prototype.optionalInt64Hifield = protoInt64.zero;
Int64ParseTester.prototype.otherField = 0;

/**
 * @generated from extension: optional int64 optional_int64_ext = 2000000;
 */
export const Int64ParseTester_optional_int64_ext = proto2.makeExtension<Int64ParseTester, bigint>(
  "protobuf_unittest.Int64ParseTester.optional_int64_ext", 
  Int64ParseTester, 
  { no: 2000000, kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
);

/**
 * @generated from extension: repeated int64 repeated_int64_ext = 2000001;
 */
export const Int64ParseTester_repeated_int64_ext = proto2.makeExtension<Int64ParseTester, bigint[]>(
  "protobuf_unittest.Int64ParseTester.repeated_int64_ext", 
  Int64ParseTester, 
  { no: 2000001, kind: "scalar", T: 3 /* ScalarType.INT64 */, repeated: true },
);

/**
 * @generated from extension: repeated int64 packed_int64_ext = 2000002 [packed = true];
 */
export const Int64ParseTester_packed_int64_ext = proto2.makeExtension<Int64ParseTester, bigint[]>(
  "protobuf_unittest.Int64ParseTester.packed_int64_ext", 
  Int64ParseTester, 
  { no: 2000002, kind: "scalar", T: 3 /* ScalarType.INT64 */, repeated: true, packed: true },
);

/**
 * @generated from message protobuf_unittest.InlinedStringIdxRegressionProto
 */
export class InlinedStringIdxRegressionProto extends Message<InlinedStringIdxRegressionProto> {
  /**
   * We mix data to make sure aux ids and inlined string idx do not match.
   * aux_idx == inlined_string_idx == 1
   *
   * @generated from field: optional string str1 = 1;
   */
  declare str1: string;

  /**
   * aux_idx == 2
   *
   * @generated from field: optional protobuf_unittest.InlinedStringIdxRegressionProto sub = 2;
   */
  sub?: InlinedStringIdxRegressionProto;

  /**
   * aux_idx == 3, inlined_string_idx == 2
   *
   * @generated from field: optional string str2 = 3;
   */
  declare str2: string;

  /**
   * aux_idx == 4, inlined_string_idx == 3
   *
   * @generated from field: optional bytes str3 = 4;
   */
  declare str3: Uint8Array;

  constructor(data?: PartialMessage<InlinedStringIdxRegressionProto>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.InlinedStringIdxRegressionProto";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "str1", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "sub", kind: "message", T: InlinedStringIdxRegressionProto, opt: true },
    { no: 3, name: "str2", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "str3", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InlinedStringIdxRegressionProto {
    return new InlinedStringIdxRegressionProto().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InlinedStringIdxRegressionProto {
    return new InlinedStringIdxRegressionProto().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InlinedStringIdxRegressionProto {
    return new InlinedStringIdxRegressionProto().fromJsonString(jsonString, options);
  }

  static equals(a: InlinedStringIdxRegressionProto | PlainMessage<InlinedStringIdxRegressionProto> | undefined, b: InlinedStringIdxRegressionProto | PlainMessage<InlinedStringIdxRegressionProto> | undefined): boolean {
    return proto2.util.equals(InlinedStringIdxRegressionProto, a, b);
  }
}

InlinedStringIdxRegressionProto.prototype.str1 = "";
InlinedStringIdxRegressionProto.prototype.str2 = "";
InlinedStringIdxRegressionProto.prototype.str3 = new Uint8Array(0);

/**
 * @generated from message protobuf_unittest.StringParseTester
 */
export class StringParseTester extends Message<StringParseTester> {
  /**
   * @generated from field: optional string optional_string_lowfield = 1;
   */
  declare optionalStringLowfield: string;

  /**
   * @generated from field: optional string optional_string_midfield = 1001;
   */
  declare optionalStringMidfield: string;

  /**
   * @generated from field: optional string optional_string_hifield = 1000001;
   */
  declare optionalStringHifield: string;

  /**
   * @generated from field: repeated string repeated_string_lowfield = 2;
   */
  repeatedStringLowfield: string[] = [];

  /**
   * @generated from field: repeated string repeated_string_midfield = 1002;
   */
  repeatedStringMidfield: string[] = [];

  /**
   * @generated from field: repeated string repeated_string_hifield = 1000002;
   */
  repeatedStringHifield: string[] = [];

  constructor(data?: PartialMessage<StringParseTester>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.StringParseTester";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "optional_string_lowfield", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 1001, name: "optional_string_midfield", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 1000001, name: "optional_string_hifield", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "repeated_string_lowfield", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 1002, name: "repeated_string_midfield", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 1000002, name: "repeated_string_hifield", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringParseTester {
    return new StringParseTester().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringParseTester {
    return new StringParseTester().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringParseTester {
    return new StringParseTester().fromJsonString(jsonString, options);
  }

  static equals(a: StringParseTester | PlainMessage<StringParseTester> | undefined, b: StringParseTester | PlainMessage<StringParseTester> | undefined): boolean {
    return proto2.util.equals(StringParseTester, a, b);
  }
}

StringParseTester.prototype.optionalStringLowfield = "";
StringParseTester.prototype.optionalStringMidfield = "";
StringParseTester.prototype.optionalStringHifield = "";

/**
 * @generated from extension: optional string optional_string_ext = 2000000;
 */
export const StringParseTester_optional_string_ext = proto2.makeExtension<StringParseTester, string>(
  "protobuf_unittest.StringParseTester.optional_string_ext", 
  StringParseTester, 
  { no: 2000000, kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
);

/**
 * @generated from extension: repeated string repeated_string_ext = 2000001;
 */
export const StringParseTester_repeated_string_ext = proto2.makeExtension<StringParseTester, string[]>(
  "protobuf_unittest.StringParseTester.repeated_string_ext", 
  StringParseTester, 
  { no: 2000001, kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
);

/**
 * @generated from message protobuf_unittest.BadFieldNames
 */
export class BadFieldNames extends Message<BadFieldNames> {
  /**
   * @generated from field: optional int32 OptionalInt32 = 1;
   */
  declare OptionalInt32: number;

  /**
   * @generated from field: optional int32 for = 2;
   */
  declare for: number;

  constructor(data?: PartialMessage<BadFieldNames>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.BadFieldNames";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "OptionalInt32", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 2, name: "for", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BadFieldNames {
    return new BadFieldNames().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BadFieldNames {
    return new BadFieldNames().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BadFieldNames {
    return new BadFieldNames().fromJsonString(jsonString, options);
  }

  static equals(a: BadFieldNames | PlainMessage<BadFieldNames> | undefined, b: BadFieldNames | PlainMessage<BadFieldNames> | undefined): boolean {
    return proto2.util.equals(BadFieldNames, a, b);
  }
}

BadFieldNames.prototype.OptionalInt32 = 0;
BadFieldNames.prototype.for = 0;

/**
 * @generated from message protobuf_unittest.TestNestedMessageRedaction
 */
export class TestNestedMessageRedaction extends Message<TestNestedMessageRedaction> {
  /**
   * @generated from field: optional string optional_unredacted_nested_string = 1;
   */
  declare optionalUnredactedNestedString: string;

  /**
   * @generated from field: optional string optional_redacted_nested_string = 2;
   */
  declare optionalRedactedNestedString: string;

  constructor(data?: PartialMessage<TestNestedMessageRedaction>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestNestedMessageRedaction";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "optional_unredacted_nested_string", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "optional_redacted_nested_string", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestNestedMessageRedaction {
    return new TestNestedMessageRedaction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestNestedMessageRedaction {
    return new TestNestedMessageRedaction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestNestedMessageRedaction {
    return new TestNestedMessageRedaction().fromJsonString(jsonString, options);
  }

  static equals(a: TestNestedMessageRedaction | PlainMessage<TestNestedMessageRedaction> | undefined, b: TestNestedMessageRedaction | PlainMessage<TestNestedMessageRedaction> | undefined): boolean {
    return proto2.util.equals(TestNestedMessageRedaction, a, b);
  }
}

TestNestedMessageRedaction.prototype.optionalUnredactedNestedString = "";
TestNestedMessageRedaction.prototype.optionalRedactedNestedString = "";

/**
 * @generated from message protobuf_unittest.RedactedFields
 */
export class RedactedFields extends Message<RedactedFields> {
  /**
   * @generated from field: optional string optional_redacted_string = 1;
   */
  declare optionalRedactedString: string;

  /**
   * @generated from field: optional string optional_unredacted_string = 2;
   */
  declare optionalUnredactedString: string;

  /**
   * @generated from field: repeated string repeated_redacted_string = 3;
   */
  repeatedRedactedString: string[] = [];

  /**
   * @generated from field: repeated string repeated_unredacted_string = 4;
   */
  repeatedUnredactedString: string[] = [];

  /**
   * @generated from field: optional protobuf_unittest.TestNestedMessageRedaction optional_redacted_message = 5;
   */
  optionalRedactedMessage?: TestNestedMessageRedaction;

  /**
   * @generated from field: optional protobuf_unittest.TestNestedMessageRedaction optional_unredacted_message = 6;
   */
  optionalUnredactedMessage?: TestNestedMessageRedaction;

  /**
   * @generated from field: repeated protobuf_unittest.TestNestedMessageRedaction repeated_redacted_message = 7;
   */
  repeatedRedactedMessage: TestNestedMessageRedaction[] = [];

  /**
   * @generated from field: repeated protobuf_unittest.TestNestedMessageRedaction repeated_unredacted_message = 8;
   */
  repeatedUnredactedMessage: TestNestedMessageRedaction[] = [];

  /**
   * @generated from field: map<string, string> map_redacted_string = 9;
   */
  mapRedactedString: { [key: string]: string } = {};

  /**
   * @generated from field: map<string, string> map_unredacted_string = 10;
   */
  mapUnredactedString: { [key: string]: string } = {};

  constructor(data?: PartialMessage<RedactedFields>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.RedactedFields";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "optional_redacted_string", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "optional_unredacted_string", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "repeated_redacted_string", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "repeated_unredacted_string", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "optional_redacted_message", kind: "message", T: TestNestedMessageRedaction, opt: true },
    { no: 6, name: "optional_unredacted_message", kind: "message", T: TestNestedMessageRedaction, opt: true },
    { no: 7, name: "repeated_redacted_message", kind: "message", T: TestNestedMessageRedaction, repeated: true },
    { no: 8, name: "repeated_unredacted_message", kind: "message", T: TestNestedMessageRedaction, repeated: true },
    { no: 9, name: "map_redacted_string", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 10, name: "map_unredacted_string", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RedactedFields {
    return new RedactedFields().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RedactedFields {
    return new RedactedFields().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RedactedFields {
    return new RedactedFields().fromJsonString(jsonString, options);
  }

  static equals(a: RedactedFields | PlainMessage<RedactedFields> | undefined, b: RedactedFields | PlainMessage<RedactedFields> | undefined): boolean {
    return proto2.util.equals(RedactedFields, a, b);
  }
}

RedactedFields.prototype.optionalRedactedString = "";
RedactedFields.prototype.optionalUnredactedString = "";

/**
 * @generated from message protobuf_unittest.TestCord
 */
export class TestCord extends Message<TestCord> {
  /**
   * @generated from field: optional bytes optional_bytes_cord = 1;
   */
  declare optionalBytesCord: Uint8Array;

  /**
   * @generated from field: optional bytes optional_bytes_cord_default = 2 [default = "hello"];
   */
  declare optionalBytesCordDefault: Uint8Array;

  constructor(data?: PartialMessage<TestCord>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestCord";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "optional_bytes_cord", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 2, name: "optional_bytes_cord_default", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true, default: new Uint8Array([0x68, 0x65, 0x6C, 0x6C, 0x6F]) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestCord {
    return new TestCord().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestCord {
    return new TestCord().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestCord {
    return new TestCord().fromJsonString(jsonString, options);
  }

  static equals(a: TestCord | PlainMessage<TestCord> | undefined, b: TestCord | PlainMessage<TestCord> | undefined): boolean {
    return proto2.util.equals(TestCord, a, b);
  }
}

TestCord.prototype.optionalBytesCord = new Uint8Array(0);
TestCord.prototype.optionalBytesCordDefault = new Uint8Array([0x68, 0x65, 0x6C, 0x6C, 0x6F]);

/**
 * @generated from message protobuf_unittest.TestPackedEnumSmallRange
 */
export class TestPackedEnumSmallRange extends Message<TestPackedEnumSmallRange> {
  /**
   * @generated from field: repeated protobuf_unittest.TestPackedEnumSmallRange.NestedEnum vals = 1 [packed = true];
   */
  vals: TestPackedEnumSmallRange_NestedEnum[] = [];

  constructor(data?: PartialMessage<TestPackedEnumSmallRange>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestPackedEnumSmallRange";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "vals", kind: "enum", T: proto2.getEnumType(TestPackedEnumSmallRange_NestedEnum), repeated: true, packed: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestPackedEnumSmallRange {
    return new TestPackedEnumSmallRange().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestPackedEnumSmallRange {
    return new TestPackedEnumSmallRange().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestPackedEnumSmallRange {
    return new TestPackedEnumSmallRange().fromJsonString(jsonString, options);
  }

  static equals(a: TestPackedEnumSmallRange | PlainMessage<TestPackedEnumSmallRange> | undefined, b: TestPackedEnumSmallRange | PlainMessage<TestPackedEnumSmallRange> | undefined): boolean {
    return proto2.util.equals(TestPackedEnumSmallRange, a, b);
  }
}

/**
 * @generated from enum protobuf_unittest.TestPackedEnumSmallRange.NestedEnum
 */
export enum TestPackedEnumSmallRange_NestedEnum {
  /**
   * @generated from enum value: UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: FOO = 1;
   */
  FOO = 1,

  /**
   * @generated from enum value: BAR = 2;
   */
  BAR = 2,

  /**
   * @generated from enum value: BAZ = 3;
   */
  BAZ = 3,
}
// Retrieve enum metadata with: proto2.getEnumType(TestPackedEnumSmallRange_NestedEnum)
proto2.util.setEnumType(TestPackedEnumSmallRange_NestedEnum, "protobuf_unittest.TestPackedEnumSmallRange.NestedEnum", [
  { no: 0, name: "UNSPECIFIED" },
  { no: 1, name: "FOO" },
  { no: 2, name: "BAR" },
  { no: 3, name: "BAZ" },
]);

/**
 * @generated from message protobuf_unittest.EnumsForBenchmark
 */
export class EnumsForBenchmark extends Message<EnumsForBenchmark> {
  constructor(data?: PartialMessage<EnumsForBenchmark>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.EnumsForBenchmark";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EnumsForBenchmark {
    return new EnumsForBenchmark().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EnumsForBenchmark {
    return new EnumsForBenchmark().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EnumsForBenchmark {
    return new EnumsForBenchmark().fromJsonString(jsonString, options);
  }

  static equals(a: EnumsForBenchmark | PlainMessage<EnumsForBenchmark> | undefined, b: EnumsForBenchmark | PlainMessage<EnumsForBenchmark> | undefined): boolean {
    return proto2.util.equals(EnumsForBenchmark, a, b);
  }
}

/**
 * @generated from enum protobuf_unittest.EnumsForBenchmark.Flat
 */
export enum EnumsForBenchmark_Flat {
  /**
   * @generated from enum value: A0 = 0;
   */
  A0 = 0,

  /**
   * @generated from enum value: A1 = 1;
   */
  A1 = 1,

  /**
   * @generated from enum value: A2 = 2;
   */
  A2 = 2,

  /**
   * @generated from enum value: A3 = 3;
   */
  A3 = 3,

  /**
   * @generated from enum value: A4 = 4;
   */
  A4 = 4,

  /**
   * @generated from enum value: A5 = 5;
   */
  A5 = 5,

  /**
   * @generated from enum value: A6 = 6;
   */
  A6 = 6,

  /**
   * @generated from enum value: A7 = 7;
   */
  A7 = 7,

  /**
   * @generated from enum value: A8 = 8;
   */
  A8 = 8,

  /**
   * @generated from enum value: A9 = 9;
   */
  A9 = 9,

  /**
   * @generated from enum value: A10 = 10;
   */
  A10 = 10,

  /**
   * @generated from enum value: A11 = 11;
   */
  A11 = 11,

  /**
   * @generated from enum value: A12 = 12;
   */
  A12 = 12,

  /**
   * @generated from enum value: A13 = 13;
   */
  A13 = 13,

  /**
   * @generated from enum value: A14 = 14;
   */
  A14 = 14,

  /**
   * @generated from enum value: A15 = 15;
   */
  A15 = 15,
}
// Retrieve enum metadata with: proto2.getEnumType(EnumsForBenchmark_Flat)
proto2.util.setEnumType(EnumsForBenchmark_Flat, "protobuf_unittest.EnumsForBenchmark.Flat", [
  { no: 0, name: "A0" },
  { no: 1, name: "A1" },
  { no: 2, name: "A2" },
  { no: 3, name: "A3" },
  { no: 4, name: "A4" },
  { no: 5, name: "A5" },
  { no: 6, name: "A6" },
  { no: 7, name: "A7" },
  { no: 8, name: "A8" },
  { no: 9, name: "A9" },
  { no: 10, name: "A10" },
  { no: 11, name: "A11" },
  { no: 12, name: "A12" },
  { no: 13, name: "A13" },
  { no: 14, name: "A14" },
  { no: 15, name: "A15" },
]);

/**
 * Has a few holes, bitmap can be used.
 *
 * @generated from enum protobuf_unittest.EnumsForBenchmark.AlmostFlat
 */
export enum EnumsForBenchmark_AlmostFlat {
  /**
   * @generated from enum value: B0 = 0;
   */
  B0 = 0,

  /**
   * @generated from enum value: B1 = 1;
   */
  B1 = 1,

  /**
   * @generated from enum value: B2 = 2;
   */
  B2 = 2,

  /**
   * @generated from enum value: B3 = 3;
   */
  B3 = 3,

  /**
   * @generated from enum value: B5 = 5;
   */
  B5 = 5,

  /**
   * @generated from enum value: B6 = 6;
   */
  B6 = 6,

  /**
   * @generated from enum value: B7 = 7;
   */
  B7 = 7,

  /**
   * @generated from enum value: B8 = 8;
   */
  B8 = 8,

  /**
   * @generated from enum value: B9 = 9;
   */
  B9 = 9,

  /**
   * @generated from enum value: B11 = 11;
   */
  B11 = 11,

  /**
   * @generated from enum value: B12 = 12;
   */
  B12 = 12,

  /**
   * @generated from enum value: B13 = 13;
   */
  B13 = 13,

  /**
   * @generated from enum value: B14 = 14;
   */
  B14 = 14,

  /**
   * @generated from enum value: B15 = 15;
   */
  B15 = 15,

  /**
   * @generated from enum value: B17 = 17;
   */
  B17 = 17,

  /**
   * @generated from enum value: B19 = 19;
   */
  B19 = 19,
}
// Retrieve enum metadata with: proto2.getEnumType(EnumsForBenchmark_AlmostFlat)
proto2.util.setEnumType(EnumsForBenchmark_AlmostFlat, "protobuf_unittest.EnumsForBenchmark.AlmostFlat", [
  { no: 0, name: "B0" },
  { no: 1, name: "B1" },
  { no: 2, name: "B2" },
  { no: 3, name: "B3" },
  { no: 5, name: "B5" },
  { no: 6, name: "B6" },
  { no: 7, name: "B7" },
  { no: 8, name: "B8" },
  { no: 9, name: "B9" },
  { no: 11, name: "B11" },
  { no: 12, name: "B12" },
  { no: 13, name: "B13" },
  { no: 14, name: "B14" },
  { no: 15, name: "B15" },
  { no: 17, name: "B17" },
  { no: 19, name: "B19" },
]);

/**
 * @generated from enum protobuf_unittest.EnumsForBenchmark.Sparse
 */
export enum EnumsForBenchmark_Sparse {
  /**
   * @generated from enum value: C536 = 536;
   */
  C536 = 536,

  /**
   * @generated from enum value: C8387 = 8387;
   */
  C8387 = 8387,

  /**
   * @generated from enum value: C9673 = 9673;
   */
  C9673 = 9673,

  /**
   * @generated from enum value: C10285 = 10285;
   */
  C10285 = 10285,

  /**
   * @generated from enum value: C13318 = 13318;
   */
  C13318 = 13318,

  /**
   * @generated from enum value: C15963 = 15963;
   */
  C15963 = 15963,

  /**
   * @generated from enum value: C16439 = 16439;
   */
  C16439 = 16439,

  /**
   * @generated from enum value: C18197 = 18197;
   */
  C18197 = 18197,

  /**
   * @generated from enum value: C19430 = 19430;
   */
  C19430 = 19430,

  /**
   * @generated from enum value: C20361 = 20361;
   */
  C20361 = 20361,

  /**
   * @generated from enum value: C20706 = 20706;
   */
  C20706 = 20706,

  /**
   * @generated from enum value: C21050 = 21050;
   */
  C21050 = 21050,

  /**
   * @generated from enum value: C21906 = 21906;
   */
  C21906 = 21906,

  /**
   * @generated from enum value: C27265 = 27265;
   */
  C27265 = 27265,

  /**
   * @generated from enum value: C30109 = 30109;
   */
  C30109 = 30109,

  /**
   * @generated from enum value: C31670 = 31670;
   */
  C31670 = 31670,
}
// Retrieve enum metadata with: proto2.getEnumType(EnumsForBenchmark_Sparse)
proto2.util.setEnumType(EnumsForBenchmark_Sparse, "protobuf_unittest.EnumsForBenchmark.Sparse", [
  { no: 536, name: "C536" },
  { no: 8387, name: "C8387" },
  { no: 9673, name: "C9673" },
  { no: 10285, name: "C10285" },
  { no: 13318, name: "C13318" },
  { no: 15963, name: "C15963" },
  { no: 16439, name: "C16439" },
  { no: 18197, name: "C18197" },
  { no: 19430, name: "C19430" },
  { no: 20361, name: "C20361" },
  { no: 20706, name: "C20706" },
  { no: 21050, name: "C21050" },
  { no: 21906, name: "C21906" },
  { no: 27265, name: "C27265" },
  { no: 30109, name: "C30109" },
  { no: 31670, name: "C31670" },
]);

/**
 * @generated from message protobuf_unittest.TestMessageWithManyRepeatedPtrFields
 */
export class TestMessageWithManyRepeatedPtrFields extends Message<TestMessageWithManyRepeatedPtrFields> {
  /**
   * @generated from field: repeated string repeated_string_1 = 1;
   */
  repeatedString1: string[] = [];

  /**
   * @generated from field: repeated string repeated_string_2 = 2;
   */
  repeatedString2: string[] = [];

  /**
   * @generated from field: repeated string repeated_string_3 = 3;
   */
  repeatedString3: string[] = [];

  /**
   * @generated from field: repeated string repeated_string_4 = 4;
   */
  repeatedString4: string[] = [];

  /**
   * @generated from field: repeated string repeated_string_5 = 5;
   */
  repeatedString5: string[] = [];

  /**
   * @generated from field: repeated string repeated_string_6 = 6;
   */
  repeatedString6: string[] = [];

  /**
   * @generated from field: repeated string repeated_string_7 = 7;
   */
  repeatedString7: string[] = [];

  /**
   * @generated from field: repeated string repeated_string_8 = 8;
   */
  repeatedString8: string[] = [];

  /**
   * @generated from field: repeated string repeated_string_9 = 9;
   */
  repeatedString9: string[] = [];

  /**
   * @generated from field: repeated string repeated_string_10 = 10;
   */
  repeatedString10: string[] = [];

  /**
   * @generated from field: repeated string repeated_string_11 = 11;
   */
  repeatedString11: string[] = [];

  /**
   * @generated from field: repeated string repeated_string_12 = 12;
   */
  repeatedString12: string[] = [];

  /**
   * @generated from field: repeated string repeated_string_13 = 13;
   */
  repeatedString13: string[] = [];

  /**
   * @generated from field: repeated string repeated_string_14 = 14;
   */
  repeatedString14: string[] = [];

  /**
   * @generated from field: repeated string repeated_string_15 = 15;
   */
  repeatedString15: string[] = [];

  /**
   * @generated from field: repeated string repeated_string_16 = 16;
   */
  repeatedString16: string[] = [];

  /**
   * @generated from field: repeated string repeated_string_17 = 17;
   */
  repeatedString17: string[] = [];

  /**
   * @generated from field: repeated string repeated_string_18 = 18;
   */
  repeatedString18: string[] = [];

  /**
   * @generated from field: repeated string repeated_string_19 = 19;
   */
  repeatedString19: string[] = [];

  /**
   * @generated from field: repeated string repeated_string_20 = 20;
   */
  repeatedString20: string[] = [];

  /**
   * @generated from field: repeated string repeated_string_21 = 21;
   */
  repeatedString21: string[] = [];

  /**
   * @generated from field: repeated string repeated_string_22 = 22;
   */
  repeatedString22: string[] = [];

  /**
   * @generated from field: repeated string repeated_string_23 = 23;
   */
  repeatedString23: string[] = [];

  /**
   * @generated from field: repeated string repeated_string_24 = 24;
   */
  repeatedString24: string[] = [];

  /**
   * @generated from field: repeated string repeated_string_25 = 25;
   */
  repeatedString25: string[] = [];

  /**
   * @generated from field: repeated string repeated_string_26 = 26;
   */
  repeatedString26: string[] = [];

  /**
   * @generated from field: repeated string repeated_string_27 = 27;
   */
  repeatedString27: string[] = [];

  /**
   * @generated from field: repeated string repeated_string_28 = 28;
   */
  repeatedString28: string[] = [];

  /**
   * @generated from field: repeated string repeated_string_29 = 29;
   */
  repeatedString29: string[] = [];

  /**
   * @generated from field: repeated string repeated_string_30 = 30;
   */
  repeatedString30: string[] = [];

  /**
   * @generated from field: repeated string repeated_string_31 = 31;
   */
  repeatedString31: string[] = [];

  /**
   * @generated from field: repeated string repeated_string_32 = 32;
   */
  repeatedString32: string[] = [];

  constructor(data?: PartialMessage<TestMessageWithManyRepeatedPtrFields>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "protobuf_unittest.TestMessageWithManyRepeatedPtrFields";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "repeated_string_1", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "repeated_string_2", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "repeated_string_3", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "repeated_string_4", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "repeated_string_5", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "repeated_string_6", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 7, name: "repeated_string_7", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 8, name: "repeated_string_8", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 9, name: "repeated_string_9", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 10, name: "repeated_string_10", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 11, name: "repeated_string_11", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 12, name: "repeated_string_12", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 13, name: "repeated_string_13", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 14, name: "repeated_string_14", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 15, name: "repeated_string_15", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 16, name: "repeated_string_16", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 17, name: "repeated_string_17", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 18, name: "repeated_string_18", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 19, name: "repeated_string_19", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 20, name: "repeated_string_20", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 21, name: "repeated_string_21", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 22, name: "repeated_string_22", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 23, name: "repeated_string_23", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 24, name: "repeated_string_24", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 25, name: "repeated_string_25", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 26, name: "repeated_string_26", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 27, name: "repeated_string_27", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 28, name: "repeated_string_28", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 29, name: "repeated_string_29", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 30, name: "repeated_string_30", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 31, name: "repeated_string_31", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 32, name: "repeated_string_32", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestMessageWithManyRepeatedPtrFields {
    return new TestMessageWithManyRepeatedPtrFields().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestMessageWithManyRepeatedPtrFields {
    return new TestMessageWithManyRepeatedPtrFields().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestMessageWithManyRepeatedPtrFields {
    return new TestMessageWithManyRepeatedPtrFields().fromJsonString(jsonString, options);
  }

  static equals(a: TestMessageWithManyRepeatedPtrFields | PlainMessage<TestMessageWithManyRepeatedPtrFields> | undefined, b: TestMessageWithManyRepeatedPtrFields | PlainMessage<TestMessageWithManyRepeatedPtrFields> | undefined): boolean {
    return proto2.util.equals(TestMessageWithManyRepeatedPtrFields, a, b);
  }
}

/**
 * Singular
 *
 * @generated from extension: optional int32 optional_int32_extension = 1;
 */
export const optional_int32_extension = proto2.makeExtension<TestAllExtensions, number>(
  "protobuf_unittest.optional_int32_extension", 
  TestAllExtensions, 
  { no: 1, kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
);

/**
 * @generated from extension: optional int64 optional_int64_extension = 2;
 */
export const optional_int64_extension = proto2.makeExtension<TestAllExtensions, bigint>(
  "protobuf_unittest.optional_int64_extension", 
  TestAllExtensions, 
  { no: 2, kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
);

/**
 * @generated from extension: optional uint32 optional_uint32_extension = 3;
 */
export const optional_uint32_extension = proto2.makeExtension<TestAllExtensions, number>(
  "protobuf_unittest.optional_uint32_extension", 
  TestAllExtensions, 
  { no: 3, kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
);

/**
 * @generated from extension: optional uint64 optional_uint64_extension = 4;
 */
export const optional_uint64_extension = proto2.makeExtension<TestAllExtensions, bigint>(
  "protobuf_unittest.optional_uint64_extension", 
  TestAllExtensions, 
  { no: 4, kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
);

/**
 * @generated from extension: optional sint32 optional_sint32_extension = 5;
 */
export const optional_sint32_extension = proto2.makeExtension<TestAllExtensions, number>(
  "protobuf_unittest.optional_sint32_extension", 
  TestAllExtensions, 
  { no: 5, kind: "scalar", T: 17 /* ScalarType.SINT32 */, opt: true },
);

/**
 * @generated from extension: optional sint64 optional_sint64_extension = 6;
 */
export const optional_sint64_extension = proto2.makeExtension<TestAllExtensions, bigint>(
  "protobuf_unittest.optional_sint64_extension", 
  TestAllExtensions, 
  { no: 6, kind: "scalar", T: 18 /* ScalarType.SINT64 */, opt: true },
);

/**
 * @generated from extension: optional fixed32 optional_fixed32_extension = 7;
 */
export const optional_fixed32_extension = proto2.makeExtension<TestAllExtensions, number>(
  "protobuf_unittest.optional_fixed32_extension", 
  TestAllExtensions, 
  { no: 7, kind: "scalar", T: 7 /* ScalarType.FIXED32 */, opt: true },
);

/**
 * @generated from extension: optional fixed64 optional_fixed64_extension = 8;
 */
export const optional_fixed64_extension = proto2.makeExtension<TestAllExtensions, bigint>(
  "protobuf_unittest.optional_fixed64_extension", 
  TestAllExtensions, 
  { no: 8, kind: "scalar", T: 6 /* ScalarType.FIXED64 */, opt: true },
);

/**
 * @generated from extension: optional sfixed32 optional_sfixed32_extension = 9;
 */
export const optional_sfixed32_extension = proto2.makeExtension<TestAllExtensions, number>(
  "protobuf_unittest.optional_sfixed32_extension", 
  TestAllExtensions, 
  { no: 9, kind: "scalar", T: 15 /* ScalarType.SFIXED32 */, opt: true },
);

/**
 * @generated from extension: optional sfixed64 optional_sfixed64_extension = 10;
 */
export const optional_sfixed64_extension = proto2.makeExtension<TestAllExtensions, bigint>(
  "protobuf_unittest.optional_sfixed64_extension", 
  TestAllExtensions, 
  { no: 10, kind: "scalar", T: 16 /* ScalarType.SFIXED64 */, opt: true },
);

/**
 * @generated from extension: optional float optional_float_extension = 11;
 */
export const optional_float_extension = proto2.makeExtension<TestAllExtensions, number>(
  "protobuf_unittest.optional_float_extension", 
  TestAllExtensions, 
  { no: 11, kind: "scalar", T: 2 /* ScalarType.FLOAT */, opt: true },
);

/**
 * @generated from extension: optional double optional_double_extension = 12;
 */
export const optional_double_extension = proto2.makeExtension<TestAllExtensions, number>(
  "protobuf_unittest.optional_double_extension", 
  TestAllExtensions, 
  { no: 12, kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
);

/**
 * @generated from extension: optional bool optional_bool_extension = 13;
 */
export const optional_bool_extension = proto2.makeExtension<TestAllExtensions, boolean>(
  "protobuf_unittest.optional_bool_extension", 
  TestAllExtensions, 
  { no: 13, kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
);

/**
 * @generated from extension: optional string optional_string_extension = 14;
 */
export const optional_string_extension = proto2.makeExtension<TestAllExtensions, string>(
  "protobuf_unittest.optional_string_extension", 
  TestAllExtensions, 
  { no: 14, kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
);

/**
 * @generated from extension: optional bytes optional_bytes_extension = 15;
 */
export const optional_bytes_extension = proto2.makeExtension<TestAllExtensions, Uint8Array>(
  "protobuf_unittest.optional_bytes_extension", 
  TestAllExtensions, 
  { no: 15, kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
);

/**
 * @generated from extension: optional protobuf_unittest.OptionalGroup_extension optionalgroup_extension = 16;
 */
export const optionalgroup_extension = proto2.makeExtension<TestAllExtensions, OptionalGroup_extension>(
  "protobuf_unittest.optionalgroup_extension", 
  TestAllExtensions, 
  () => ({ no: 16, kind: "message", T: OptionalGroup_extension, delimited: true, opt: true }),
);

/**
 * @generated from extension: optional protobuf_unittest.TestAllTypes.NestedMessage optional_nested_message_extension = 18;
 */
export const optional_nested_message_extension = proto2.makeExtension<TestAllExtensions, TestAllTypes_NestedMessage>(
  "protobuf_unittest.optional_nested_message_extension", 
  TestAllExtensions, 
  () => ({ no: 18, kind: "message", T: TestAllTypes_NestedMessage, opt: true }),
);

/**
 * @generated from extension: optional protobuf_unittest.ForeignMessage optional_foreign_message_extension = 19;
 */
export const optional_foreign_message_extension = proto2.makeExtension<TestAllExtensions, ForeignMessage>(
  "protobuf_unittest.optional_foreign_message_extension", 
  TestAllExtensions, 
  () => ({ no: 19, kind: "message", T: ForeignMessage, opt: true }),
);

/**
 * @generated from extension: optional protobuf_unittest_import.ImportMessage optional_import_message_extension = 20;
 */
export const optional_import_message_extension = proto2.makeExtension<TestAllExtensions, ImportMessage>(
  "protobuf_unittest.optional_import_message_extension", 
  TestAllExtensions, 
  () => ({ no: 20, kind: "message", T: ImportMessage, opt: true }),
);

/**
 * @generated from extension: optional protobuf_unittest.TestAllTypes.NestedEnum optional_nested_enum_extension = 21;
 */
export const optional_nested_enum_extension = proto2.makeExtension<TestAllExtensions, TestAllTypes_NestedEnum>(
  "protobuf_unittest.optional_nested_enum_extension", 
  TestAllExtensions, 
  () => ({ no: 21, kind: "enum", T: proto2.getEnumType(TestAllTypes_NestedEnum), opt: true }),
);

/**
 * @generated from extension: optional protobuf_unittest.ForeignEnum optional_foreign_enum_extension = 22;
 */
export const optional_foreign_enum_extension = proto2.makeExtension<TestAllExtensions, ForeignEnum>(
  "protobuf_unittest.optional_foreign_enum_extension", 
  TestAllExtensions, 
  () => ({ no: 22, kind: "enum", T: proto2.getEnumType(ForeignEnum), opt: true }),
);

/**
 * @generated from extension: optional protobuf_unittest_import.ImportEnum optional_import_enum_extension = 23;
 */
export const optional_import_enum_extension = proto2.makeExtension<TestAllExtensions, ImportEnum>(
  "protobuf_unittest.optional_import_enum_extension", 
  TestAllExtensions, 
  () => ({ no: 23, kind: "enum", T: proto2.getEnumType(ImportEnum), opt: true }),
);

/**
 * @generated from extension: optional string optional_string_piece_extension = 24;
 */
export const optional_string_piece_extension = proto2.makeExtension<TestAllExtensions, string>(
  "protobuf_unittest.optional_string_piece_extension", 
  TestAllExtensions, 
  { no: 24, kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
);

/**
 * TODO: ctype=CORD is not supported for extension. Add
 * ctype=CORD option back after it is supported.
 *
 * @generated from extension: optional string optional_cord_extension = 25;
 */
export const optional_cord_extension = proto2.makeExtension<TestAllExtensions, string>(
  "protobuf_unittest.optional_cord_extension", 
  TestAllExtensions, 
  { no: 25, kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
);

/**
 * @generated from extension: optional protobuf_unittest_import.PublicImportMessage optional_public_import_message_extension = 26;
 */
export const optional_public_import_message_extension = proto2.makeExtension<TestAllExtensions, PublicImportMessage>(
  "protobuf_unittest.optional_public_import_message_extension", 
  TestAllExtensions, 
  () => ({ no: 26, kind: "message", T: PublicImportMessage, opt: true }),
);

/**
 * @generated from extension: optional protobuf_unittest.TestAllTypes.NestedMessage optional_lazy_message_extension = 27;
 */
export const optional_lazy_message_extension = proto2.makeExtension<TestAllExtensions, TestAllTypes_NestedMessage>(
  "protobuf_unittest.optional_lazy_message_extension", 
  TestAllExtensions, 
  () => ({ no: 27, kind: "message", T: TestAllTypes_NestedMessage, opt: true }),
);

/**
 * @generated from extension: optional protobuf_unittest.TestAllTypes.NestedMessage optional_unverified_lazy_message_extension = 28;
 */
export const optional_unverified_lazy_message_extension = proto2.makeExtension<TestAllExtensions, TestAllTypes_NestedMessage>(
  "protobuf_unittest.optional_unverified_lazy_message_extension", 
  TestAllExtensions, 
  () => ({ no: 28, kind: "message", T: TestAllTypes_NestedMessage, opt: true }),
);

/**
 * Repeated
 *
 * @generated from extension: repeated int32 repeated_int32_extension = 31;
 */
export const repeated_int32_extension = proto2.makeExtension<TestAllExtensions, number[]>(
  "protobuf_unittest.repeated_int32_extension", 
  TestAllExtensions, 
  { no: 31, kind: "scalar", T: 5 /* ScalarType.INT32 */, repeated: true },
);

/**
 * @generated from extension: repeated int64 repeated_int64_extension = 32;
 */
export const repeated_int64_extension = proto2.makeExtension<TestAllExtensions, bigint[]>(
  "protobuf_unittest.repeated_int64_extension", 
  TestAllExtensions, 
  { no: 32, kind: "scalar", T: 3 /* ScalarType.INT64 */, repeated: true },
);

/**
 * @generated from extension: repeated uint32 repeated_uint32_extension = 33;
 */
export const repeated_uint32_extension = proto2.makeExtension<TestAllExtensions, number[]>(
  "protobuf_unittest.repeated_uint32_extension", 
  TestAllExtensions, 
  { no: 33, kind: "scalar", T: 13 /* ScalarType.UINT32 */, repeated: true },
);

/**
 * @generated from extension: repeated uint64 repeated_uint64_extension = 34;
 */
export const repeated_uint64_extension = proto2.makeExtension<TestAllExtensions, bigint[]>(
  "protobuf_unittest.repeated_uint64_extension", 
  TestAllExtensions, 
  { no: 34, kind: "scalar", T: 4 /* ScalarType.UINT64 */, repeated: true },
);

/**
 * @generated from extension: repeated sint32 repeated_sint32_extension = 35;
 */
export const repeated_sint32_extension = proto2.makeExtension<TestAllExtensions, number[]>(
  "protobuf_unittest.repeated_sint32_extension", 
  TestAllExtensions, 
  { no: 35, kind: "scalar", T: 17 /* ScalarType.SINT32 */, repeated: true },
);

/**
 * @generated from extension: repeated sint64 repeated_sint64_extension = 36;
 */
export const repeated_sint64_extension = proto2.makeExtension<TestAllExtensions, bigint[]>(
  "protobuf_unittest.repeated_sint64_extension", 
  TestAllExtensions, 
  { no: 36, kind: "scalar", T: 18 /* ScalarType.SINT64 */, repeated: true },
);

/**
 * @generated from extension: repeated fixed32 repeated_fixed32_extension = 37;
 */
export const repeated_fixed32_extension = proto2.makeExtension<TestAllExtensions, number[]>(
  "protobuf_unittest.repeated_fixed32_extension", 
  TestAllExtensions, 
  { no: 37, kind: "scalar", T: 7 /* ScalarType.FIXED32 */, repeated: true },
);

/**
 * @generated from extension: repeated fixed64 repeated_fixed64_extension = 38;
 */
export const repeated_fixed64_extension = proto2.makeExtension<TestAllExtensions, bigint[]>(
  "protobuf_unittest.repeated_fixed64_extension", 
  TestAllExtensions, 
  { no: 38, kind: "scalar", T: 6 /* ScalarType.FIXED64 */, repeated: true },
);

/**
 * @generated from extension: repeated sfixed32 repeated_sfixed32_extension = 39;
 */
export const repeated_sfixed32_extension = proto2.makeExtension<TestAllExtensions, number[]>(
  "protobuf_unittest.repeated_sfixed32_extension", 
  TestAllExtensions, 
  { no: 39, kind: "scalar", T: 15 /* ScalarType.SFIXED32 */, repeated: true },
);

/**
 * @generated from extension: repeated sfixed64 repeated_sfixed64_extension = 40;
 */
export const repeated_sfixed64_extension = proto2.makeExtension<TestAllExtensions, bigint[]>(
  "protobuf_unittest.repeated_sfixed64_extension", 
  TestAllExtensions, 
  { no: 40, kind: "scalar", T: 16 /* ScalarType.SFIXED64 */, repeated: true },
);

/**
 * @generated from extension: repeated float repeated_float_extension = 41;
 */
export const repeated_float_extension = proto2.makeExtension<TestAllExtensions, number[]>(
  "protobuf_unittest.repeated_float_extension", 
  TestAllExtensions, 
  { no: 41, kind: "scalar", T: 2 /* ScalarType.FLOAT */, repeated: true },
);

/**
 * @generated from extension: repeated double repeated_double_extension = 42;
 */
export const repeated_double_extension = proto2.makeExtension<TestAllExtensions, number[]>(
  "protobuf_unittest.repeated_double_extension", 
  TestAllExtensions, 
  { no: 42, kind: "scalar", T: 1 /* ScalarType.DOUBLE */, repeated: true },
);

/**
 * @generated from extension: repeated bool repeated_bool_extension = 43;
 */
export const repeated_bool_extension = proto2.makeExtension<TestAllExtensions, boolean[]>(
  "protobuf_unittest.repeated_bool_extension", 
  TestAllExtensions, 
  { no: 43, kind: "scalar", T: 8 /* ScalarType.BOOL */, repeated: true },
);

/**
 * @generated from extension: repeated string repeated_string_extension = 44;
 */
export const repeated_string_extension = proto2.makeExtension<TestAllExtensions, string[]>(
  "protobuf_unittest.repeated_string_extension", 
  TestAllExtensions, 
  { no: 44, kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
);

/**
 * @generated from extension: repeated bytes repeated_bytes_extension = 45;
 */
export const repeated_bytes_extension = proto2.makeExtension<TestAllExtensions, Uint8Array[]>(
  "protobuf_unittest.repeated_bytes_extension", 
  TestAllExtensions, 
  { no: 45, kind: "scalar", T: 12 /* ScalarType.BYTES */, repeated: true },
);

/**
 * @generated from extension: repeated protobuf_unittest.RepeatedGroup_extension repeatedgroup_extension = 46;
 */
export const repeatedgroup_extension = proto2.makeExtension<TestAllExtensions, RepeatedGroup_extension[]>(
  "protobuf_unittest.repeatedgroup_extension", 
  TestAllExtensions, 
  () => ({ no: 46, kind: "message", T: RepeatedGroup_extension, delimited: true, repeated: true }),
);

/**
 * @generated from extension: repeated protobuf_unittest.TestAllTypes.NestedMessage repeated_nested_message_extension = 48;
 */
export const repeated_nested_message_extension = proto2.makeExtension<TestAllExtensions, TestAllTypes_NestedMessage[]>(
  "protobuf_unittest.repeated_nested_message_extension", 
  TestAllExtensions, 
  () => ({ no: 48, kind: "message", T: TestAllTypes_NestedMessage, repeated: true }),
);

/**
 * @generated from extension: repeated protobuf_unittest.ForeignMessage repeated_foreign_message_extension = 49;
 */
export const repeated_foreign_message_extension = proto2.makeExtension<TestAllExtensions, ForeignMessage[]>(
  "protobuf_unittest.repeated_foreign_message_extension", 
  TestAllExtensions, 
  () => ({ no: 49, kind: "message", T: ForeignMessage, repeated: true }),
);

/**
 * @generated from extension: repeated protobuf_unittest_import.ImportMessage repeated_import_message_extension = 50;
 */
export const repeated_import_message_extension = proto2.makeExtension<TestAllExtensions, ImportMessage[]>(
  "protobuf_unittest.repeated_import_message_extension", 
  TestAllExtensions, 
  () => ({ no: 50, kind: "message", T: ImportMessage, repeated: true }),
);

/**
 * @generated from extension: repeated protobuf_unittest.TestAllTypes.NestedEnum repeated_nested_enum_extension = 51;
 */
export const repeated_nested_enum_extension = proto2.makeExtension<TestAllExtensions, TestAllTypes_NestedEnum[]>(
  "protobuf_unittest.repeated_nested_enum_extension", 
  TestAllExtensions, 
  () => ({ no: 51, kind: "enum", T: proto2.getEnumType(TestAllTypes_NestedEnum), repeated: true }),
);

/**
 * @generated from extension: repeated protobuf_unittest.ForeignEnum repeated_foreign_enum_extension = 52;
 */
export const repeated_foreign_enum_extension = proto2.makeExtension<TestAllExtensions, ForeignEnum[]>(
  "protobuf_unittest.repeated_foreign_enum_extension", 
  TestAllExtensions, 
  () => ({ no: 52, kind: "enum", T: proto2.getEnumType(ForeignEnum), repeated: true }),
);

/**
 * @generated from extension: repeated protobuf_unittest_import.ImportEnum repeated_import_enum_extension = 53;
 */
export const repeated_import_enum_extension = proto2.makeExtension<TestAllExtensions, ImportEnum[]>(
  "protobuf_unittest.repeated_import_enum_extension", 
  TestAllExtensions, 
  () => ({ no: 53, kind: "enum", T: proto2.getEnumType(ImportEnum), repeated: true }),
);

/**
 * @generated from extension: repeated string repeated_string_piece_extension = 54;
 */
export const repeated_string_piece_extension = proto2.makeExtension<TestAllExtensions, string[]>(
  "protobuf_unittest.repeated_string_piece_extension", 
  TestAllExtensions, 
  { no: 54, kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
);

/**
 * TODO: ctype=CORD is not supported for extension. Add
 * ctype=CORD option back after it is supported.
 *
 * @generated from extension: repeated string repeated_cord_extension = 55;
 */
export const repeated_cord_extension = proto2.makeExtension<TestAllExtensions, string[]>(
  "protobuf_unittest.repeated_cord_extension", 
  TestAllExtensions, 
  { no: 55, kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
);

/**
 * @generated from extension: repeated protobuf_unittest.TestAllTypes.NestedMessage repeated_lazy_message_extension = 57;
 */
export const repeated_lazy_message_extension = proto2.makeExtension<TestAllExtensions, TestAllTypes_NestedMessage[]>(
  "protobuf_unittest.repeated_lazy_message_extension", 
  TestAllExtensions, 
  () => ({ no: 57, kind: "message", T: TestAllTypes_NestedMessage, repeated: true }),
);

/**
 * Singular with defaults
 *
 * @generated from extension: optional int32 default_int32_extension = 61 [default = 41];
 */
export const default_int32_extension = proto2.makeExtension<TestAllExtensions, number>(
  "protobuf_unittest.default_int32_extension", 
  TestAllExtensions, 
  { no: 61, kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true, default: 41 },
);

/**
 * @generated from extension: optional int64 default_int64_extension = 62 [default = 42];
 */
export const default_int64_extension = proto2.makeExtension<TestAllExtensions, bigint>(
  "protobuf_unittest.default_int64_extension", 
  TestAllExtensions, 
  { no: 62, kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true, default: protoInt64.parse("42") },
);

/**
 * @generated from extension: optional uint32 default_uint32_extension = 63 [default = 43];
 */
export const default_uint32_extension = proto2.makeExtension<TestAllExtensions, number>(
  "protobuf_unittest.default_uint32_extension", 
  TestAllExtensions, 
  { no: 63, kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true, default: 43 },
);

/**
 * @generated from extension: optional uint64 default_uint64_extension = 64 [default = 44];
 */
export const default_uint64_extension = proto2.makeExtension<TestAllExtensions, bigint>(
  "protobuf_unittest.default_uint64_extension", 
  TestAllExtensions, 
  { no: 64, kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true, default: protoInt64.uParse("44") },
);

/**
 * @generated from extension: optional sint32 default_sint32_extension = 65 [default = -45];
 */
export const default_sint32_extension = proto2.makeExtension<TestAllExtensions, number>(
  "protobuf_unittest.default_sint32_extension", 
  TestAllExtensions, 
  { no: 65, kind: "scalar", T: 17 /* ScalarType.SINT32 */, opt: true, default: -45 },
);

/**
 * @generated from extension: optional sint64 default_sint64_extension = 66 [default = 46];
 */
export const default_sint64_extension = proto2.makeExtension<TestAllExtensions, bigint>(
  "protobuf_unittest.default_sint64_extension", 
  TestAllExtensions, 
  { no: 66, kind: "scalar", T: 18 /* ScalarType.SINT64 */, opt: true, default: protoInt64.parse("46") },
);

/**
 * @generated from extension: optional fixed32 default_fixed32_extension = 67 [default = 47];
 */
export const default_fixed32_extension = proto2.makeExtension<TestAllExtensions, number>(
  "protobuf_unittest.default_fixed32_extension", 
  TestAllExtensions, 
  { no: 67, kind: "scalar", T: 7 /* ScalarType.FIXED32 */, opt: true, default: 47 },
);

/**
 * @generated from extension: optional fixed64 default_fixed64_extension = 68 [default = 48];
 */
export const default_fixed64_extension = proto2.makeExtension<TestAllExtensions, bigint>(
  "protobuf_unittest.default_fixed64_extension", 
  TestAllExtensions, 
  { no: 68, kind: "scalar", T: 6 /* ScalarType.FIXED64 */, opt: true, default: protoInt64.uParse("48") },
);

/**
 * @generated from extension: optional sfixed32 default_sfixed32_extension = 69 [default = 49];
 */
export const default_sfixed32_extension = proto2.makeExtension<TestAllExtensions, number>(
  "protobuf_unittest.default_sfixed32_extension", 
  TestAllExtensions, 
  { no: 69, kind: "scalar", T: 15 /* ScalarType.SFIXED32 */, opt: true, default: 49 },
);

/**
 * @generated from extension: optional sfixed64 default_sfixed64_extension = 70 [default = -50];
 */
export const default_sfixed64_extension = proto2.makeExtension<TestAllExtensions, bigint>(
  "protobuf_unittest.default_sfixed64_extension", 
  TestAllExtensions, 
  { no: 70, kind: "scalar", T: 16 /* ScalarType.SFIXED64 */, opt: true, default: protoInt64.parse("-50") },
);

/**
 * @generated from extension: optional float default_float_extension = 71 [default = 51.5];
 */
export const default_float_extension = proto2.makeExtension<TestAllExtensions, number>(
  "protobuf_unittest.default_float_extension", 
  TestAllExtensions, 
  { no: 71, kind: "scalar", T: 2 /* ScalarType.FLOAT */, opt: true, default: 51.5 },
);

/**
 * @generated from extension: optional double default_double_extension = 72 [default = 52000];
 */
export const default_double_extension = proto2.makeExtension<TestAllExtensions, number>(
  "protobuf_unittest.default_double_extension", 
  TestAllExtensions, 
  { no: 72, kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true, default: 52000 },
);

/**
 * @generated from extension: optional bool default_bool_extension = 73 [default = true];
 */
export const default_bool_extension = proto2.makeExtension<TestAllExtensions, boolean>(
  "protobuf_unittest.default_bool_extension", 
  TestAllExtensions, 
  { no: 73, kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true, default: true },
);

/**
 * @generated from extension: optional string default_string_extension = 74 [default = "hello"];
 */
export const default_string_extension = proto2.makeExtension<TestAllExtensions, string>(
  "protobuf_unittest.default_string_extension", 
  TestAllExtensions, 
  { no: 74, kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true, default: "hello" },
);

/**
 * @generated from extension: optional bytes default_bytes_extension = 75 [default = "world"];
 */
export const default_bytes_extension = proto2.makeExtension<TestAllExtensions, Uint8Array>(
  "protobuf_unittest.default_bytes_extension", 
  TestAllExtensions, 
  { no: 75, kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true, default: new Uint8Array([0x77, 0x6F, 0x72, 0x6C, 0x64]) },
);

/**
 * @generated from extension: optional protobuf_unittest.TestAllTypes.NestedEnum default_nested_enum_extension = 81 [default = BAR];
 */
export const default_nested_enum_extension = proto2.makeExtension<TestAllExtensions, TestAllTypes_NestedEnum>(
  "protobuf_unittest.default_nested_enum_extension", 
  TestAllExtensions, 
  () => ({ no: 81, kind: "enum", T: proto2.getEnumType(TestAllTypes_NestedEnum), opt: true, default: TestAllTypes_NestedEnum.BAR }),
);

/**
 * @generated from extension: optional protobuf_unittest.ForeignEnum default_foreign_enum_extension = 82 [default = FOREIGN_BAR];
 */
export const default_foreign_enum_extension = proto2.makeExtension<TestAllExtensions, ForeignEnum>(
  "protobuf_unittest.default_foreign_enum_extension", 
  TestAllExtensions, 
  () => ({ no: 82, kind: "enum", T: proto2.getEnumType(ForeignEnum), opt: true, default: ForeignEnum.FOREIGN_BAR }),
);

/**
 * @generated from extension: optional protobuf_unittest_import.ImportEnum default_import_enum_extension = 83 [default = IMPORT_BAR];
 */
export const default_import_enum_extension = proto2.makeExtension<TestAllExtensions, ImportEnum>(
  "protobuf_unittest.default_import_enum_extension", 
  TestAllExtensions, 
  () => ({ no: 83, kind: "enum", T: proto2.getEnumType(ImportEnum), opt: true, default: ImportEnum.IMPORT_BAR }),
);

/**
 * @generated from extension: optional string default_string_piece_extension = 84 [default = "abc"];
 */
export const default_string_piece_extension = proto2.makeExtension<TestAllExtensions, string>(
  "protobuf_unittest.default_string_piece_extension", 
  TestAllExtensions, 
  { no: 84, kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true, default: "abc" },
);

/**
 * TODO: ctype=CORD is not supported for extension. Add
 * ctype=CORD option back after it is supported.
 *
 * @generated from extension: optional string default_cord_extension = 85 [default = "123"];
 */
export const default_cord_extension = proto2.makeExtension<TestAllExtensions, string>(
  "protobuf_unittest.default_cord_extension", 
  TestAllExtensions, 
  { no: 85, kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true, default: "123" },
);

/**
 * For oneof test
 *
 * @generated from extension: optional uint32 oneof_uint32_extension = 111;
 */
export const oneof_uint32_extension = proto2.makeExtension<TestAllExtensions, number>(
  "protobuf_unittest.oneof_uint32_extension", 
  TestAllExtensions, 
  { no: 111, kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
);

/**
 * @generated from extension: optional protobuf_unittest.TestAllTypes.NestedMessage oneof_nested_message_extension = 112;
 */
export const oneof_nested_message_extension = proto2.makeExtension<TestAllExtensions, TestAllTypes_NestedMessage>(
  "protobuf_unittest.oneof_nested_message_extension", 
  TestAllExtensions, 
  () => ({ no: 112, kind: "message", T: TestAllTypes_NestedMessage, opt: true }),
);

/**
 * @generated from extension: optional string oneof_string_extension = 113;
 */
export const oneof_string_extension = proto2.makeExtension<TestAllExtensions, string>(
  "protobuf_unittest.oneof_string_extension", 
  TestAllExtensions, 
  { no: 113, kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
);

/**
 * @generated from extension: optional bytes oneof_bytes_extension = 114;
 */
export const oneof_bytes_extension = proto2.makeExtension<TestAllExtensions, Uint8Array>(
  "protobuf_unittest.oneof_bytes_extension", 
  TestAllExtensions, 
  { no: 114, kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
);

/**
 * @generated from extension: optional string my_extension_string = 50;
 */
export const my_extension_string = proto2.makeExtension<TestFieldOrderings, string>(
  "protobuf_unittest.my_extension_string", 
  TestFieldOrderings, 
  { no: 50, kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
);

/**
 * @generated from extension: optional int32 my_extension_int = 5;
 */
export const my_extension_int = proto2.makeExtension<TestFieldOrderings, number>(
  "protobuf_unittest.my_extension_int", 
  TestFieldOrderings, 
  { no: 5, kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
);

/**
 * @generated from extension: repeated int32 packed_int32_extension = 90 [packed = true];
 */
export const packed_int32_extension = proto2.makeExtension<TestPackedExtensions, number[]>(
  "protobuf_unittest.packed_int32_extension", 
  TestPackedExtensions, 
  { no: 90, kind: "scalar", T: 5 /* ScalarType.INT32 */, repeated: true, packed: true },
);

/**
 * @generated from extension: repeated int64 packed_int64_extension = 91 [packed = true];
 */
export const packed_int64_extension = proto2.makeExtension<TestPackedExtensions, bigint[]>(
  "protobuf_unittest.packed_int64_extension", 
  TestPackedExtensions, 
  { no: 91, kind: "scalar", T: 3 /* ScalarType.INT64 */, repeated: true, packed: true },
);

/**
 * @generated from extension: repeated uint32 packed_uint32_extension = 92 [packed = true];
 */
export const packed_uint32_extension = proto2.makeExtension<TestPackedExtensions, number[]>(
  "protobuf_unittest.packed_uint32_extension", 
  TestPackedExtensions, 
  { no: 92, kind: "scalar", T: 13 /* ScalarType.UINT32 */, repeated: true, packed: true },
);

/**
 * @generated from extension: repeated uint64 packed_uint64_extension = 93 [packed = true];
 */
export const packed_uint64_extension = proto2.makeExtension<TestPackedExtensions, bigint[]>(
  "protobuf_unittest.packed_uint64_extension", 
  TestPackedExtensions, 
  { no: 93, kind: "scalar", T: 4 /* ScalarType.UINT64 */, repeated: true, packed: true },
);

/**
 * @generated from extension: repeated sint32 packed_sint32_extension = 94 [packed = true];
 */
export const packed_sint32_extension = proto2.makeExtension<TestPackedExtensions, number[]>(
  "protobuf_unittest.packed_sint32_extension", 
  TestPackedExtensions, 
  { no: 94, kind: "scalar", T: 17 /* ScalarType.SINT32 */, repeated: true, packed: true },
);

/**
 * @generated from extension: repeated sint64 packed_sint64_extension = 95 [packed = true];
 */
export const packed_sint64_extension = proto2.makeExtension<TestPackedExtensions, bigint[]>(
  "protobuf_unittest.packed_sint64_extension", 
  TestPackedExtensions, 
  { no: 95, kind: "scalar", T: 18 /* ScalarType.SINT64 */, repeated: true, packed: true },
);

/**
 * @generated from extension: repeated fixed32 packed_fixed32_extension = 96 [packed = true];
 */
export const packed_fixed32_extension = proto2.makeExtension<TestPackedExtensions, number[]>(
  "protobuf_unittest.packed_fixed32_extension", 
  TestPackedExtensions, 
  { no: 96, kind: "scalar", T: 7 /* ScalarType.FIXED32 */, repeated: true, packed: true },
);

/**
 * @generated from extension: repeated fixed64 packed_fixed64_extension = 97 [packed = true];
 */
export const packed_fixed64_extension = proto2.makeExtension<TestPackedExtensions, bigint[]>(
  "protobuf_unittest.packed_fixed64_extension", 
  TestPackedExtensions, 
  { no: 97, kind: "scalar", T: 6 /* ScalarType.FIXED64 */, repeated: true, packed: true },
);

/**
 * @generated from extension: repeated sfixed32 packed_sfixed32_extension = 98 [packed = true];
 */
export const packed_sfixed32_extension = proto2.makeExtension<TestPackedExtensions, number[]>(
  "protobuf_unittest.packed_sfixed32_extension", 
  TestPackedExtensions, 
  { no: 98, kind: "scalar", T: 15 /* ScalarType.SFIXED32 */, repeated: true, packed: true },
);

/**
 * @generated from extension: repeated sfixed64 packed_sfixed64_extension = 99 [packed = true];
 */
export const packed_sfixed64_extension = proto2.makeExtension<TestPackedExtensions, bigint[]>(
  "protobuf_unittest.packed_sfixed64_extension", 
  TestPackedExtensions, 
  { no: 99, kind: "scalar", T: 16 /* ScalarType.SFIXED64 */, repeated: true, packed: true },
);

/**
 * @generated from extension: repeated float packed_float_extension = 100 [packed = true];
 */
export const packed_float_extension = proto2.makeExtension<TestPackedExtensions, number[]>(
  "protobuf_unittest.packed_float_extension", 
  TestPackedExtensions, 
  { no: 100, kind: "scalar", T: 2 /* ScalarType.FLOAT */, repeated: true, packed: true },
);

/**
 * @generated from extension: repeated double packed_double_extension = 101 [packed = true];
 */
export const packed_double_extension = proto2.makeExtension<TestPackedExtensions, number[]>(
  "protobuf_unittest.packed_double_extension", 
  TestPackedExtensions, 
  { no: 101, kind: "scalar", T: 1 /* ScalarType.DOUBLE */, repeated: true, packed: true },
);

/**
 * @generated from extension: repeated bool packed_bool_extension = 102 [packed = true];
 */
export const packed_bool_extension = proto2.makeExtension<TestPackedExtensions, boolean[]>(
  "protobuf_unittest.packed_bool_extension", 
  TestPackedExtensions, 
  { no: 102, kind: "scalar", T: 8 /* ScalarType.BOOL */, repeated: true, packed: true },
);

/**
 * @generated from extension: repeated protobuf_unittest.ForeignEnum packed_enum_extension = 103 [packed = true];
 */
export const packed_enum_extension = proto2.makeExtension<TestPackedExtensions, ForeignEnum[]>(
  "protobuf_unittest.packed_enum_extension", 
  TestPackedExtensions, 
  () => ({ no: 103, kind: "enum", T: proto2.getEnumType(ForeignEnum), repeated: true, packed: true }),
);

/**
 * @generated from extension: repeated int32 unpacked_int32_extension = 90 [packed = false];
 */
export const unpacked_int32_extension = proto2.makeExtension<TestUnpackedExtensions, number[]>(
  "protobuf_unittest.unpacked_int32_extension", 
  TestUnpackedExtensions, 
  { no: 90, kind: "scalar", T: 5 /* ScalarType.INT32 */, repeated: true },
);

/**
 * @generated from extension: repeated int64 unpacked_int64_extension = 91 [packed = false];
 */
export const unpacked_int64_extension = proto2.makeExtension<TestUnpackedExtensions, bigint[]>(
  "protobuf_unittest.unpacked_int64_extension", 
  TestUnpackedExtensions, 
  { no: 91, kind: "scalar", T: 3 /* ScalarType.INT64 */, repeated: true },
);

/**
 * @generated from extension: repeated uint32 unpacked_uint32_extension = 92 [packed = false];
 */
export const unpacked_uint32_extension = proto2.makeExtension<TestUnpackedExtensions, number[]>(
  "protobuf_unittest.unpacked_uint32_extension", 
  TestUnpackedExtensions, 
  { no: 92, kind: "scalar", T: 13 /* ScalarType.UINT32 */, repeated: true },
);

/**
 * @generated from extension: repeated uint64 unpacked_uint64_extension = 93 [packed = false];
 */
export const unpacked_uint64_extension = proto2.makeExtension<TestUnpackedExtensions, bigint[]>(
  "protobuf_unittest.unpacked_uint64_extension", 
  TestUnpackedExtensions, 
  { no: 93, kind: "scalar", T: 4 /* ScalarType.UINT64 */, repeated: true },
);

/**
 * @generated from extension: repeated sint32 unpacked_sint32_extension = 94 [packed = false];
 */
export const unpacked_sint32_extension = proto2.makeExtension<TestUnpackedExtensions, number[]>(
  "protobuf_unittest.unpacked_sint32_extension", 
  TestUnpackedExtensions, 
  { no: 94, kind: "scalar", T: 17 /* ScalarType.SINT32 */, repeated: true },
);

/**
 * @generated from extension: repeated sint64 unpacked_sint64_extension = 95 [packed = false];
 */
export const unpacked_sint64_extension = proto2.makeExtension<TestUnpackedExtensions, bigint[]>(
  "protobuf_unittest.unpacked_sint64_extension", 
  TestUnpackedExtensions, 
  { no: 95, kind: "scalar", T: 18 /* ScalarType.SINT64 */, repeated: true },
);

/**
 * @generated from extension: repeated fixed32 unpacked_fixed32_extension = 96 [packed = false];
 */
export const unpacked_fixed32_extension = proto2.makeExtension<TestUnpackedExtensions, number[]>(
  "protobuf_unittest.unpacked_fixed32_extension", 
  TestUnpackedExtensions, 
  { no: 96, kind: "scalar", T: 7 /* ScalarType.FIXED32 */, repeated: true },
);

/**
 * @generated from extension: repeated fixed64 unpacked_fixed64_extension = 97 [packed = false];
 */
export const unpacked_fixed64_extension = proto2.makeExtension<TestUnpackedExtensions, bigint[]>(
  "protobuf_unittest.unpacked_fixed64_extension", 
  TestUnpackedExtensions, 
  { no: 97, kind: "scalar", T: 6 /* ScalarType.FIXED64 */, repeated: true },
);

/**
 * @generated from extension: repeated sfixed32 unpacked_sfixed32_extension = 98 [packed = false];
 */
export const unpacked_sfixed32_extension = proto2.makeExtension<TestUnpackedExtensions, number[]>(
  "protobuf_unittest.unpacked_sfixed32_extension", 
  TestUnpackedExtensions, 
  { no: 98, kind: "scalar", T: 15 /* ScalarType.SFIXED32 */, repeated: true },
);

/**
 * @generated from extension: repeated sfixed64 unpacked_sfixed64_extension = 99 [packed = false];
 */
export const unpacked_sfixed64_extension = proto2.makeExtension<TestUnpackedExtensions, bigint[]>(
  "protobuf_unittest.unpacked_sfixed64_extension", 
  TestUnpackedExtensions, 
  { no: 99, kind: "scalar", T: 16 /* ScalarType.SFIXED64 */, repeated: true },
);

/**
 * @generated from extension: repeated float unpacked_float_extension = 100 [packed = false];
 */
export const unpacked_float_extension = proto2.makeExtension<TestUnpackedExtensions, number[]>(
  "protobuf_unittest.unpacked_float_extension", 
  TestUnpackedExtensions, 
  { no: 100, kind: "scalar", T: 2 /* ScalarType.FLOAT */, repeated: true },
);

/**
 * @generated from extension: repeated double unpacked_double_extension = 101 [packed = false];
 */
export const unpacked_double_extension = proto2.makeExtension<TestUnpackedExtensions, number[]>(
  "protobuf_unittest.unpacked_double_extension", 
  TestUnpackedExtensions, 
  { no: 101, kind: "scalar", T: 1 /* ScalarType.DOUBLE */, repeated: true },
);

/**
 * @generated from extension: repeated bool unpacked_bool_extension = 102 [packed = false];
 */
export const unpacked_bool_extension = proto2.makeExtension<TestUnpackedExtensions, boolean[]>(
  "protobuf_unittest.unpacked_bool_extension", 
  TestUnpackedExtensions, 
  { no: 102, kind: "scalar", T: 8 /* ScalarType.BOOL */, repeated: true },
);

/**
 * @generated from extension: repeated protobuf_unittest.ForeignEnum unpacked_enum_extension = 103 [packed = false];
 */
export const unpacked_enum_extension = proto2.makeExtension<TestUnpackedExtensions, ForeignEnum[]>(
  "protobuf_unittest.unpacked_enum_extension", 
  TestUnpackedExtensions, 
  () => ({ no: 103, kind: "enum", T: proto2.getEnumType(ForeignEnum), repeated: true }),
);

/**
 * @generated from extension: optional protobuf_unittest.TestAllTypes test_all_types = 536860000;
 */
export const test_all_types = proto2.makeExtension<TestHugeFieldNumbers, TestAllTypes>(
  "protobuf_unittest.test_all_types", 
  TestHugeFieldNumbers, 
  () => ({ no: 536860000, kind: "message", T: TestAllTypes, opt: true }),
);

/**
 * @generated from extension: optional int32 test_extension_inside_table_extension = 5;
 */
export const test_extension_inside_table_extension = proto2.makeExtension<TestExtensionInsideTable, number>(
  "protobuf_unittest.test_extension_inside_table_extension", 
  TestExtensionInsideTable, 
  { no: 5, kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
);

/**
 * @generated from extension: optional protobuf_unittest.TestNestedGroupExtensionInnerExtension inner = 3;
 */
export const inner = proto2.makeExtension<TestNestedGroupExtensionOuter_Layer1OptionalGroup_Layer2RepeatedGroup, TestNestedGroupExtensionInnerExtension>(
  "protobuf_unittest.inner", 
  TestNestedGroupExtensionOuter_Layer1OptionalGroup_Layer2RepeatedGroup, 
  () => ({ no: 3, kind: "message", T: TestNestedGroupExtensionInnerExtension, opt: true }),
);

