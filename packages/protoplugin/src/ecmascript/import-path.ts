import { codegenInfo, DescFile } from "@bufbuild/protobuf";

/**
 * A configuration of import path redirections, a feature mainly used for
 * remote code generation in the BSR npm registry, which makes it possible
 * to serve the output of a BSR module and a plugin in an individual package.
 *
 * All plugins based on @bufbuild/protoplugin support the option
 * "redirect_imports", which is parsed into this type. The option can be given
 * multiple times, in the form of `redirect_imports=<pattern>:<target>`.
 * If any generated file imports from a path matching a pattern, the import
 * path is redirected to the corresponding target. The first matching pattern
 * wins. As a result, the target is prepended to the import path, stripping
 * any leading ./ or ../ from the import path first.
 *
 * The pattern is a very reduced subset of glob:
 * - `*` matches zero or more characters except `/`.
 * - `**` matches zero or more path elements, where an element is one or more
 *   characters with a trailing `/`.
 *
 * For example, the pattern `./foo/**\/*_pb.js` matches:
 * - ./foo/bar_pb.js
 * - ./foo/bar/baz_pb.js
 *
 * But neither of:
 * - ./bar_pb.js
 * - ./foo/bar_pb.js
 *
 * With the target `@scope/pkg`, the import path `./foo/bar_pb.js` is
 * transformed to `@scope/pkg/foo/bar_pb.js`.
 */
export type ImportRedirections = { pattern: string; target: string }[];

const cache = new WeakMap<ImportRedirections, { pattern: RegExp; target: string }[]>();

/**
 * Apply import redirection to the given path.
 */
export function redirectImport(importPath: string, redirectedImports: ImportRedirections): string {
  let ri = cache.get(redirectedImports);
  if (ri === undefined) {
    ri = redirectedImports.map(({ pattern, target }) => {
      return {
        pattern: starToRegExp(pattern),
        target
      };
    });
    cache.set(redirectedImports, ri);
  }
  for (const { pattern, target } of ri) {
    if (pattern.test(importPath)) {
      return target.replace(/\/$/, "") + importPath.replace(relativePathRE, "/");
    }
  }
  return importPath;
}

function starToRegExp(star: string): RegExp {
  const r: string[] = ["^"];
  for (let i = 0; i < star.length; i++) {
    switch (star[i]) {
      case "*":
        if (star[i+1] === "*" && star[i+2] === "/") {
          i += 2;
          r.push("([^\\/]+\\/)*");
          break;
        }
        r.push("[^\\/]*");
        break;
      case ".":
      case "+":
      case "?":
      case "^":
      case "$":
      case "{":
      case "}":
      case "(":
      case ")":
      case "|":
      case "[":
      case "]":
      case "\\":
        r.push("\\", star[i]);
        break;
      default:
        r.push(star[i]);
        break;
    }
  }
  r.push("$");
  return new RegExp(r.join(""));
}

/**
 * Returns the import path for files generated by the base type generator
 * protoc-gen-es.
 */
export function makeImportPath(
  file: DescFile,
  bootstrapWkt: boolean,
  filesToGenerate: DescFile[]
): string {
  // Well-known types are published with the runtime package. We usually want
  // the generated code to import them from the runtime package, with the
  // following exceptions:
  // 1. We are bootstrapping the runtime package via the plugin option
  //    "bootstrap_wkt". In that case, we cannot refer to the runtime package
  //    itself.
  // 2. We were explicitly asked to generate the well-known type.
  if (
    !bootstrapWkt &&
    !filesToGenerate.includes(file) &&
    codegenInfo.wktSourceFiles.includes(file.name + ".proto")
  ) {
    return codegenInfo.packageName;
  }
  return "./" + file.name + "_pb.js";
}

export const relativePathRE = /^\.{1,2}\//;

/**
 * Derives an ECMAScript module import path from a file path. For example,
 * the path `foo/bar.ts` is transformed into `./foo/bar.js`.
 */
export function deriveImportPath(filename: string): string {
  let importPath = filename.replace(/\.(js|ts|d.ts)$/, ".js");
  if (!relativePathRE.test(importPath)) {
    importPath = "./" + importPath;
  }
  return importPath;
}

/**
 * Makes an import path relative to the file importing it. For example,
 * consider the following files:
 * - foo/foo.js
 * - baz.js
 * If foo.js wants to import baz.js, we return ../baz.js
 */
export function makeImportPathRelative(importer: string, importPath: string): string {
  if (!relativePathRE.test(importPath)) {
    // We don't touch absolute imports, like @bufbuild/protobuf
    return importPath;
  }
  let a = importer
    .replace(/^\.\//, "")
    .split("/")
    .filter((p) => p.length > 0)
    .slice(0, -1);
  let b = importPath
    .replace(/^\.\//, "")
    .split("/")
    .filter((p) => p.length > 0);
  let matchingPartCount = 0;
  for (
    let l = Math.min(a.length, b.length);
    matchingPartCount < l;
    matchingPartCount++
  ) {
    if (a[matchingPartCount] !== b[matchingPartCount]) {
      break;
    }
  }
  a = a.slice(matchingPartCount);
  b = b.slice(matchingPartCount);
  const c = a
    .map(() => "..")
    .concat(b)
    .join("/");
  return relativePathRE.test(c) ? c : "./" + c;
}
