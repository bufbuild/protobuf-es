// Copyright 2021-2024 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.0.0-alpha.1 with parameter "ts_nocheck=false,target=ts"
// @generated from file buf/alpha/image/v1/image.proto (package buf.alpha.image.v1, syntax proto2)
/* eslint-disable */

import type { GenDescFile, GenDescMessage } from "@bufbuild/protobuf/codegenv1";
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { DescriptorProto, EnumDescriptorProto, FieldDescriptorProto, FileOptions, ServiceDescriptorProto, SourceCodeInfo } from "@bufbuild/protobuf/wkt";
import { fileDesc_google_protobuf_descriptor } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

export const fileDesc_buf_alpha_image_v1_image: GenDescFile = /*@__PURE__*/
  fileDesc("Ch5idWYvYWxwaGEvaW1hZ2UvdjEvaW1hZ2UucHJvdG8SEmJ1Zi5hbHBoYS5pbWFnZS52MSI0CgVJbWFnZRIrCgRmaWxlGAEgAygLMh0uYnVmLmFscGhhLmltYWdlLnYxLkltYWdlRmlsZSKRBAoJSW1hZ2VGaWxlEgwKBG5hbWUYASABKAkSDwoHcGFja2FnZRgCIAEoCRISCgpkZXBlbmRlbmN5GAMgAygJEhkKEXB1YmxpY19kZXBlbmRlbmN5GAogAygFEhcKD3dlYWtfZGVwZW5kZW5jeRgLIAMoBRI2CgxtZXNzYWdlX3R5cGUYBCADKAsyIC5nb29nbGUucHJvdG9idWYuRGVzY3JpcHRvclByb3RvEjcKCWVudW1fdHlwZRgFIAMoCzIkLmdvb2dsZS5wcm90b2J1Zi5FbnVtRGVzY3JpcHRvclByb3RvEjgKB3NlcnZpY2UYBiADKAsyJy5nb29nbGUucHJvdG9idWYuU2VydmljZURlc2NyaXB0b3JQcm90bxI4CglleHRlbnNpb24YByADKAsyJS5nb29nbGUucHJvdG9idWYuRmllbGREZXNjcmlwdG9yUHJvdG8SLQoHb3B0aW9ucxgIIAEoCzIcLmdvb2dsZS5wcm90b2J1Zi5GaWxlT3B0aW9ucxI5ChBzb3VyY2VfY29kZV9pbmZvGAkgASgLMh8uZ29vZ2xlLnByb3RvYnVmLlNvdXJjZUNvZGVJbmZvEg4KBnN5bnRheBgMIAEoCRI+Cg1idWZfZXh0ZW5zaW9uGOo+IAEoCzImLmJ1Zi5hbHBoYS5pbWFnZS52MS5JbWFnZUZpbGVFeHRlbnNpb24ilgEKEkltYWdlRmlsZUV4dGVuc2lvbhIRCglpc19pbXBvcnQYASABKAgSMwoLbW9kdWxlX2luZm8YAiABKAsyHi5idWYuYWxwaGEuaW1hZ2UudjEuTW9kdWxlSW5mbxIdChVpc19zeW50YXhfdW5zcGVjaWZpZWQYAyABKAgSGQoRdW51c2VkX2RlcGVuZGVuY3kYBCADKAUiSgoKTW9kdWxlSW5mbxIsCgRuYW1lGAEgASgLMh4uYnVmLmFscGhhLmltYWdlLnYxLk1vZHVsZU5hbWUSDgoGY29tbWl0GAIgASgJIj8KCk1vZHVsZU5hbWUSDgoGcmVtb3RlGAEgASgJEg0KBW93bmVyGAIgASgJEhIKCnJlcG9zaXRvcnkYAyABKAlCBUgB+AEB", [fileDesc_google_protobuf_descriptor]);

/**
 * Image is an extended FileDescriptorSet.
 *
 * See https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/descriptor.proto
 *
 * @generated from message buf.alpha.image.v1.Image
 */
export type Image = Message<"buf.alpha.image.v1.Image"> & {
  /**
   * @generated from field: repeated buf.alpha.image.v1.ImageFile file = 1;
   */
  file: ImageFile[];
};

// Describes the message buf.alpha.image.v1.Image.
// Use `create(ImageDesc)` to create a new Image.
export const ImageDesc: GenDescMessage<Image> = /*@__PURE__*/
  messageDesc(fileDesc_buf_alpha_image_v1_image, 0);

/**
 * ImageFile is an extended FileDescriptorProto.
 *
 * Since FileDescriptorProto does not have extensions, we copy the fields from
 * FileDescriptorProto, and then add our own extensions via the
 * buf_image_file_extension field. This is compatible with a
 * FileDescriptorProto.
 *
 * See https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/descriptor.proto
 *
 * @generated from message buf.alpha.image.v1.ImageFile
 */
export type ImageFile = Message<"buf.alpha.image.v1.ImageFile"> & {
  /**
   * @generated from field: optional string name = 1;
   */
  name: string;

  /**
   * @generated from field: optional string package = 2;
   */
  package: string;

  /**
   * @generated from field: repeated string dependency = 3;
   */
  dependency: string[];

  /**
   * @generated from field: repeated int32 public_dependency = 10;
   */
  publicDependency: number[];

  /**
   * @generated from field: repeated int32 weak_dependency = 11;
   */
  weakDependency: number[];

  /**
   * @generated from field: repeated google.protobuf.DescriptorProto message_type = 4;
   */
  messageType: DescriptorProto[];

  /**
   * @generated from field: repeated google.protobuf.EnumDescriptorProto enum_type = 5;
   */
  enumType: EnumDescriptorProto[];

  /**
   * @generated from field: repeated google.protobuf.ServiceDescriptorProto service = 6;
   */
  service: ServiceDescriptorProto[];

  /**
   * @generated from field: repeated google.protobuf.FieldDescriptorProto extension = 7;
   */
  extension: FieldDescriptorProto[];

  /**
   * @generated from field: optional google.protobuf.FileOptions options = 8;
   */
  options?: FileOptions;

  /**
   * @generated from field: optional google.protobuf.SourceCodeInfo source_code_info = 9;
   */
  sourceCodeInfo?: SourceCodeInfo;

  /**
   * @generated from field: optional string syntax = 12;
   */
  syntax: string;

  /**
   * buf_extension contains buf-specific extensions to FileDescriptorProtos.
   *
   * The prefixed name and high tag value is used to all but guarantee there
   * will never be any conflict with Google's FileDescriptorProto definition.
   * The definition of a FileDescriptorProto has not changed in years, so
   * we're not too worried about a conflict here.
   *
   * @generated from field: optional buf.alpha.image.v1.ImageFileExtension buf_extension = 8042;
   */
  bufExtension?: ImageFileExtension;
};

// Describes the message buf.alpha.image.v1.ImageFile.
// Use `create(ImageFileDesc)` to create a new ImageFile.
export const ImageFileDesc: GenDescMessage<ImageFile> = /*@__PURE__*/
  messageDesc(fileDesc_buf_alpha_image_v1_image, 1);

/**
 * ImageFileExtension contains extensions to ImageFiles.
 *
 * The fields are not included directly on the ImageFile so that we can both
 * detect if extensions exist, which signifies this was created by buf and not
 * by protoc, and so that we can add fields in a freeform manner without
 * worrying about conflicts with FileDescriptorProto.
 *
 * @generated from message buf.alpha.image.v1.ImageFileExtension
 */
export type ImageFileExtension = Message<"buf.alpha.image.v1.ImageFileExtension"> & {
  /**
   * is_import denotes whether this file is considered an "import".
   *
   * An import is a file which was not derived from the local source files.
   * There are two cases where this could be true:
   *
   * 1. A Well-Known Type included from the compiler.
   * 2. A file that was included from a Buf module dependency.
   *
   * We use "import" as this matches with the protoc concept of
   * --include_imports, however import is a bit of an overloaded term.
   *
   * This will always be set.
   *
   * @generated from field: optional bool is_import = 1;
   */
  isImport: boolean;

  /**
   * ModuleInfo contains information about the Buf module this file belongs to.
   *
   * This field is optional and will not be set if the module is not known.
   *
   * @generated from field: optional buf.alpha.image.v1.ModuleInfo module_info = 2;
   */
  moduleInfo?: ModuleInfo;

  /**
   * is_syntax_unspecified denotes whether the file did not have a syntax
   * explicitly specified.
   *
   * Per the FileDescriptorProto spec, it would be fine in this case to just
   * leave the syntax field unset to denote this and to set the syntax field
   * to "proto2" if it is specified. However, protoc does not set the syntax
   * field if it was "proto2", and plugins may (incorrectly) depend on this.
   * We also want to maintain consistency with protoc as much as possible.
   * So instead, we have this field which will denote whether syntax was not
   * specified.
   *
   * This will always be set.
   *
   * @generated from field: optional bool is_syntax_unspecified = 3;
   */
  isSyntaxUnspecified: boolean;

  /**
   * unused_dependency are the indexes within the dependency field on
   * FileDescriptorProto for those dependencies that are not used.
   *
   * This matches the shape of the public_dependency and weak_dependency
   * fields.
   *
   * @generated from field: repeated int32 unused_dependency = 4;
   */
  unusedDependency: number[];
};

// Describes the message buf.alpha.image.v1.ImageFileExtension.
// Use `create(ImageFileExtensionDesc)` to create a new ImageFileExtension.
export const ImageFileExtensionDesc: GenDescMessage<ImageFileExtension> = /*@__PURE__*/
  messageDesc(fileDesc_buf_alpha_image_v1_image, 2);

/**
 * ModuleInfo contains information about a Buf module that an ImageFile
 * belongs to.
 *
 * @generated from message buf.alpha.image.v1.ModuleInfo
 */
export type ModuleInfo = Message<"buf.alpha.image.v1.ModuleInfo"> & {
  /**
   * name is the name of the Buf module.
   *
   * This will always be set.
   *
   * @generated from field: optional buf.alpha.image.v1.ModuleName name = 1;
   */
  name?: ModuleName;

  /**
   * commit is the repository commit.
   *
   * This field is optional and will not be set if the commit is not known.
   *
   * @generated from field: optional string commit = 2;
   */
  commit: string;
};

// Describes the message buf.alpha.image.v1.ModuleInfo.
// Use `create(ModuleInfoDesc)` to create a new ModuleInfo.
export const ModuleInfoDesc: GenDescMessage<ModuleInfo> = /*@__PURE__*/
  messageDesc(fileDesc_buf_alpha_image_v1_image, 3);

/**
 * ModuleName is a module name.
 *
 * All fields will always be set.
 *
 * @generated from message buf.alpha.image.v1.ModuleName
 */
export type ModuleName = Message<"buf.alpha.image.v1.ModuleName"> & {
  /**
   * @generated from field: optional string remote = 1;
   */
  remote: string;

  /**
   * @generated from field: optional string owner = 2;
   */
  owner: string;

  /**
   * @generated from field: optional string repository = 3;
   */
  repository: string;
};

// Describes the message buf.alpha.image.v1.ModuleName.
// Use `create(ModuleNameDesc)` to create a new ModuleName.
export const ModuleNameDesc: GenDescMessage<ModuleName> = /*@__PURE__*/
  messageDesc(fileDesc_buf_alpha_image_v1_image, 4);

